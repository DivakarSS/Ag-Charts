/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9662:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var tryToString = __webpack_require__(6330);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 6077:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 5787:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(7976);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 9670:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(111);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 1318:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(5656);
var toAbsoluteIndex = __webpack_require__(1400);
var lengthOfArrayLike = __webpack_require__(6244);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 3658:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(9781);
var isArray = __webpack_require__(3157);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 4326:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 648:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(1694);
var isCallable = __webpack_require__(614);
var classofRaw = __webpack_require__(4326);
var wellKnownSymbol = __webpack_require__(5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 9920:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasOwn = __webpack_require__(2597);
var ownKeys = __webpack_require__(3887);
var getOwnPropertyDescriptorModule = __webpack_require__(1236);
var definePropertyModule = __webpack_require__(3070);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 8880:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var definePropertyModule = __webpack_require__(3070);
var createPropertyDescriptor = __webpack_require__(9114);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 9114:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 8052:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var definePropertyModule = __webpack_require__(3070);
var makeBuiltIn = __webpack_require__(6339);
var defineGlobalProperty = __webpack_require__(3072);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 3072:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 9781:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 4154:
/***/ (function(module) {

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ 317:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var isObject = __webpack_require__(111);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 7207:
/***/ (function(module) {

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 3678:
/***/ (function(module) {

module.exports = {
  IndexSizeError: { s: 'INDEX_SIZE_ERR', c: 1, m: 1 },
  DOMStringSizeError: { s: 'DOMSTRING_SIZE_ERR', c: 2, m: 0 },
  HierarchyRequestError: { s: 'HIERARCHY_REQUEST_ERR', c: 3, m: 1 },
  WrongDocumentError: { s: 'WRONG_DOCUMENT_ERR', c: 4, m: 1 },
  InvalidCharacterError: { s: 'INVALID_CHARACTER_ERR', c: 5, m: 1 },
  NoDataAllowedError: { s: 'NO_DATA_ALLOWED_ERR', c: 6, m: 0 },
  NoModificationAllowedError: { s: 'NO_MODIFICATION_ALLOWED_ERR', c: 7, m: 1 },
  NotFoundError: { s: 'NOT_FOUND_ERR', c: 8, m: 1 },
  NotSupportedError: { s: 'NOT_SUPPORTED_ERR', c: 9, m: 1 },
  InUseAttributeError: { s: 'INUSE_ATTRIBUTE_ERR', c: 10, m: 1 },
  InvalidStateError: { s: 'INVALID_STATE_ERR', c: 11, m: 1 },
  SyntaxError: { s: 'SYNTAX_ERR', c: 12, m: 1 },
  InvalidModificationError: { s: 'INVALID_MODIFICATION_ERR', c: 13, m: 1 },
  NamespaceError: { s: 'NAMESPACE_ERR', c: 14, m: 1 },
  InvalidAccessError: { s: 'INVALID_ACCESS_ERR', c: 15, m: 1 },
  ValidationError: { s: 'VALIDATION_ERR', c: 16, m: 0 },
  TypeMismatchError: { s: 'TYPE_MISMATCH_ERR', c: 17, m: 1 },
  SecurityError: { s: 'SECURITY_ERR', c: 18, m: 1 },
  NetworkError: { s: 'NETWORK_ERR', c: 19, m: 1 },
  AbortError: { s: 'ABORT_ERR', c: 20, m: 1 },
  URLMismatchError: { s: 'URL_MISMATCH_ERR', c: 21, m: 1 },
  QuotaExceededError: { s: 'QUOTA_EXCEEDED_ERR', c: 22, m: 1 },
  TimeoutError: { s: 'TIMEOUT_ERR', c: 23, m: 1 },
  InvalidNodeTypeError: { s: 'INVALID_NODE_TYPE_ERR', c: 24, m: 1 },
  DataCloneError: { s: 'DATA_CLONE_ERR', c: 25, m: 1 }
};


/***/ }),

/***/ 8113:
/***/ (function(module) {

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 7392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var userAgent = __webpack_require__(8113);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 748:
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 1060:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ 2109:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var getOwnPropertyDescriptor = (__webpack_require__(1236).f);
var createNonEnumerableProperty = __webpack_require__(8880);
var defineBuiltIn = __webpack_require__(8052);
var defineGlobalProperty = __webpack_require__(3072);
var copyConstructorProperties = __webpack_require__(9920);
var isForced = __webpack_require__(4705);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 7293:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 4374:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 6916:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(4374);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 6530:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var hasOwn = __webpack_require__(2597);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 5668:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var aCallable = __webpack_require__(9662);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 1702:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(4374);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 5005:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var isCallable = __webpack_require__(614);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 8173:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aCallable = __webpack_require__(9662);
var isNullOrUndefined = __webpack_require__(8554);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 7854:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || this || Function('return this')();


/***/ }),

/***/ 2597:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var toObject = __webpack_require__(7908);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 3501:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 4664:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var fails = __webpack_require__(7293);
var createElement = __webpack_require__(317);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 8361:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var fails = __webpack_require__(7293);
var classof = __webpack_require__(4326);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 9587:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var isObject = __webpack_require__(111);
var setPrototypeOf = __webpack_require__(7674);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 2788:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var isCallable = __webpack_require__(614);
var store = __webpack_require__(5465);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 9909:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(4811);
var global = __webpack_require__(7854);
var isObject = __webpack_require__(111);
var createNonEnumerableProperty = __webpack_require__(8880);
var hasOwn = __webpack_require__(2597);
var shared = __webpack_require__(5465);
var sharedKey = __webpack_require__(6200);
var hiddenKeys = __webpack_require__(3501);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 3157:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(4326);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ 614:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $documentAll = __webpack_require__(4154);

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 4705:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);
var isCallable = __webpack_require__(614);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 8554:
/***/ (function(module) {

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 111:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var $documentAll = __webpack_require__(4154);

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 1913:
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 2190:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(5005);
var isCallable = __webpack_require__(614);
var isPrototypeOf = __webpack_require__(7976);
var USE_SYMBOL_AS_UID = __webpack_require__(3307);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6244:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toLength = __webpack_require__(7466);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 6339:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var fails = __webpack_require__(7293);
var isCallable = __webpack_require__(614);
var hasOwn = __webpack_require__(2597);
var DESCRIPTORS = __webpack_require__(9781);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(6530).CONFIGURABLE);
var inspectSource = __webpack_require__(2788);
var InternalStateModule = __webpack_require__(9909);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 4758:
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 6277:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toString = __webpack_require__(1340);

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ 3070:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var IE8_DOM_DEFINE = __webpack_require__(4664);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(3353);
var anObject = __webpack_require__(9670);
var toPropertyKey = __webpack_require__(4948);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 1236:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var call = __webpack_require__(6916);
var propertyIsEnumerableModule = __webpack_require__(5296);
var createPropertyDescriptor = __webpack_require__(9114);
var toIndexedObject = __webpack_require__(5656);
var toPropertyKey = __webpack_require__(4948);
var hasOwn = __webpack_require__(2597);
var IE8_DOM_DEFINE = __webpack_require__(4664);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8006:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(6324);
var enumBugKeys = __webpack_require__(748);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 5181:
/***/ (function(__unused_webpack_module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 7976:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 6324:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var hasOwn = __webpack_require__(2597);
var toIndexedObject = __webpack_require__(5656);
var indexOf = (__webpack_require__(1318).indexOf);
var hiddenKeys = __webpack_require__(3501);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 5296:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 7674:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(5668);
var anObject = __webpack_require__(9670);
var aPossiblePrototype = __webpack_require__(6077);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(6916);
var isCallable = __webpack_require__(614);
var isObject = __webpack_require__(111);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 3887:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(5005);
var uncurryThis = __webpack_require__(1702);
var getOwnPropertyNamesModule = __webpack_require__(8006);
var getOwnPropertySymbolsModule = __webpack_require__(5181);
var anObject = __webpack_require__(9670);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 4488:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isNullOrUndefined = __webpack_require__(8554);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6200:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(2309);
var uid = __webpack_require__(9711);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5465:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var defineGlobalProperty = __webpack_require__(3072);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 2309:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(1913);
var store = __webpack_require__(5465);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.31.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 6293:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(7392);
var fails = __webpack_require__(7293);
var global = __webpack_require__(7854);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 1400:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__(9303);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5656:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(8361);
var requireObjectCoercible = __webpack_require__(4488);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 9303:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trunc = __webpack_require__(4758);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 7466:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__(9303);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 7908:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(4488);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 7593:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(6916);
var isObject = __webpack_require__(111);
var isSymbol = __webpack_require__(2190);
var getMethod = __webpack_require__(8173);
var ordinaryToPrimitive = __webpack_require__(2140);
var wellKnownSymbol = __webpack_require__(5112);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 4948:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPrimitive = __webpack_require__(7593);
var isSymbol = __webpack_require__(2190);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 1694:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 1340:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(648);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6330:
/***/ (function(module) {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 9711:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 3307:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(6293);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 3353:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var fails = __webpack_require__(7293);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 4811:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var isCallable = __webpack_require__(614);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 5112:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var shared = __webpack_require__(2309);
var hasOwn = __webpack_require__(2597);
var uid = __webpack_require__(9711);
var NATIVE_SYMBOL = __webpack_require__(6293);
var USE_SYMBOL_AS_UID = __webpack_require__(3307);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 7658:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(2109);
var toObject = __webpack_require__(7908);
var lengthOfArrayLike = __webpack_require__(6244);
var setArrayLength = __webpack_require__(3658);
var doesNotExceedSafeInteger = __webpack_require__(7207);
var fails = __webpack_require__(7293);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 and Safari <= 15.4, FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 2801:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(2109);
var global = __webpack_require__(7854);
var getBuiltIn = __webpack_require__(5005);
var createPropertyDescriptor = __webpack_require__(9114);
var defineProperty = (__webpack_require__(3070).f);
var hasOwn = __webpack_require__(2597);
var anInstance = __webpack_require__(5787);
var inheritIfRequired = __webpack_require__(9587);
var normalizeStringArgument = __webpack_require__(6277);
var DOMExceptionConstants = __webpack_require__(3678);
var clearErrorStack = __webpack_require__(1060);
var DESCRIPTORS = __webpack_require__(9781);
var IS_PURE = __webpack_require__(1913);

var DOM_EXCEPTION = 'DOMException';
var Error = getBuiltIn('Error');
var NativeDOMException = getBuiltIn(DOM_EXCEPTION);

var $DOMException = function DOMException() {
  anInstance(this, DOMExceptionPrototype);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
  var that = new NativeDOMException(message, name);
  var error = Error(message);
  error.name = DOM_EXCEPTION;
  defineProperty(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
  inheritIfRequired(that, this, $DOMException);
  return that;
};

var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;

var ERROR_HAS_STACK = 'stack' in Error(DOM_EXCEPTION);
var DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(global, DOM_EXCEPTION);

// Bun ~ 0.1.1 DOMException have incorrect descriptor and we can't redefine it
// https://github.com/Jarred-Sumner/bun/issues/399
var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);

var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;

// `DOMException` constructor patch for `.stack` where it's required
// https://webidl.spec.whatwg.org/#es-DOMException-specialness
$({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, { // TODO: fix export logic
  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});

var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;

if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
  if (!IS_PURE) {
    defineProperty(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
  }

  for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
    var constant = DOMExceptionConstants[key];
    var constantName = constant.s;
    if (!hasOwn(PolyfilledDOMException, constantName)) {
      defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
    }
  }
}


/***/ }),

/***/ 4870:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $y: function() { return /* binding */ isReadonly; },
/* harmony export */   B: function() { return /* binding */ effectScope; },
/* harmony export */   BK: function() { return /* binding */ toRefs; },
/* harmony export */   Bj: function() { return /* binding */ EffectScope; },
/* harmony export */   EB: function() { return /* binding */ onScopeDispose; },
/* harmony export */   Fl: function() { return /* binding */ computed; },
/* harmony export */   IU: function() { return /* binding */ toRaw; },
/* harmony export */   Jd: function() { return /* binding */ pauseTracking; },
/* harmony export */   OT: function() { return /* binding */ readonly; },
/* harmony export */   PG: function() { return /* binding */ isReactive; },
/* harmony export */   SU: function() { return /* binding */ unref; },
/* harmony export */   Tn: function() { return /* binding */ toValue; },
/* harmony export */   Um: function() { return /* binding */ shallowReactive; },
/* harmony export */   Vh: function() { return /* binding */ toRef; },
/* harmony export */   WL: function() { return /* binding */ proxyRefs; },
/* harmony export */   X$: function() { return /* binding */ trigger; },
/* harmony export */   X3: function() { return /* binding */ isProxy; },
/* harmony export */   XI: function() { return /* binding */ shallowRef; },
/* harmony export */   Xl: function() { return /* binding */ markRaw; },
/* harmony export */   YS: function() { return /* binding */ shallowReadonly; },
/* harmony export */   ZM: function() { return /* binding */ customRef; },
/* harmony export */   cE: function() { return /* binding */ effect; },
/* harmony export */   dq: function() { return /* binding */ isRef; },
/* harmony export */   iH: function() { return /* binding */ ref; },
/* harmony export */   j: function() { return /* binding */ track; },
/* harmony export */   lk: function() { return /* binding */ resetTracking; },
/* harmony export */   nZ: function() { return /* binding */ getCurrentScope; },
/* harmony export */   oR: function() { return /* binding */ triggerRef; },
/* harmony export */   qj: function() { return /* binding */ reactive; },
/* harmony export */   qq: function() { return /* binding */ ReactiveEffect; },
/* harmony export */   sT: function() { return /* binding */ stop; },
/* harmony export */   yT: function() { return /* binding */ isShallow; }
/* harmony export */ });
/* unused harmony exports ITERATE_KEY, deferredComputed, enableTracking */
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7139);


function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {}
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (false) {}
}
const createDep = effects => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = dep => (dep.w & trackOpBit) > 0;
const newTracked = dep => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({
  deps
}) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = effect => {
  const {
    deps
  } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol( false ? 0 : "");
const MAP_KEY_ITERATE_KEY = Symbol( false ? 0 : "");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const {
    deps
  } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)(_effect, options);
    if (options.scope) recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo =  false ? 0 : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (false) {}
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isIntegerKey */ .S0)(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo =  false ? 0 : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (false) {} else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (false) {} else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2, debuggerEventExtraInfo);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (false) {}
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .makeMap */ .fY)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== "arguments" && key !== "caller").map(key => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .yk));
const get$1 = /* @__PURE__ */createGetter();
const shallowGet = /* @__PURE__ */createGetter(false, true);
const readonlyGet = /* @__PURE__ */createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach(key => {
    instrumentations[key] = function (...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach(key => {
    instrumentations[key] = function (...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target);
    if (!isReadonly2) {
      if (targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .yk)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isIntegerKey */ .S0)(key) ? res : res.value;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */createSetter();
const shallowSet = /* @__PURE__ */createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isIntegerKey */ .S0)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .aU)(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .yk)(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (false) {}
    return true;
  },
  deleteProperty(target, key) {
    if (false) {}
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = value => value;
const getProto = v => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const {
    has: has2
  } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target["__v_raw"];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const {
    has: has2,
    get: get2
  } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {}
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .aU)(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const {
    has: has2,
    get: get2
  } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {}
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget =  false ? 0 : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function (...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const {
          value,
          done
        } = innerIterator.next();
        return done ? {
          value,
          done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function (...args) {
    if (false) {}
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach(method => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */new WeakMap();
const shallowReactiveMap = /* @__PURE__ */new WeakMap();
const readonlyMap = /* @__PURE__ */new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}

function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toRawType */ .W7)(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(target)) {
    if (false) {}
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .def */ .Nj)(value, "__v_skip", true);
  return value;
}
const toReactive = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(value) ? reactive(value) : value;
const toReadonly = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (false) {} else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    if (false) {} else {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .aU)(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2,  false ? 0 : void 0);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const {
      get,
      set
    } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (false) {}
  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(source)) {
    return new GetterRefImpl(source);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly;
  }
  get value() {
    const self = toRaw(this);
    trackRefValue(self);
    if (self._dirty || !self._cacheable) {
      self._dirty = false;
      self._value = self.effect.run();
    }
    return self._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter =  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .dG;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {}
  return cRef;
}
const tick = /* @__PURE__ */(/* unused pure expression or super */ null && (Promise.resolve()));
const queue = (/* unused pure expression or super */ null && ([]));
let queued = false;
const scheduler = fn => {
  queue.push(fn);
  if (!queued) {
    queued = true;
    tick.then(flush);
  }
};
const flush = () => {
  for (let i = 0; i < queue.length; i++) {
    queue[i]();
  }
  queue.length = 0;
  queued = false;
};
class DeferredComputedRefImpl {
  constructor(getter) {
    this.dep = void 0;
    this._dirty = true;
    this.__v_isRef = true;
    this["__v_isReadonly"] = true;
    let compareTarget;
    let hasCompareTarget = false;
    let scheduled = false;
    this.effect = new ReactiveEffect(getter, computedTrigger => {
      if (this.dep) {
        if (computedTrigger) {
          compareTarget = this._value;
          hasCompareTarget = true;
        } else if (!scheduled) {
          const valueToCompare = hasCompareTarget ? compareTarget : this._value;
          scheduled = true;
          hasCompareTarget = false;
          scheduler(() => {
            if (this.effect.active && this._get() !== valueToCompare) {
              triggerRefValue(this);
            }
            scheduled = false;
          });
        }
        for (const e of this.dep) {
          if (e.computed instanceof DeferredComputedRefImpl) {
            e.scheduler(true
            /* computedTrigger */);
          }
        }
      }

      this._dirty = true;
    });
    this.effect.computed = this;
  }
  _get() {
    if (this._dirty) {
      this._dirty = false;
      return this._value = this.effect.run();
    }
    return this._value;
  }
  get value() {
    trackRefValue(this);
    return toRaw(this)._get();
  }
}
function deferredComputed(getter) {
  return new DeferredComputedRefImpl(getter);
}


/***/ }),

/***/ 7139:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C_: function() { return /* binding */ normalizeClass; },
/* harmony export */   DM: function() { return /* binding */ isSet; },
/* harmony export */   E9: function() { return /* binding */ getGlobalThis; },
/* harmony export */   F7: function() { return /* binding */ isOn; },
/* harmony export */   Gg: function() { return /* binding */ isReservedProp; },
/* harmony export */   HD: function() { return /* binding */ isString; },
/* harmony export */   He: function() { return /* binding */ toNumber; },
/* harmony export */   Kj: function() { return /* binding */ isRegExp; },
/* harmony export */   Kn: function() { return /* binding */ isObject; },
/* harmony export */   Kp: function() { return /* binding */ generateCodeFrame; },
/* harmony export */   NO: function() { return /* binding */ NO; },
/* harmony export */   Nj: function() { return /* binding */ def; },
/* harmony export */   Od: function() { return /* binding */ remove; },
/* harmony export */   PO: function() { return /* binding */ isPlainObject; },
/* harmony export */   Pq: function() { return /* binding */ isSpecialBooleanAttr; },
/* harmony export */   RI: function() { return /* binding */ hasOwn; },
/* harmony export */   S0: function() { return /* binding */ isIntegerKey; },
/* harmony export */   W7: function() { return /* binding */ toRawType; },
/* harmony export */   WB: function() { return /* binding */ isVoidTag; },
/* harmony export */   WV: function() { return /* binding */ looseEqual; },
/* harmony export */   Z6: function() { return /* binding */ EMPTY_ARR; },
/* harmony export */   _A: function() { return /* binding */ camelize; },
/* harmony export */   _N: function() { return /* binding */ isMap; },
/* harmony export */   aN: function() { return /* binding */ isSVGTag; },
/* harmony export */   aU: function() { return /* binding */ hasChanged; },
/* harmony export */   dG: function() { return /* binding */ NOOP; },
/* harmony export */   e1: function() { return /* binding */ isGloballyWhitelisted; },
/* harmony export */   eS: function() { return /* binding */ isHTMLTag; },
/* harmony export */   fY: function() { return /* binding */ makeMap; },
/* harmony export */   h5: function() { return /* binding */ looseToNumber; },
/* harmony export */   hR: function() { return /* binding */ toHandlerKey; },
/* harmony export */   hq: function() { return /* binding */ looseIndexOf; },
/* harmony export */   ir: function() { return /* binding */ invokeArrayFns; },
/* harmony export */   j5: function() { return /* binding */ normalizeStyle; },
/* harmony export */   kC: function() { return /* binding */ capitalize; },
/* harmony export */   kJ: function() { return /* binding */ isArray; },
/* harmony export */   kT: function() { return /* binding */ EMPTY_OBJ; },
/* harmony export */   l7: function() { return /* binding */ extend; },
/* harmony export */   m: function() { return /* binding */ PatchFlagNames; },
/* harmony export */   mf: function() { return /* binding */ isFunction; },
/* harmony export */   rs: function() { return /* binding */ hyphenate; },
/* harmony export */   tI: function() { return /* binding */ isPromise; },
/* harmony export */   tR: function() { return /* binding */ isModelListener; },
/* harmony export */   vs: function() { return /* binding */ normalizeProps; },
/* harmony export */   wh: function() { return /* binding */ isBuiltInDirective; },
/* harmony export */   yA: function() { return /* binding */ includeBooleanAttr; },
/* harmony export */   yL: function() { return /* binding */ parseStringStyle; },
/* harmony export */   yk: function() { return /* binding */ isSymbol; },
/* harmony export */   zw: function() { return /* binding */ toDisplayString; }
/* harmony export */ });
/* unused harmony exports escapeHtml, escapeHtmlComment, genPropsAccessExp, isBooleanAttr, isDate, isKnownHtmlAttr, isKnownSvgAttr, isSSRSafeAttrName, objectToString, propsToAttrMap, slotFlagsText, stringifyStyle, toTypeString */
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);

function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}
const EMPTY_OBJ =  false ? 0 : {};
const EMPTY_ARR =  false ? 0 : [];
const NOOP = () => {};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = key => onRE.test(key);
const isModelListener = key => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = val => toTypeString(val) === "[object Map]";
const isSet = val => toTypeString(val) === "[object Set]";
const isDate = val => toTypeString(val) === "[object Date]";
const isRegExp = val => toTypeString(val) === "[object RegExp]";
const isFunction = val => typeof val === "function";
const isString = val => typeof val === "string";
const isSymbol = val => typeof val === "symbol";
const isObject = val => val !== null && typeof val === "object";
const isPromise = val => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = value => objectToString.call(value);
const toRawType = value => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = val => toTypeString(val) === "[object Object]";
const isIntegerKey = key => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */makeMap(
// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = fn => {
  const cache = /* @__PURE__ */Object.create(null);
  return str => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(str => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction(str => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = val => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = val => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyWhitelisted = /* @__PURE__ */makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (isString(value) || typeof value === "number") {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let {
    class: klass,
    style
  } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */(/* unused pure expression or super */ null && (makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`)));
const isKnownSvgAttr = /* @__PURE__ */(/* unused pure expression or super */ null && (makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex(item => looseEqual(item, val));
}
const toDisplayString = val => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};


/***/ }),

/***/ 6139:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AgChartsVue: function() { return /* binding */ AgChartsVue; }
});

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 4 modules
var vue_esm_bundler = __webpack_require__(9003);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(7658);
;// CONCATENATED MODULE: ./node_modules/vue-class-component/dist/vue-class-component.esm-bundler.js

/**
  * vue-class-component v8.0.0-rc.1
  * (c) 2015-present Evan You
  * @license MIT
  */

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function defineGetter(obj, key, getter) {
  Object.defineProperty(obj, key, {
    get: getter,
    enumerable: false,
    configurable: true
  });
}
function defineProxy(proxy, key, target) {
  Object.defineProperty(proxy, key, {
    get: function get() {
      return target[key].value;
    },
    set: function set(value) {
      target[key].value = value;
    },
    enumerable: true,
    configurable: true
  });
}
function getSuper(Ctor) {
  var superProto = Object.getPrototypeOf(Ctor.prototype);
  if (!superProto) {
    return undefined;
  }
  return superProto.constructor;
}
function getOwn(value, key) {
  return value.hasOwnProperty(key) ? value[key] : undefined;
}
var VueImpl = /*#__PURE__*/function () {
  function VueImpl(props, ctx) {
    var _this = this;
    _classCallCheck(this, VueImpl);
    defineGetter(this, '$props', function () {
      return props;
    });
    defineGetter(this, '$attrs', function () {
      return ctx.attrs;
    });
    defineGetter(this, '$slots', function () {
      return ctx.slots;
    });
    defineGetter(this, '$emit', function () {
      return ctx.emit;
    });
    Object.keys(props).forEach(function (key) {
      Object.defineProperty(_this, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: props[key]
      });
    });
  }
  _createClass(VueImpl, null, [{
    key: "registerHooks",
    value: function registerHooks(keys) {
      var _this$__h;
      (_this$__h = this.__h).push.apply(_this$__h, _toConsumableArray(keys));
    }
  }, {
    key: "with",
    value: function _with(Props) {
      var propsMeta = new Props();
      var props = {};
      Object.keys(propsMeta).forEach(function (key) {
        var meta = propsMeta[key];
        props[key] = meta !== null && meta !== void 0 ? meta : null;
      });
      var PropsMixin = /*#__PURE__*/function (_this2) {
        _inherits(PropsMixin, _this2);
        var _super = _createSuper(PropsMixin);
        function PropsMixin() {
          _classCallCheck(this, PropsMixin);
          return _super.apply(this, arguments);
        }
        return PropsMixin;
      }(this);
      PropsMixin.__b = {
        props: props
      };
      return PropsMixin;
    }
  }, {
    key: "__vccOpts",
    get: function get() {
      // Early return if `this` is base class as it does not have any options
      if (this === Vue) {
        return {};
      }
      var Ctor = this;
      var cache = getOwn(Ctor, '__c');
      if (cache) {
        return cache;
      } // If the options are provided via decorator use it as a base

      var options = _objectSpread2({}, getOwn(Ctor, '__o'));
      Ctor.__c = options; // Handle super class options

      var Super = getSuper(Ctor);
      if (Super) {
        options["extends"] = Super.__vccOpts;
      } // Inject base options as a mixin

      var base = getOwn(Ctor, '__b');
      if (base) {
        options.mixins = options.mixins || [];
        options.mixins.unshift(base);
      }
      options.methods = _objectSpread2({}, options.methods);
      options.computed = _objectSpread2({}, options.computed);
      var proto = Ctor.prototype;
      Object.getOwnPropertyNames(proto).forEach(function (key) {
        if (key === 'constructor') {
          return;
        } // hooks

        if (Ctor.__h.indexOf(key) > -1) {
          options[key] = proto[key];
          return;
        }
        var descriptor = Object.getOwnPropertyDescriptor(proto, key); // methods

        if (typeof descriptor.value === 'function') {
          options.methods[key] = descriptor.value;
          return;
        } // computed properties

        if (descriptor.get || descriptor.set) {
          options.computed[key] = {
            get: descriptor.get,
            set: descriptor.set
          };
          return;
        }
      });
      options.setup = function (props, ctx) {
        var _promise;
        var data = new Ctor(props, ctx);
        var dataKeys = Object.keys(data);
        var plainData = {};
        var promise = null; // Initialize reactive data and convert constructor `this` to a proxy

        dataKeys.forEach(function (key) {
          // Skip if the value is undefined not to make it reactive.
          // If the value has `__s`, it's a value from `setup` helper, proceed it later.
          if (data[key] === undefined || data[key] && data[key].__s) {
            return;
          }
          plainData[key] = (0,vue_esm_bundler/* ref */.iH)(data[key]);
          defineProxy(data, key, plainData);
        }); // Invoke composition functions

        dataKeys.forEach(function (key) {
          if (data[key] && data[key].__s) {
            var setupState = data[key].__s();
            if (setupState instanceof Promise) {
              if (!promise) {
                promise = Promise.resolve(plainData);
              }
              promise = promise.then(function () {
                return setupState.then(function (value) {
                  plainData[key] = (0,vue_esm_bundler/* proxyRefs */.WL)(value);
                  return plainData;
                });
              });
            } else {
              plainData[key] = (0,vue_esm_bundler/* proxyRefs */.WL)(setupState);
            }
          }
        });
        return (_promise = promise) !== null && _promise !== void 0 ? _promise : plainData;
      };
      var decorators = getOwn(Ctor, '__d');
      if (decorators) {
        decorators.forEach(function (fn) {
          return fn(options);
        });
      } // from Vue Loader

      var injections = ['render', 'ssrRender', '__file', '__cssModules', '__scopeId', '__hmrId'];
      injections.forEach(function (key) {
        if (Ctor[key]) {
          options[key] = Ctor[key];
        }
      });
      return options;
    }
  }]);
  return VueImpl;
}();
VueImpl.__h = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUnmount', 'unmounted', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch'];
var Vue = VueImpl;
function Options(options) {
  return function (Component) {
    Component.__o = options;
    return Component;
  };
}
function createDecorator(factory) {
  return function (target, key, index) {
    var Ctor = typeof target === 'function' ? target : target.constructor;
    if (!Ctor.__d) {
      Ctor.__d = [];
    }
    if (typeof index !== 'number') {
      index = undefined;
    }
    Ctor.__d.push(function (options) {
      return factory(options, key, index);
    });
  };
}
function mixins() {
  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {
    Ctors[_key] = arguments[_key];
  }
  var _a;
  return _a = /*#__PURE__*/function (_Vue) {
    _inherits(MixedVue, _Vue);
    var _super = _createSuper(MixedVue);
    function MixedVue() {
      var _this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _classCallCheck(this, MixedVue);
      _this = _super.call.apply(_super, [this].concat(args));
      Ctors.forEach(function (Ctor) {
        var data = _construct(Ctor, args);
        Object.keys(data).forEach(function (key) {
          _this[key] = data[key];
        });
      });
      return _this;
    }
    return MixedVue;
  }(Vue), _a.__b = {
    mixins: Ctors.map(function (Ctor) {
      return Ctor.__vccOpts;
    })
  }, _a;
}
function setup(setupFn) {
  // Hack to delay the invocation of setup function.
  // Will be called after dealing with class properties.
  return {
    __s: setupFn
  };
}

// Actual implementation
function prop(options) {
  return options;
}

// EXTERNAL MODULE: ./node_modules/ag-charts-community/dist/esm/es6/main.mjs + 187 modules
var main = __webpack_require__(6385);
// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(4870);
;// CONCATENATED MODULE: ./node_modules/ag-charts-vue3/lib/AgChartsVue.js
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




let AgChartsVue = class AgChartsVue extends Vue {
  constructor() {
    super(...arguments);
    this.isCreated = false;
    this.isDestroyed = false;
  }
  // noinspection JSUnusedGlobalSymbols, JSMethodCanBeStatic
  render() {
    return (0,vue_esm_bundler.h)('div', {
      style: {
        height: '100%'
      },
      ref: 'agChartRef'
    });
  }
  mounted() {
    const options = this.applyContainerIfNotSet(this.options);
    this.chart = main/* AgChart */.hX.create(options);
    this.$watch('options', (newValue, oldValue) => {
      this.processChanges(newValue, oldValue);
    }, {
      deep: true
    });
    this.isCreated = true;
    this.chart.chart.waitForUpdate().then(() => this.$emit('onChartReady', this.chart));
  }
  destroyed() {
    if (this.isCreated) {
      if (this.chart) {
        this.chart.destroy();
      }
      this.isDestroyed = true;
    }
  }
  unmounted() {
    this.destroyed();
  }
  processChanges(currentValue, previousValue) {
    if (this.isCreated && this.chart) {
      main/* AgChart */.hX.update(this.chart, (0,reactivity_esm_bundler/* toRaw */.IU)(this.applyContainerIfNotSet((0,reactivity_esm_bundler/* toRaw */.IU)(this.options))));
    }
  }
  applyContainerIfNotSet(propsOptions) {
    if (propsOptions.container) {
      return propsOptions;
    }
    return Object.assign(Object.assign({}, propsOptions), {
      container: this.$refs.agChartRef
    });
  }
};
AgChartsVue = __decorate([Options({
  props: {
    options: {}
  },
  emits: ['onChartReady']
  // watch: {
  //     options: {
  //         handler(currentValue, previousValue) {
  //             this.processChanges( currentValue, previousValue);
  //         },
  //         deep: true,
  //     },
  // },
})], AgChartsVue);


/***/ }),

/***/ 7534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (let p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
__export(__webpack_require__(6139));

/***/ }),

/***/ 89:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
// runtime helper for setting properties on components
// in a tree-shakable way
exports.Z = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

/***/ }),

/***/ 9003:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  j4: function() { return /* reexport */ createBlock; },
  MW: function() { return /* reexport */ defineCustomElement; },
  h: function() { return /* reexport */ h; },
  wg: function() { return /* reexport */ openBlock; },
  WL: function() { return /* reexport */ reactivity_esm_bundler/* proxyRefs */.WL; },
  iH: function() { return /* reexport */ reactivity_esm_bundler/* ref */.iH; },
  up: function() { return /* reexport */ resolveComponent; }
});

// UNUSED EXPORTS: BaseTransition, BaseTransitionPropsValidators, Comment, EffectScope, Fragment, KeepAlive, ReactiveEffect, Static, Suspense, Teleport, Text, Transition, TransitionGroup, VueElement, assertNumber, callWithAsyncErrorHandling, callWithErrorHandling, camelize, capitalize, cloneVNode, compatUtils, compile, computed, createApp, createCommentVNode, createElementBlock, createElementVNode, createHydrationRenderer, createPropsRestProxy, createRenderer, createSSRApp, createSlots, createStaticVNode, createTextVNode, createVNode, customRef, defineAsyncComponent, defineComponent, defineEmits, defineExpose, defineModel, defineOptions, defineProps, defineSSRCustomElement, defineSlots, devtools, effect, effectScope, getCurrentInstance, getCurrentScope, getTransitionRawChildren, guardReactiveProps, handleError, hasInjectionContext, hydrate, initCustomFormatter, initDirectivesForSSR, inject, isMemoSame, isProxy, isReactive, isReadonly, isRef, isRuntimeOnly, isShallow, isVNode, markRaw, mergeDefaults, mergeModels, mergeProps, nextTick, normalizeClass, normalizeProps, normalizeStyle, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, popScopeId, provide, pushScopeId, queuePostFlushCb, reactive, readonly, registerRuntimeCompiler, render, renderList, renderSlot, resolveDirective, resolveDynamicComponent, resolveFilter, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, shallowReactive, shallowReadonly, shallowRef, ssrContextKey, ssrUtils, stop, toDisplayString, toHandlerKey, toHandlers, toRaw, toRef, toRefs, toValue, transformVNodeArgs, triggerRef, unref, useAttrs, useCssModule, useCssVars, useModel, useSSRContext, useSlots, useTransitionState, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, version, warn, watch, watchEffect, watchPostEffect, watchSyncEffect, withAsyncContext, withCtx, withDefaults, withDirectives, withKeys, withMemo, withModifiers, withScopeId

// NAMESPACE OBJECT: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var runtime_dom_esm_bundler_namespaceObject = {};
__webpack_require__.r(runtime_dom_esm_bundler_namespaceObject);
__webpack_require__.d(runtime_dom_esm_bundler_namespaceObject, {
  BaseTransition: function() { return BaseTransition; },
  BaseTransitionPropsValidators: function() { return BaseTransitionPropsValidators; },
  Comment: function() { return Comment; },
  EffectScope: function() { return reactivity_esm_bundler/* EffectScope */.Bj; },
  Fragment: function() { return Fragment; },
  KeepAlive: function() { return KeepAlive; },
  ReactiveEffect: function() { return reactivity_esm_bundler/* ReactiveEffect */.qq; },
  Static: function() { return Static; },
  Suspense: function() { return Suspense; },
  Teleport: function() { return Teleport; },
  Text: function() { return Text; },
  Transition: function() { return Transition; },
  TransitionGroup: function() { return TransitionGroup; },
  VueElement: function() { return VueElement; },
  assertNumber: function() { return assertNumber; },
  callWithAsyncErrorHandling: function() { return callWithAsyncErrorHandling; },
  callWithErrorHandling: function() { return callWithErrorHandling; },
  camelize: function() { return shared_esm_bundler/* camelize */._A; },
  capitalize: function() { return shared_esm_bundler/* capitalize */.kC; },
  cloneVNode: function() { return cloneVNode; },
  compatUtils: function() { return compatUtils; },
  computed: function() { return computed; },
  createApp: function() { return createApp; },
  createBlock: function() { return createBlock; },
  createCommentVNode: function() { return createCommentVNode; },
  createElementBlock: function() { return createElementBlock; },
  createElementVNode: function() { return createBaseVNode; },
  createHydrationRenderer: function() { return createHydrationRenderer; },
  createPropsRestProxy: function() { return createPropsRestProxy; },
  createRenderer: function() { return createRenderer; },
  createSSRApp: function() { return createSSRApp; },
  createSlots: function() { return createSlots; },
  createStaticVNode: function() { return createStaticVNode; },
  createTextVNode: function() { return createTextVNode; },
  createVNode: function() { return createVNode; },
  customRef: function() { return reactivity_esm_bundler/* customRef */.ZM; },
  defineAsyncComponent: function() { return defineAsyncComponent; },
  defineComponent: function() { return defineComponent; },
  defineCustomElement: function() { return defineCustomElement; },
  defineEmits: function() { return defineEmits; },
  defineExpose: function() { return defineExpose; },
  defineModel: function() { return defineModel; },
  defineOptions: function() { return defineOptions; },
  defineProps: function() { return defineProps; },
  defineSSRCustomElement: function() { return defineSSRCustomElement; },
  defineSlots: function() { return defineSlots; },
  devtools: function() { return devtools; },
  effect: function() { return reactivity_esm_bundler/* effect */.cE; },
  effectScope: function() { return reactivity_esm_bundler/* effectScope */.B; },
  getCurrentInstance: function() { return getCurrentInstance; },
  getCurrentScope: function() { return reactivity_esm_bundler/* getCurrentScope */.nZ; },
  getTransitionRawChildren: function() { return getTransitionRawChildren; },
  guardReactiveProps: function() { return guardReactiveProps; },
  h: function() { return h; },
  handleError: function() { return handleError; },
  hasInjectionContext: function() { return hasInjectionContext; },
  hydrate: function() { return hydrate; },
  initCustomFormatter: function() { return runtime_core_esm_bundler_initCustomFormatter; },
  initDirectivesForSSR: function() { return initDirectivesForSSR; },
  inject: function() { return inject; },
  isMemoSame: function() { return isMemoSame; },
  isProxy: function() { return reactivity_esm_bundler/* isProxy */.X3; },
  isReactive: function() { return reactivity_esm_bundler/* isReactive */.PG; },
  isReadonly: function() { return reactivity_esm_bundler/* isReadonly */.$y; },
  isRef: function() { return reactivity_esm_bundler/* isRef */.dq; },
  isRuntimeOnly: function() { return runtime_core_esm_bundler_isRuntimeOnly; },
  isShallow: function() { return reactivity_esm_bundler/* isShallow */.yT; },
  isVNode: function() { return isVNode; },
  markRaw: function() { return reactivity_esm_bundler/* markRaw */.Xl; },
  mergeDefaults: function() { return mergeDefaults; },
  mergeModels: function() { return mergeModels; },
  mergeProps: function() { return mergeProps; },
  nextTick: function() { return nextTick; },
  normalizeClass: function() { return shared_esm_bundler/* normalizeClass */.C_; },
  normalizeProps: function() { return shared_esm_bundler/* normalizeProps */.vs; },
  normalizeStyle: function() { return shared_esm_bundler/* normalizeStyle */.j5; },
  onActivated: function() { return onActivated; },
  onBeforeMount: function() { return onBeforeMount; },
  onBeforeUnmount: function() { return onBeforeUnmount; },
  onBeforeUpdate: function() { return onBeforeUpdate; },
  onDeactivated: function() { return onDeactivated; },
  onErrorCaptured: function() { return onErrorCaptured; },
  onMounted: function() { return onMounted; },
  onRenderTracked: function() { return onRenderTracked; },
  onRenderTriggered: function() { return onRenderTriggered; },
  onScopeDispose: function() { return reactivity_esm_bundler/* onScopeDispose */.EB; },
  onServerPrefetch: function() { return onServerPrefetch; },
  onUnmounted: function() { return onUnmounted; },
  onUpdated: function() { return onUpdated; },
  openBlock: function() { return openBlock; },
  popScopeId: function() { return popScopeId; },
  provide: function() { return provide; },
  proxyRefs: function() { return reactivity_esm_bundler/* proxyRefs */.WL; },
  pushScopeId: function() { return pushScopeId; },
  queuePostFlushCb: function() { return queuePostFlushCb; },
  reactive: function() { return reactivity_esm_bundler/* reactive */.qj; },
  readonly: function() { return reactivity_esm_bundler/* readonly */.OT; },
  ref: function() { return reactivity_esm_bundler/* ref */.iH; },
  registerRuntimeCompiler: function() { return registerRuntimeCompiler; },
  render: function() { return render; },
  renderList: function() { return renderList; },
  renderSlot: function() { return renderSlot; },
  resolveComponent: function() { return resolveComponent; },
  resolveDirective: function() { return resolveDirective; },
  resolveDynamicComponent: function() { return resolveDynamicComponent; },
  resolveFilter: function() { return resolveFilter; },
  resolveTransitionHooks: function() { return resolveTransitionHooks; },
  setBlockTracking: function() { return setBlockTracking; },
  setDevtoolsHook: function() { return setDevtoolsHook; },
  setTransitionHooks: function() { return setTransitionHooks; },
  shallowReactive: function() { return reactivity_esm_bundler/* shallowReactive */.Um; },
  shallowReadonly: function() { return reactivity_esm_bundler/* shallowReadonly */.YS; },
  shallowRef: function() { return reactivity_esm_bundler/* shallowRef */.XI; },
  ssrContextKey: function() { return ssrContextKey; },
  ssrUtils: function() { return ssrUtils; },
  stop: function() { return reactivity_esm_bundler/* stop */.sT; },
  toDisplayString: function() { return shared_esm_bundler/* toDisplayString */.zw; },
  toHandlerKey: function() { return shared_esm_bundler/* toHandlerKey */.hR; },
  toHandlers: function() { return toHandlers; },
  toRaw: function() { return reactivity_esm_bundler/* toRaw */.IU; },
  toRef: function() { return reactivity_esm_bundler/* toRef */.Vh; },
  toRefs: function() { return reactivity_esm_bundler/* toRefs */.BK; },
  toValue: function() { return reactivity_esm_bundler/* toValue */.Tn; },
  transformVNodeArgs: function() { return transformVNodeArgs; },
  triggerRef: function() { return reactivity_esm_bundler/* triggerRef */.oR; },
  unref: function() { return reactivity_esm_bundler/* unref */.SU; },
  useAttrs: function() { return useAttrs; },
  useCssModule: function() { return useCssModule; },
  useCssVars: function() { return useCssVars; },
  useModel: function() { return useModel; },
  useSSRContext: function() { return useSSRContext; },
  useSlots: function() { return useSlots; },
  useTransitionState: function() { return useTransitionState; },
  vModelCheckbox: function() { return vModelCheckbox; },
  vModelDynamic: function() { return vModelDynamic; },
  vModelRadio: function() { return vModelRadio; },
  vModelSelect: function() { return vModelSelect; },
  vModelText: function() { return vModelText; },
  vShow: function() { return vShow; },
  version: function() { return version; },
  warn: function() { return runtime_core_esm_bundler_warn; },
  watch: function() { return watch; },
  watchEffect: function() { return watchEffect; },
  watchPostEffect: function() { return watchPostEffect; },
  watchSyncEffect: function() { return watchSyncEffect; },
  withAsyncContext: function() { return withAsyncContext; },
  withCtx: function() { return withCtx; },
  withDefaults: function() { return withDefaults; },
  withDirectives: function() { return withDirectives; },
  withKeys: function() { return withKeys; },
  withMemo: function() { return withMemo; },
  withModifiers: function() { return withModifiers; },
  withScopeId: function() { return withScopeId; }
});

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(7658);
// EXTERNAL MODULE: ./node_modules/@vue/shared/dist/shared.esm-bundler.js
var shared_esm_bundler = __webpack_require__(7139);
// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(4870);
;// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js





const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function runtime_core_esm_bundler_warn(msg, ...args) {
  if (true) return;
  (0,reactivity_esm_bundler/* pauseTracking */.Jd)();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [msg + args.join(""), instance && instance.proxy, trace.map(({
      vnode
    }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"), trace]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length &&
    // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  (0,reactivity_esm_bundler/* resetTracking */.lk)();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...(i === 0 ? [] : [`
`]), ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({
  vnode,
  recurseCount
}) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach(key => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if ((0,shared_esm_bundler/* isString */.HD)(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if ((0,reactivity_esm_bundler/* isRef */.dq)(value)) {
    value = formatProp(key, (0,reactivity_esm_bundler/* toRaw */.IU)(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if ((0,shared_esm_bundler/* isFunction */.mf)(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = (0,reactivity_esm_bundler/* toRaw */.IU)(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (true) return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    runtime_core_esm_bundler_warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    runtime_core_esm_bundler_warn(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,shared_esm_bundler/* isFunction */.mf)(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && (0,shared_esm_bundler/* isPromise */.tI)(res)) {
      res.catch(err => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo =  false ? 0 : type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {} else {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!(0,shared_esm_bundler/* isArray */.kJ)(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (false) {}
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (false) {}
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {}
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (false) {}
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = job => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre) return -1;
    if (b.pre && !a.pre) return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {}
  queue.sort(comparator);
  const check =  false ? 0 : shared_esm_bundler/* NOOP */.dG;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {}
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      runtime_core_esm_bundler_warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */new Set();
if (false) {}
const map = /* @__PURE__ */new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach(instance => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({
      event,
      args
    });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({
      event,
      args
    }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
  // handle late devtools injection - only do this if we are in an actual
  // browser environment to avoid the timer handle stalling test runner exit
  // (#4815)
  typeof window !== "undefined" &&
  // some envs mock window but not fully
  window.HTMLElement &&
  // also exclude jsdom
  !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push(newHook => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$1("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */)));

const devtoolsComponentUpdated = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */)));
const _devtoolsComponentRemoved = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */)));

const devtoolsComponentRemoved = component => {
  if (devtools && typeof devtools.cleanupBuffer === "function" &&
  // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return component => {
    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */)));

const devtoolsPerfEnd = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */)));

function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || shared_esm_bundler/* EMPTY_OBJ */.kT;
  if (false) {}
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modelArg = isModelListener && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const {
      number,
      trim
    } = props[modifiersKey] || shared_esm_bundler/* EMPTY_OBJ */.kT;
    if (trim) {
      args = rawArgs.map(a => (0,shared_esm_bundler/* isString */.HD)(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(shared_esm_bundler/* looseToNumber */.h5);
    }
  }
  if (false) {}
  if (false) {}
  let handlerName;
  let handler = props[handlerName = (0,shared_esm_bundler/* toHandlerKey */.hR)(event)] ||
  // also try camelCase event handler (#2249)
  props[handlerName = (0,shared_esm_bundler/* toHandlerKey */.hR)((0,shared_esm_bundler/* camelize */._A)(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = (0,shared_esm_bundler/* toHandlerKey */.hR)((0,shared_esm_bundler/* hyphenate */.rs)(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if ( true && !(0,shared_esm_bundler/* isFunction */.mf)(comp)) {
    const extendEmits = raw2 => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        (0,shared_esm_bundler/* extend */.l7)(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,shared_esm_bundler/* isObject */.Kn)(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if ((0,shared_esm_bundler/* isArray */.kJ)(raw)) {
    raw.forEach(key => normalized[key] = null);
  } else {
    (0,shared_esm_bundler/* extend */.l7)(normalized, raw);
  }
  if ((0,shared_esm_bundler/* isObject */.Kn)(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !(0,shared_esm_bundler/* isOn */.F7)(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return (0,shared_esm_bundler/* hasOwn */.RI)(options, key[0].toLowerCase() + key.slice(1)) || (0,shared_esm_bundler/* hasOwn */.RI)(options, (0,shared_esm_bundler/* hyphenate */.rs)(key)) || (0,shared_esm_bundler/* hasOwn */.RI)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = _id => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) {}
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  if (false) {}
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) {}
      result = normalizeVNode(render2.length > 1 ? render2(props,  false ? 0 : {
        attrs,
        slots,
        emit
      }) : render2(props, null
      /* we know it doesn't need it */));

      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (false) {}
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const {
      shapeFlag
    } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(shared_esm_bundler/* isModelListener */.tR)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (false) {}
    }
  }
  if (vnode.dirs) {
    if (false) {}
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {}
    root.transition = vnode.transition;
  }
  if (false) {} else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = vnode => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = updatedRoot => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = attrs => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || (0,shared_esm_bundler/* isOn */.F7)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!(0,shared_esm_bundler/* isModelListener */.tR)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = vnode => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const {
    props: prevProps,
    children: prevChildren,
    component
  } = prevVNode;
  const {
    props: nextProps,
    children: nextChildren,
    patchFlag
  } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {}
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({
  vnode,
  parent
}, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = type => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if ((0,shared_esm_bundler/* isFunction */.mf)(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: {
      createElement
    }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null,
    // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, {
  p: patch,
  um: unmount,
  o: {
    createElement
  }
}) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const {
    activeBranch,
    pendingBranch,
    isInFallback,
    isHydrating
  } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null,
        // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null,
          // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const {
          timeout,
          pendingId
        } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (false) {}
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: {
      parentNode,
      remove
    }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? (0,shared_esm_bundler/* toNumber */.He)(vnode.props.timeout) : void 0;
  if (false) {}
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (false) {}
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let {
          anchor: anchor2
        } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const {
        vnode: vnode2,
        activeBranch,
        parentComponent: parentComponent2,
        container: container2,
        isSVG: isSVG2
      } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null,
        // fallback tree will not have suspense context
        isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null,
      // no suspense so unmount hooks fire now
      true
      // shouldRemove
      );

      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch(err => {
        handleError(err, instance, 0);
      }).then(asyncSetupResult => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const {
          vnode: vnode2
        } = instance;
        if (false) {}
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode2,
        // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el),
        // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (false) {}
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */);

  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const {
    shapeFlag,
    children
  } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if ((0,shared_esm_bundler/* isFunction */.mf)(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if ((0,shared_esm_bundler/* isArray */.kJ)(s)) {
    const singleChild = filterSingleRoot(s);
    if (false) {}
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter(c => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,shared_esm_bundler/* isArray */.kJ)(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const {
    vnode,
    parentComponent
  } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  var _a;
  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(effect, null,  false ? 0 : {
    flush: "post"
  });
}
function watchSyncEffect(effect, options) {
  return doWatch(effect, null,  false ? 0 : {
    flush: "sync"
  });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (false) {}
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  onTrack,
  onTrigger
} = shared_esm_bundler/* EMPTY_OBJ */.kT) {
  var _a;
  if (false) {}
  const warnInvalidSource = s => {
    runtime_core_esm_bundler_warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = (0,reactivity_esm_bundler/* getCurrentScope */.nZ)() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if ((0,reactivity_esm_bundler/* isRef */.dq)(source)) {
    getter = () => source.value;
    forceTrigger = (0,reactivity_esm_bundler/* isShallow */.yT)(source);
  } else if ((0,reactivity_esm_bundler/* isReactive */.PG)(source)) {
    getter = () => source;
    deep = true;
  } else if ((0,shared_esm_bundler/* isArray */.kJ)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(s => (0,reactivity_esm_bundler/* isReactive */.PG)(s) || (0,reactivity_esm_bundler/* isShallow */.yT)(s));
    getter = () => source.map(s => {
      if ((0,reactivity_esm_bundler/* isRef */.dq)(s)) {
        return s.value;
      } else if ((0,reactivity_esm_bundler/* isReactive */.PG)(s)) {
        return traverse(s);
      } else if ((0,shared_esm_bundler/* isFunction */.mf)(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
         false && 0;
      }
    });
  } else if ((0,shared_esm_bundler/* isFunction */.mf)(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = shared_esm_bundler/* NOOP */.dG;
     false && 0;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = fn => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = shared_esm_bundler/* NOOP */.dG;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [getter(), isMultiSource ? [] : void 0, onCleanup]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return shared_esm_bundler/* NOOP */.dG;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,shared_esm_bundler/* hasChanged */.aU)(v, oldValue[i])) : (0,shared_esm_bundler/* hasChanged */.aU)(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [newValue,
        // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance) job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new reactivity_esm_bundler/* ReactiveEffect */.qq(getter, scheduler);
  if (false) {}
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      (0,shared_esm_bundler/* remove */.Od)(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup) ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = (0,shared_esm_bundler/* isString */.HD)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if ((0,shared_esm_bundler/* isFunction */.mf)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!(0,shared_esm_bundler/* isObject */.Kn)(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if ((0,reactivity_esm_bundler/* isRef */.dq)(value)) {
    traverse(value.value, seen);
  } else if ((0,shared_esm_bundler/* isArray */.kJ)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if ((0,shared_esm_bundler/* isSet */.DM)(value) || (0,shared_esm_bundler/* isMap */._N)(value)) {
    value.forEach(v => {
      traverse(v, seen);
    });
  } else if ((0,shared_esm_bundler/* isPlainObject */.PO)(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    runtime_core_esm_bundler_warn("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
     false && 0;
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = shared_esm_bundler/* EMPTY_OBJ */.kT] = directives[i];
    if (dir) {
      if ((0,shared_esm_bundler/* isFunction */.mf)(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      (0,reactivity_esm_bundler/* pauseTracking */.Jd)();
      callWithAsyncErrorHandling(hook, instance, 8, [vnode.el, binding, vnode, prevVNode]);
      (0,reactivity_esm_bundler/* resetTracking */.lk)();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (false) {}
            child = c;
            hasFound = true;
            if (true) break;
          }
        }
      }
      const rawProps = (0,reactivity_esm_bundler/* toRaw */.IU)(props);
      const {
        mode
      } = rawProps;
      if (false) {}
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const {
        getTransitionKey
      } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const {
    leavingVNodes
  } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if ((0,shared_esm_bundler/* isArray */.kJ)(hook)) {
      if (hook.every(hook2 => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true
        /* cancelled */);
      }

      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = cancelled => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true
        /* cancelled */);
      }

      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = cancelled => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, {
        key
      }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options, extraOptions) {
  return (0,shared_esm_bundler/* isFunction */.mf)(options) ?
  // #8326: extend call and options.name access are considered side-effects
  // by Rollup, so we have to wrap it in a pure-annotated IIFE.
  /* @__PURE__ */
  (() => (0,shared_esm_bundler/* extend */.l7)({
    name: options.name
  }, extraOptions, {
    setup: options
  }))() : options;
}
const isAsyncWrapper = i => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
  if ((0,shared_esm_bundler/* isFunction */.mf)(source)) {
    source = {
      loader: source
    };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(comp => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (false) {}
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (false) {}
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = err => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent
        /* do not throw in dev if user provided error component */);
      };

      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then(comp => {
          return () => createInnerComp(comp, instance);
        }).catch(err => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = (0,reactivity_esm_bundler/* ref */.iH)(false);
      const error = (0,reactivity_esm_bundler/* ref */.iH)();
      const delayed = (0,reactivity_esm_bundler/* ref */.iH)(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch(err => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const {
    ref: ref2,
    props,
    children,
    ce
  } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = vnode => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */new Map();
    const keys = /* @__PURE__ */new Set();
    let current = null;
    if (false) {}
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: {
          createElement
        }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          (0,shared_esm_bundler/* invokeArrayFns */.ir)(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (false) {}
    };
    sharedContext.deactivate = vnode => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          (0,shared_esm_bundler/* invokeArrayFns */.ir)(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (false) {}
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(() => [props.include, props.exclude], ([include, exclude]) => {
      include && pruneCache(name => matches(include, name));
      exclude && pruneCache(name => !matches(exclude, name));
    },
    // prune post-render after `current` has been updated
    {
      flush: "post",
      deep: true
    });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach(cached => {
        const {
          subTree,
          suspense
        } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (false) {}
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const {
        include,
        exclude,
        max
      } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(pattern)) {
    return pattern.some(p => matches(p, name));
  } else if ((0,shared_esm_bundler/* isString */.HD)(pattern)) {
    return pattern.split(",").includes(name);
  } else if ((0,shared_esm_bundler/* isRegExp */.Kj)(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */);

  onUnmounted(() => {
    (0,shared_esm_bundler/* remove */.Od)(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      (0,reactivity_esm_bundler/* pauseTracking */.Jd)();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      (0,reactivity_esm_bundler/* resetTracking */.lk)();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {}
}
const createHook = lifecycle => (hook, target = currentInstance) =>
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if ((0,shared_esm_bundler/* isString */.HD)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false
      /* do not include inferred name to avoid breaking existing code */);

      if (selfName && (selfName === name || selfName === (0,shared_esm_bundler/* camelize */._A)(name) || selfName === (0,shared_esm_bundler/* capitalize */.kC)((0,shared_esm_bundler/* camelize */._A)(name)))) {
        return Component;
      }
    }
    const res =
    // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) ||
    // global registration
    resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (false) {}
    return res;
  } else if (false) {}
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,shared_esm_bundler/* camelize */._A)(name)] || registry[(0,shared_esm_bundler/* capitalize */.kC)((0,shared_esm_bundler/* camelize */._A)(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if ((0,shared_esm_bundler/* isArray */.kJ)(source) || (0,shared_esm_bundler/* isString */.HD)(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    if (false) {}
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if ((0,shared_esm_bundler/* isObject */.Kn)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if ((0,shared_esm_bundler/* isArray */.kJ)(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default") props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (false) {}
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key ||
    // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    validSlotContent && validSlotContent.key || `_${name}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some(child => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if (false) {}
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,shared_esm_bundler/* toHandlerKey */.hR)(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = i => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap =
// Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */
(0,shared_esm_bundler/* extend */.l7)( /* @__PURE__ */Object.create(null), {
  $: i => i,
  $el: i => i.vnode.el,
  $data: i => i.data,
  $props: i =>  false ? 0 : i.props,
  $attrs: i =>  false ? 0 : i.attrs,
  $slots: i =>  false ? 0 : i.slots,
  $refs: i =>  false ? 0 : i.refs,
  $parent: i => getPublicInstance(i.parent),
  $root: i => getPublicInstance(i.root),
  $emit: i => i.emit,
  $options: i =>  true ? resolveMergedOptions(i) : 0,
  $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: i =>  true ? instanceWatch.bind(i) : 0
});
const isReservedPrefix = key => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== shared_esm_bundler/* EMPTY_OBJ */.kT && !state.__isScriptSetup && (0,shared_esm_bundler/* hasOwn */.RI)(state, key);
const PublicInstanceProxyHandlers = {
  get({
    _: instance
  }, key) {
    const {
      ctx,
      setupState,
      data,
      props,
      accessCache,
      type,
      appContext
    } = instance;
    if (false) {}
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== shared_esm_bundler/* EMPTY_OBJ */.kT && (0,shared_esm_bundler/* hasOwn */.RI)(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (
      // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && (0,shared_esm_bundler/* hasOwn */.RI)(normalizedProps, key)) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== shared_esm_bundler/* EMPTY_OBJ */.kT && (0,shared_esm_bundler/* hasOwn */.RI)(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if ( false || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }

    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        (0,reactivity_esm_bundler/* track */.j)(instance, "get", key);
         false && 0;
      } else if (false) {}
      return publicGetter(instance);
    } else if (
    // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== shared_esm_bundler/* EMPTY_OBJ */.kT && (0,shared_esm_bundler/* hasOwn */.RI)(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
    // global properties
    globalProperties = appContext.config.globalProperties, (0,shared_esm_bundler/* hasOwn */.RI)(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (false) {}
  },
  set({
    _: instance
  }, key, value) {
    const {
      data,
      setupState,
      ctx
    } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (false) {} else if (data !== shared_esm_bundler/* EMPTY_OBJ */.kT && (0,shared_esm_bundler/* hasOwn */.RI)(data, key)) {
      data[key] = value;
      return true;
    } else if ((0,shared_esm_bundler/* hasOwn */.RI)(instance.props, key)) {
       false && 0;
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
       false && 0;
      return false;
    } else {
      if (false) {} else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: {
      data,
      setupState,
      accessCache,
      ctx,
      appContext,
      propsOptions
    }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== shared_esm_bundler/* EMPTY_OBJ */.kT && (0,shared_esm_bundler/* hasOwn */.RI)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,shared_esm_bundler/* hasOwn */.RI)(normalizedProps, key) || (0,shared_esm_bundler/* hasOwn */.RI)(ctx, key) || (0,shared_esm_bundler/* hasOwn */.RI)(publicPropertiesMap, key) || (0,shared_esm_bundler/* hasOwn */.RI)(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if ((0,shared_esm_bundler/* hasOwn */.RI)(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */(0,shared_esm_bundler/* extend */.l7)({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !(0,shared_esm_bundler/* isGloballyWhitelisted */.e1)(key);
    if (false) {}
    return has;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach(key => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach(key => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const {
    ctx,
    setupState
  } = instance;
  Object.keys(toRaw(setupState)).forEach(key => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        runtime_core_esm_bundler_warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
const warnRuntimeUsage = method => runtime_core_esm_bundler_warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
  if (false) {}
  return null;
}
function defineEmits() {
  if (false) {}
  return null;
}
function defineExpose(exposed) {
  if (false) {}
}
function defineOptions(options) {
  if (false) {}
}
function defineSlots() {
  if (false) {}
  return null;
}
function defineModel() {
  if (false) {}
}
function withDefaults(props, defaults) {
  if (false) {}
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function useModel(props, name, options) {
  const i = getCurrentInstance();
  if (false) {}
  if (false) {}
  if (options && options.local) {
    const proxy = (0,reactivity_esm_bundler/* ref */.iH)(props[name]);
    watch(() => props[name], v => proxy.value = v);
    watch(proxy, value => {
      if (value !== props[name]) {
        i.emit(`update:${name}`, value);
      }
    });
    return proxy;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return props[name];
      },
      set value(value) {
        i.emit(`update:${name}`, value);
      }
    };
  }
}
function getContext() {
  const i = getCurrentInstance();
  if (false) {}
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return (0,shared_esm_bundler/* isArray */.kJ)(props) ? props.reduce((normalized, p) => (normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if ((0,shared_esm_bundler/* isArray */.kJ)(opt) || (0,shared_esm_bundler/* isFunction */.mf)(opt)) {
        opt = props[key] = {
          type: opt,
          default: defaults[key]
        };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = {
        default: defaults[key]
      };
    } else if (false) {}
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if ((0,shared_esm_bundler/* isArray */.kJ)(a) && (0,shared_esm_bundler/* isArray */.kJ)(b)) return a.concat(b);
  return (0,shared_esm_bundler/* extend */.l7)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (false) {}
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if ((0,shared_esm_bundler/* isPromise */.tI)(awaitable)) {
    awaitable = awaitable.catch(e => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      runtime_core_esm_bundler_warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  false ? 0 : null;
  if (false) {}
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if ((0,shared_esm_bundler/* isFunction */.mf)(methodHandler)) {
        if (false) {} else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) {}
      } else if (false) {}
    }
  }
  if (dataOptions) {
    if (false) {}
    const data = dataOptions.call(publicThis, publicThis);
    if (false) {}
    if (!(0,shared_esm_bundler/* isObject */.Kn)(data)) {
       false && 0;
    } else {
      instance.data = (0,reactivity_esm_bundler/* reactive */.qj)(data);
      if (false) {}
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = (0,shared_esm_bundler/* isFunction */.mf)(opt) ? opt.bind(publicThis, publicThis) : (0,shared_esm_bundler/* isFunction */.mf)(opt.get) ? opt.get.bind(publicThis, publicThis) : shared_esm_bundler/* NOOP */.dG;
      if (false) {}
      const set = !(0,shared_esm_bundler/* isFunction */.mf)(opt) && (0,shared_esm_bundler/* isFunction */.mf)(opt.set) ? opt.set.bind(publicThis) :  false ? 0 : shared_esm_bundler/* NOOP */.dG;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: v => c.value = v
      });
      if (false) {}
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = (0,shared_esm_bundler/* isFunction */.mf)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(key => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if ((0,shared_esm_bundler/* isArray */.kJ)(hook)) {
      hook.forEach(_hook => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if ((0,shared_esm_bundler/* isArray */.kJ)(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach(key => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: val => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === shared_esm_bundler/* NOOP */.dG) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared_esm_bundler/* NOOP */.dG) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if ((0,shared_esm_bundler/* isObject */.Kn)(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true
        /* treat default function as factory */);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if ((0,reactivity_esm_bundler/* isRef */.dq)(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: v => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (false) {}
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling((0,shared_esm_bundler/* isArray */.kJ)(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if ((0,shared_esm_bundler/* isString */.HD)(raw)) {
    const handler = ctx[raw];
    if ((0,shared_esm_bundler/* isFunction */.mf)(handler)) {
      watch(getter, handler);
    } else if (false) {}
  } else if ((0,shared_esm_bundler/* isFunction */.mf)(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if ((0,shared_esm_bundler/* isObject */.Kn)(raw)) {
    if ((0,shared_esm_bundler/* isArray */.kJ)(raw)) {
      raw.forEach(r => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = (0,shared_esm_bundler/* isFunction */.mf)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if ((0,shared_esm_bundler/* isFunction */.mf)(handler)) {
        watch(getter, handler, raw);
      } else if (false) {}
    }
  } else if (false) {}
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const {
    mixins,
    extends: extendsOptions
  } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: {
      optionMergeStrategies
    }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if ((0,shared_esm_bundler/* isObject */.Kn)(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const {
    mixins,
    extends: extendsOptions
  } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(m => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
       false && 0;
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return (0,shared_esm_bundler/* extend */.l7)((0,shared_esm_bundler/* isFunction */.mf)(to) ? to.call(this, this) : to, (0,shared_esm_bundler/* isFunction */.mf)(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? (0,shared_esm_bundler/* extend */.l7)( /* @__PURE__ */Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if ((0,shared_esm_bundler/* isArray */.kJ)(to) && (0,shared_esm_bundler/* isArray */.kJ)(from)) {
      return [... /* @__PURE__ */new Set([...to, ...from])];
    }
    return (0,shared_esm_bundler/* extend */.l7)( /* @__PURE__ */Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = (0,shared_esm_bundler/* extend */.l7)( /* @__PURE__ */Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: shared_esm_bundler.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */Object.create(null),
    optionsCache: /* @__PURE__ */new WeakMap(),
    propsCache: /* @__PURE__ */new WeakMap(),
    emitsCache: /* @__PURE__ */new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!(0,shared_esm_bundler/* isFunction */.mf)(rootComponent)) {
      rootComponent = (0,shared_esm_bundler/* extend */.l7)({}, rootComponent);
    }
    if (rootProps != null && !(0,shared_esm_bundler/* isObject */.Kn)(rootProps)) {
       false && 0;
      rootProps = null;
    }
    const context = createAppContext();
    if (false) {}
    const installedPlugins = /* @__PURE__ */new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (false) {}
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           false && 0;
        } else if (plugin && (0,shared_esm_bundler/* isFunction */.mf)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if ((0,shared_esm_bundler/* isFunction */.mf)(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (false) {}
        return app;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {}
        } else {}
        return app;
      },
      component(name, component) {
        if (false) {}
        if (!component) {
          return context.components[name];
        }
        if (false) {}
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (false) {}
        if (!directive) {
          return context.directives[name];
        }
        if (false) {}
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (false) {}
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (false) {}
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (false) {}
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (false) {}
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          if (false) {}
          delete app._container.__vue_app__;
        } else if (false) {}
      },
      provide(key, value) {
        if (false) {}
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) {
    if (false) {}
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,shared_esm_bundler/* isFunction */.mf)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) {}
  } else if (false) {}
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  (0,shared_esm_bundler/* def */.Nj)(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {}
  if (isStateful) {
    instance.props = isSSR ? props : (0,reactivity_esm_bundler/* shallowReactive */.Um)(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: {
      patchFlag
    }
  } = instance;
  const rawCurrentProps = (0,reactivity_esm_bundler/* toRaw */.IU)(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
  // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
   true && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if ((0,shared_esm_bundler/* hasOwn */.RI)(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = (0,shared_esm_bundler/* camelize */._A)(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
            /* isAbsent */);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps ||
      // for camelCase
      !(0,shared_esm_bundler/* hasOwn */.RI)(rawProps, key) && (
      // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = (0,shared_esm_bundler/* hyphenate */.rs)(key)) === key || !(0,shared_esm_bundler/* hasOwn */.RI)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (
          // for camelCase
          rawPrevProps[key] !== void 0 ||
          // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true
            /* isAbsent */);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !(0,shared_esm_bundler/* hasOwn */.RI)(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    (0,reactivity_esm_bundler/* trigger */.X$)(instance, "set", "$attrs");
  }
  if (false) {}
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if ((0,shared_esm_bundler/* isReservedProp */.Gg)(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && (0,shared_esm_bundler/* hasOwn */.RI)(options, camelKey = (0,shared_esm_bundler/* camelize */._A)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = (0,reactivity_esm_bundler/* toRaw */.IU)(props);
    const castValues = rawCastValues || shared_esm_bundler/* EMPTY_OBJ */.kT;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,shared_esm_bundler/* hasOwn */.RI)(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = (0,shared_esm_bundler/* hasOwn */.RI)(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && (0,shared_esm_bundler/* isFunction */.mf)(defaultValue)) {
        const {
          propsDefaults
        } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === (0,shared_esm_bundler/* hyphenate */.rs)(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if ( true && !(0,shared_esm_bundler/* isFunction */.mf)(comp)) {
    const extendProps = raw2 => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      (0,shared_esm_bundler/* extend */.l7)(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,shared_esm_bundler/* isObject */.Kn)(comp)) {
      cache.set(comp, shared_esm_bundler/* EMPTY_ARR */.Z6);
    }
    return shared_esm_bundler/* EMPTY_ARR */.Z6;
  }
  if ((0,shared_esm_bundler/* isArray */.kJ)(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (false) {}
      const normalizedKey = (0,shared_esm_bundler/* camelize */._A)(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = shared_esm_bundler/* EMPTY_OBJ */.kT;
      }
    }
  } else if (raw) {
    if (false) {}
    for (const key in raw) {
      const normalizedKey = (0,shared_esm_bundler/* camelize */._A)(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = (0,shared_esm_bundler/* isArray */.kJ)(opt) || (0,shared_esm_bundler/* isFunction */.mf)(opt) ? {
          type: opt
        } : (0,shared_esm_bundler/* extend */.l7)({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0 /* shouldCast */] = booleanIndex > -1;
          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || (0,shared_esm_bundler/* hasOwn */.RI)(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if ((0,shared_esm_bundler/* isObject */.Kn)(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (false) {}
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(expectedTypes)) {
    return expectedTypes.findIndex(t => isSameType(t, type));
  } else if ((0,shared_esm_bundler/* isFunction */.mf)(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null) continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const {
    type,
    required,
    validator,
    skipCheck
  } = prop;
  if (required && isAbsent) {
    runtime_core_esm_bundler_warn('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const {
        valid,
        expectedType
      } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      runtime_core_esm_bundler_warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    runtime_core_esm_bundler_warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */(/* unused pure expression or super */ null && (makeMap("String,Number,Boolean,Function,Symbol,BigInt")));
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some(elem => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some(elem => elem.toLowerCase() === "boolean");
}
const isInternalKey = key => key[0] === "_" || key === "$stable";
const normalizeSlotValue = value => (0,shared_esm_bundler/* isArray */.kJ)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {}
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if ((0,shared_esm_bundler/* isFunction */.mf)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (false) {}
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (false) {}
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = (0,reactivity_esm_bundler/* toRaw */.IU)(children);
      (0,shared_esm_bundler/* def */.Nj)(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  (0,shared_esm_bundler/* def */.Nj)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const {
    vnode,
    slots
  } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = shared_esm_bundler/* EMPTY_OBJ */.kT;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) {} else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        (0,shared_esm_bundler/* extend */.l7)(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,shared_esm_bundler/* isArray */.kJ)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const {
    i: owner,
    r: ref
  } = rawRef;
  if (false) {}
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === shared_esm_bundler/* EMPTY_OBJ */.kT ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if ((0,shared_esm_bundler/* isString */.HD)(oldRef)) {
      refs[oldRef] = null;
      if ((0,shared_esm_bundler/* hasOwn */.RI)(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,reactivity_esm_bundler/* isRef */.dq)(oldRef)) {
      oldRef.value = null;
    }
  }
  if ((0,shared_esm_bundler/* isFunction */.mf)(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = (0,shared_esm_bundler/* isString */.HD)(ref);
    const _isRef = (0,reactivity_esm_bundler/* isRef */.dq)(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? (0,shared_esm_bundler/* hasOwn */.RI)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            (0,shared_esm_bundler/* isArray */.kJ)(existing) && (0,shared_esm_bundler/* remove */.Od)(existing, refValue);
          } else {
            if (!(0,shared_esm_bundler/* isArray */.kJ)(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if ((0,shared_esm_bundler/* hasOwn */.RI)(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if ((0,shared_esm_bundler/* hasOwn */.RI)(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else if (false) {}
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {}
  }
}
let hasMismatch = false;
const isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = node => node.nodeType === 8 /* COMMENT */;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
       false && 0;
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const {
      type,
      ref,
      shapeFlag,
      patchFlag
    } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3 /* TEXT */) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
             false && 0;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 /* COMMENT */ || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8 /* COMMENT */) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else if (false) {}
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const {
      type,
      props,
      patchFlag,
      shapeFlag,
      dirs
    } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if ( false || forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || (0,shared_esm_bundler/* isOn */.F7)(key) && !(0,shared_esm_bundler/* isReservedProp */.Gg)(key)) {
              patchProp(el, key, null, props[key], false, void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 &&
      // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        let hasWarned = false;
        while (next) {
          hasMismatch = true;
          if (false) {}
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
           false && 0;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        if (false) {}
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const {
      slotScopeIds: fragmentSlotScopeIds
    } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
     false && 0;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };
  const locateClosingAsyncAnchor = node => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[") match++;
        if (node.data === "]") {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate, hydrateNode];
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (false) {}
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (false) {}
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
function initFeatureFlags() {
  const needWarn = [];
  if (false) {}
  if (false) {}
  if (false) {}
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = (0,shared_esm_bundler/* getGlobalThis */.E9)();
  target.__VUE__ = true;
  if (false) {}
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = shared_esm_bundler/* NOOP */.dG,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const {
      type,
      ref,
      shapeFlag
    } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (false) {}
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (false) {}
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({
    el,
    anchor
  }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({
    el,
    anchor
  }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const {
      type,
      props,
      shapeFlag,
      transition,
      dirs
    } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !(0,shared_esm_bundler/* isReservedProp */.Gg)(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (false) {}
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {}
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let {
      patchFlag,
      dynamicChildren,
      dirs
    } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || shared_esm_bundler/* EMPTY_OBJ */.kT;
    const newProps = n2.props || shared_esm_bundler/* EMPTY_OBJ */.kT;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {}
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (false) {}
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container =
      // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && (
      // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment ||
      // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) ||
      // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) :
      // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== shared_esm_bundler/* EMPTY_OBJ */.kT) {
        for (const key in oldProps) {
          if (!(0,shared_esm_bundler/* isReservedProp */.Gg)(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if ((0,shared_esm_bundler/* isReservedProp */.Gg)(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let {
      patchFlag,
      dynamicChildren,
      slotScopeIds: fragmentSlotScopeIds
    } = n2;
    if (false) {}
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren &&
      // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (false) {} else if (
        // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true
          /* shallow */);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (false) {}
    if (false) {}
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (false) {}
      setupComponent(instance);
      if (false) {}
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    if (false) {}
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) {}
        updateComponentPreRender(instance, n2, optimized);
        if (false) {}
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const {
          el,
          props
        } = initialVNode;
        const {
          bm,
          m,
          parent
        } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          (0,shared_esm_bundler/* invokeArrayFns */.ir)(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (false) {}
            instance.subTree = renderComponentRoot(instance);
            if (false) {}
            if (false) {}
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            if (false) {}
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {}
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) {}
          if (false) {}
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          if (false) {}
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (false) {}
        initialVNode = container = anchor = null;
      } else {
        let {
          next,
          bu,
          u,
          parent,
          vnode
        } = instance;
        let originNext = next;
        let vnodeHook;
        if (false) {}
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          (0,shared_esm_bundler/* invokeArrayFns */.ir)(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (false) {}
        const nextTree = renderComponentRoot(instance);
        if (false) {}
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) {}
        patch(prevTree, nextTree,
        // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el),
        // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        if (false) {}
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        if (false) {}
        if (false) {}
      }
    };
    const effect = instance.effect = new reactivity_esm_bundler/* ReactiveEffect */.qq(componentUpdateFn, () => queueJob(update), instance.scope
    // track it in component's effect scope
    );

    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (false) {}
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,reactivity_esm_bundler/* pauseTracking */.Jd)();
    flushPreFlushCbs();
    (0,reactivity_esm_bundler/* resetTracking */.lk)();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const {
      patchFlag,
      shapeFlag
    } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || shared_esm_bundler/* EMPTY_ARR */.Z6;
    c2 = c2 || shared_esm_bundler/* EMPTY_ARR */.Z6;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (false) {}
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared_esm_bundler/* EMPTY_ARR */.Z6;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const {
      el,
      type,
      transition,
      children,
      shapeFlag
    } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const {
          leave,
          delayLeave,
          afterLeave
        } = transition;
        const remove2 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (
      // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = vnode => {
    const {
      type,
      el,
      anchor,
      transition
    } = vnode;
    if (type === Fragment) {
      if (false) {} else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const {
        leave,
        delayLeave
      } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (false) {}
    const {
      bum,
      scope,
      update,
      subTree,
      um
    } = instance;
    if (bum) {
      (0,shared_esm_bundler/* invokeArrayFns */.ir)(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) {}
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = vnode => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({
  effect,
  update
}, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if ((0,shared_esm_bundler/* isArray */.kJ)(ch1) && (0,shared_esm_bundler/* isArray */.kJ)(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow) traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (false) {}
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
const isTeleport = type => type.__isTeleport;
const isTeleportDisabled = props => props && (props.disabled || props.disabled === "");
const isTargetSVG = target => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if ((0,shared_esm_bundler/* isString */.HD)(targetSelector)) {
    if (!select) {
       false && 0;
      return null;
    } else {
      const target = select(targetSelector);
      if (!target) {
         false && 0;
      }
      return target;
    }
  } else {
    if (false) {}
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: {
        insert,
        querySelector,
        createText,
        createComment
      }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let {
      shapeFlag,
      children,
      dynamicChildren
    } = n2;
    if (false) {}
    if (n1 == null) {
      const placeholder = n2.el =  false ? 0 : createText("");
      const mainAnchor = n2.anchor =  false ? 0 : createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      } else if (false) {}
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          } else if (false) {}
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, {
    um: unmount,
    o: {
      remove: hostRemove
    }
  }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, {
  o: {
    insert
  },
  m: move
}, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const {
    el,
    anchor,
    shapeFlag,
    children,
    props
  } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: {
    nextSibling,
    parentNode,
    querySelector
  }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared_esm_bundler/* EMPTY_ARR */.Z6 : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true
  /* isBlock */));
}

function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */));
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (false) {}
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({
  key
}) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? (0,shared_esm_bundler/* isString */.HD)(ref) || (0,reactivity_esm_bundler/* isRef */.dq)(ref) || (0,shared_esm_bundler/* isFunction */.mf)(ref) ? {
    i: currentRenderingInstance,
    r: ref,
    k: ref_key,
    f: !!ref_for
  } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= (0,shared_esm_bundler/* isString */.HD)(children) ? 8 : 16;
  }
  if (false) {}
  if (isBlockTreeEnabled > 0 &&
  // avoid a block node from tracking itself
  !isBlockNode &&
  // has current parent block
  currentBlock && (
  // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  vnode.patchFlag > 0 || shapeFlag & 6) &&
  // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode =  false ? 0 : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {}
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true
    /* mergeRef: true */);

    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let {
      class: klass,
      style
    } = props;
    if (klass && !(0,shared_esm_bundler/* isString */.HD)(klass)) {
      props.class = (0,shared_esm_bundler/* normalizeClass */.C_)(klass);
    }
    if ((0,shared_esm_bundler/* isObject */.Kn)(style)) {
      if ((0,reactivity_esm_bundler/* isProxy */.X3)(style) && !(0,shared_esm_bundler/* isArray */.kJ)(style)) {
        style = (0,shared_esm_bundler/* extend */.l7)({}, style);
      }
      props.style = (0,shared_esm_bundler/* normalizeStyle */.j5)(style);
    }
  }
  const shapeFlag = (0,shared_esm_bundler/* isString */.HD)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,shared_esm_bundler/* isObject */.Kn)(type) ? 4 : (0,shared_esm_bundler/* isFunction */.mf)(type) ? 2 : 0;
  if (false) {}
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props) return null;
  return (0,reactivity_esm_bundler/* isProxy */.X3)(props) || InternalObjectKey in props ? (0,shared_esm_bundler/* extend */.l7)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const {
    props,
    ref,
    patchFlag,
    children
  } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ?
    // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? (0,shared_esm_bundler/* isArray */.kJ)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  false ? 0 : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if ((0,shared_esm_bundler/* isArray */.kJ)(child)) {
    return createVNode(Fragment, null,
    // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const {
    shapeFlag
  } = vnode;
  if (children == null) {
    children = null;
  } else if ((0,shared_esm_bundler/* isArray */.kJ)(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if ((0,shared_esm_bundler/* isFunction */.mf)(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = (0,shared_esm_bundler/* normalizeClass */.C_)([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = (0,shared_esm_bundler/* normalizeStyle */.j5)([ret.style, toMerge.style]);
      } else if ((0,shared_esm_bundler/* isOn */.F7)(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !((0,shared_esm_bundler/* isArray */.kJ)(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new reactivity_esm_bundler/* EffectScope */.Bj(true
    /* detached */),

    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: shared_esm_bundler/* EMPTY_OBJ */.kT,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: shared_esm_bundler/* EMPTY_OBJ */.kT,
    data: shared_esm_bundler/* EMPTY_OBJ */.kT,
    props: shared_esm_bundler/* EMPTY_OBJ */.kT,
    attrs: shared_esm_bundler/* EMPTY_OBJ */.kT,
    slots: shared_esm_bundler/* EMPTY_OBJ */.kT,
    refs: shared_esm_bundler/* EMPTY_OBJ */.kT,
    setupState: shared_esm_bundler/* EMPTY_OBJ */.kT,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {} else {
    instance.ctx = {
      _: instance
    };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = (0,shared_esm_bundler/* getGlobalThis */.E9)()[settersKey])) {
    globalCurrentInstanceSetters = (0,shared_esm_bundler/* getGlobalThis */.E9)()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push(i => currentInstance = i);
  internalSetCurrentInstance = instance => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach(s => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = instance => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */(/* unused pure expression or super */ null && (makeMap("slot,component")));
function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    runtime_core_esm_bundler_warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const {
    props,
    children
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (false) {}
  instance.accessCache = /* @__PURE__ */Object.create(null);
  instance.proxy = (0,reactivity_esm_bundler/* markRaw */.Xl)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  if (false) {}
  const {
    setup
  } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    (0,reactivity_esm_bundler/* pauseTracking */.Jd)();
    const setupResult = callWithErrorHandling(setup, instance, 0, [ false ? 0 : instance.props, setupContext]);
    (0,reactivity_esm_bundler/* resetTracking */.lk)();
    unsetCurrentInstance();
    if ((0,shared_esm_bundler/* isPromise */.tI)(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then(resolvedResult => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch(e => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) {}
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,shared_esm_bundler/* isFunction */.mf)(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if ((0,shared_esm_bundler/* isObject */.Kn)(setupResult)) {
    if (false) {}
    if (false) {}
    instance.setupState = (0,reactivity_esm_bundler/* proxyRefs */.WL)(setupResult);
    if (false) {}
  } else if (false) {}
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = i => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const runtime_core_esm_bundler_isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (false) {}
        const {
          isCustomElement,
          compilerOptions
        } = instance.appContext.config;
        const {
          delimiters,
          compilerOptions: componentCompilerOptions
        } = Component;
        const finalCompilerOptions = (0,shared_esm_bundler/* extend */.l7)((0,shared_esm_bundler/* extend */.l7)({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
        if (false) {}
      }
    }
    instance.render = Component.render || shared_esm_bundler/* NOOP */.dG;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (true) {
    setCurrentInstance(instance);
    (0,reactivity_esm_bundler/* pauseTracking */.Jd)();
    applyOptions(instance);
    (0,reactivity_esm_bundler/* resetTracking */.lk)();
    unsetCurrentInstance();
  }
  if (false) {}
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs,  false ? 0 : {
    get(target, key) {
      (0,reactivity_esm_bundler/* track */.j)(instance, "get", "$attrs");
      return target[key];
    }
  }));
}
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = exposed => {
    if (false) {}
    instance.exposed = exposed || {};
  };
  if (false) {} else {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,reactivity_esm_bundler/* proxyRefs */.WL)((0,reactivity_esm_bundler/* markRaw */.Xl)(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return (0,shared_esm_bundler/* isFunction */.mf)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = registry => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return (0,shared_esm_bundler/* isFunction */.mf)(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return (0,reactivity_esm_bundler/* computed */.Fl)(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if ((0,shared_esm_bundler/* isObject */.Kn)(propsOrChildren) && !(0,shared_esm_bundler/* isArray */.kJ)(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
       false && 0;
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function runtime_core_esm_bundler_initCustomFormatter() {
  if (true) {
    return;
  }
  const vueStyle = {
    style: "color:#3ba776"
  };
  const numberStyle = {
    style: "color:#0b1bc9"
  };
  const stringStyle = {
    style: "color:#b62e24"
  };
  const keywordStyle = {
    style: "color:#9d288c"
  };
  const formatter = {
    header(obj) {
      if (!(0,shared_esm_bundler/* isObject */.Kn)(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if ((0,reactivity_esm_bundler/* isRef */.dq)(obj)) {
        return ["div", {}, ["span", vueStyle, genRefFlag(obj)], "<", formatValue(obj.value), `>`];
      } else if ((0,reactivity_esm_bundler/* isReactive */.PG)(obj)) {
        return ["div", {}, ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"], "<", formatValue(obj), `>${(0,reactivity_esm_bundler/* isReadonly */.$y)(obj) ? ` (readonly)` : ``}`];
      } else if ((0,reactivity_esm_bundler/* isReadonly */.$y)(obj)) {
        return ["div", {}, ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"], "<", formatValue(obj), ">"];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return ["div", {}, ...formatInstance(obj.$)];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", (0,reactivity_esm_bundler/* toRaw */.IU)(instance.props)));
    }
    if (instance.setupState !== shared_esm_bundler/* EMPTY_OBJ */.kT) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== shared_esm_bundler/* EMPTY_OBJ */.kT) {
      blocks.push(createInstanceBlock("data", (0,reactivity_esm_bundler/* toRaw */.IU)(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push(["div", {}, ["span", {
      style: keywordStyle.style + ";opacity:0.66"
    }, "$ (internal): "], ["object", {
      object: instance
    }]]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = (0,shared_esm_bundler/* extend */.l7)({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return ["div", {
      style: "line-height:1.25em;margin-bottom:0.6em"
    }, ["div", {
      style: "color:#476582"
    }, type], ["div", {
      style: "padding-left:1.25em"
    }, ...Object.keys(target).map(key => {
      return ["div", {}, ["span", keywordStyle, key + ": "], formatValue(target[key], false)];
    })]];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if ((0,shared_esm_bundler/* isObject */.Kn)(v)) {
      return ["object", {
        object: asRaw ? (0,reactivity_esm_bundler/* toRaw */.IU)(v) : v
      }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if ((0,shared_esm_bundler/* isFunction */.mf)(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if ((0,shared_esm_bundler/* isArray */.kJ)(opts) && opts.includes(key) || (0,shared_esm_bundler/* isObject */.Kn)(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if ((0,shared_esm_bundler/* hasChanged */.aU)(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.3.4";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;

;// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js




const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: child => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is
    } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: text => doc.createTextNode(text),
  createComment: text => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: node => node.parentNode,
  nextSibling: node => node.nextSibling,
  querySelector: selector => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
    // first
    before ? before.nextSibling : parent.firstChild,
    // last
    anchor ? anchor.previousSibling : parent.lastChild];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = (0,shared_esm_bundler/* isString */.HD)(next);
  if (next && !isCssString) {
    if (prev && !(0,shared_esm_bundler/* isString */.HD)(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(val)) {
    val.forEach(v => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (false) {}
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty((0,shared_esm_bundler/* hyphenate */.rs)(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = (0,shared_esm_bundler/* camelize */._A)(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = (0,shared_esm_bundler/* capitalize */.kC)(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = (0,shared_esm_bundler/* isSpecialBooleanAttr */.Pq)(key);
    if (value == null || isBoolean && !(0,shared_esm_bundler/* includeBooleanAttr */.yA)(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" &&
  // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = (0,shared_esm_bundler/* includeBooleanAttr */.yA)(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (false) {}
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : (0,shared_esm_bundler/* hyphenate */.rs)(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = e => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if ((0,shared_esm_bundler/* isArray */.kJ)(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(fn => e2 => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if ((0,shared_esm_bundler/* isOn */.F7)(key)) {
    if (!(0,shared_esm_bundler/* isModelListener */.tR)(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && (0,shared_esm_bundler/* isFunction */.mf)(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && (0,shared_esm_bundler/* isString */.HD)(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = options => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    /**
     * @internal
     */
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (false) {}
      this.attachShadow({
        mode: "open"
      });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    new MutationObserver(mutations => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, {
      attributes: true
    });
    const resolve = (def, isAsync = false) => {
      const {
        props,
        styles
      } = def;
      let numberProps;
      if (props && !(0,shared_esm_bundler/* isArray */.kJ)(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = (0,shared_esm_bundler/* toNumber */.He)(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */Object.create(null)))[(0,shared_esm_bundler/* camelize */._A)(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(def => resolve(def, true));
    } else {
      resolve(this._def);
    }
  }
  _resolveProps(def) {
    const {
      props
    } = def;
    const declaredPropKeys = (0,shared_esm_bundler/* isArray */.kJ)(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(shared_esm_bundler/* camelize */._A)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = (0,shared_esm_bundler/* camelize */._A)(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = (0,shared_esm_bundler/* toNumber */.He)(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute((0,shared_esm_bundler/* hyphenate */.rs)(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute((0,shared_esm_bundler/* hyphenate */.rs)(key), val + "");
        } else if (!val) {
          this.removeAttribute((0,shared_esm_bundler/* hyphenate */.rs)(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, (0,shared_esm_bundler/* extend */.l7)({}, this._props));
    if (!this._instance) {
      vnode.ce = instance => {
        this._instance = instance;
        instance.isCE = true;
        if (false) {}
        const dispatch = (event, args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if ((0,shared_esm_bundler/* hyphenate */.rs)(event) !== event) {
            dispatch((0,shared_esm_bundler/* hyphenate */.rs)(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach(css => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
        if (false) {}
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
       false && 0;
      return shared_esm_bundler/* EMPTY_OBJ */.kT;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
       false && 0;
      return shared_esm_bundler/* EMPTY_OBJ */.kT;
    }
    const mod = modules[name];
    if (!mod) {
       false && 0;
      return shared_esm_bundler/* EMPTY_OBJ */.kT;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
     false && 0;
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach(node => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, {
      childList: true
    });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach(c => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let {
      el,
      anchor
    } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, {
  slots
}) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */(0,shared_esm_bundler/* extend */.l7)({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
const runtime_dom_esm_bundler_callHook = (hook, args = []) => {
  if ((0,shared_esm_bundler/* isArray */.kJ)(hook)) {
    hook.forEach(h2 => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = hook => {
  return hook ? (0,shared_esm_bundler/* isArray */.kJ)(hook) ? hook.some(h2 => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = isAppear => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      runtime_dom_esm_bundler_callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return (0,shared_esm_bundler/* extend */.l7)(baseProps, {
    onBeforeEnter(el) {
      runtime_dom_esm_bundler_callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      runtime_dom_esm_bundler_callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      runtime_dom_esm_bundler_callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      runtime_dom_esm_bundler_callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      runtime_dom_esm_bundler_callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      runtime_dom_esm_bundler_callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,shared_esm_bundler/* isObject */.Kn)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = (0,shared_esm_bundler/* toNumber */.He)(val);
  if (false) {}
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(c => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
  const {
    _vtc
  } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const {
    type,
    timeout,
    propCount
  } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = e => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = key => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */new WeakMap();
const newPositionMap = /* @__PURE__ */new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */(0,shared_esm_bundler/* extend */.l7)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach(c => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = e => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = (0,reactivity_esm_bundler/* toRaw */.IU)(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        } else if (false) {}
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = props => delete props.mode;
/* @__PURE__ */
removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach(cls => {
      cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const {
    hasTransform
  } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = vnode => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return (0,shared_esm_bundler/* isArray */.kJ)(fn) ? value => (0,shared_esm_bundler/* invokeArrayFns */.ir)(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, {
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", e => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = (0,shared_esm_bundler/* looseToNumber */.h5)(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, {
    value
  }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, {
    value,
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing) return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && (0,shared_esm_bundler/* looseToNumber */.h5)(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el._assign;
      if ((0,shared_esm_bundler/* isArray */.kJ)(modelValue)) {
        const index = (0,shared_esm_bundler/* looseIndexOf */.hq)(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,shared_esm_bundler/* isSet */.DM)(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, {
  value,
  oldValue
}, vnode) {
  el._modelValue = value;
  if ((0,shared_esm_bundler/* isArray */.kJ)(value)) {
    el.checked = (0,shared_esm_bundler/* looseIndexOf */.hq)(value, vnode.props.value) > -1;
  } else if ((0,shared_esm_bundler/* isSet */.DM)(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = (0,shared_esm_bundler/* looseEqual */.WV)(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, {
    value
  }, vnode) {
    el.checked = (0,shared_esm_bundler/* looseEqual */.WV)(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, {
    value,
    oldValue
  }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = (0,shared_esm_bundler/* looseEqual */.WV)(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, {
    value,
    modifiers: {
      number
    }
  }, vnode) {
    const isSetModel = (0,shared_esm_bundler/* isSet */.DM)(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? (0,shared_esm_bundler/* looseToNumber */.h5)(getValue(o)) : getValue(o));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, {
    value
  }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, {
    value
  }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !(0,shared_esm_bundler/* isArray */.kJ)(value) && !(0,shared_esm_bundler/* isSet */.DM)(value)) {
     false && 0;
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if ((0,shared_esm_bundler/* isArray */.kJ)(value)) {
        option.selected = (0,shared_esm_bundler/* looseIndexOf */.hq)(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if ((0,shared_esm_bundler/* looseEqual */.WV)(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({
    value
  }) => ({
    value
  });
  vModelRadio.getSSRProps = ({
    value
  }, vnode) => {
    if (vnode.props && (0,shared_esm_bundler/* looseEqual */.WV)(vnode.props.value, value)) {
      return {
        checked: true
      };
    }
  };
  vModelCheckbox.getSSRProps = ({
    value
  }, vnode) => {
    if ((0,shared_esm_bundler/* isArray */.kJ)(value)) {
      if (vnode.props && (0,shared_esm_bundler/* looseIndexOf */.hq)(value, vnode.props.value) > -1) {
        return {
          checked: true
        };
      }
    } else if ((0,shared_esm_bundler/* isSet */.DM)(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return {
          checked: true
        };
      }
    } else if (value) {
      return {
        checked: true
      };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
    // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
    vnode.type.toUpperCase(), vnode.props && vnode.props.type);
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !e.ctrlKey,
  shift: e => !e.shiftKey,
  alt: e => !e.altKey,
  meta: e => !e.metaKey,
  left: e => "button" in e && e.button !== 0,
  middle: e => "button" in e && e.button !== 1,
  right: e => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return event => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = (0,shared_esm_bundler/* hyphenate */.rs)(event.key);
    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el, {
    value
  }, {
    transition
  }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, {
    value
  }, {
    transition
  }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, {
    value,
    oldValue
  }, {
    transition
  }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, {
    value
  }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({
    value
  }) => {
    if (!value) {
      return {
        style: {
          display: "none"
        }
      };
    }
  };
}
const rendererOptions = /* @__PURE__ */(0,shared_esm_bundler/* extend */.l7)({
  patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (false) {}
  const {
    mount
  } = app;
  app.mount = containerOrSelector => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!(0,shared_esm_bundler/* isFunction */.mf)(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  if (false) {}
  const {
    mount
  } = app;
  app.mount = containerOrSelector => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: tag => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if (isRuntimeOnly()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn(msg);
        return compilerOptions;
      },
      set() {
        warn(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if ((0,shared_esm_bundler/* isString */.HD)(container)) {
    const res = document.querySelector(container);
    if (false) {}
    return res;
  }
  if (false) {}
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};

;// CONCATENATED MODULE: ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js



function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
   false && 0;
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg =  false ? 0 : code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const errorMessages = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `Error parsing JavaScript expression: `,
  [46]: `<KeepAlive> expects exactly one child component.`,
  // generic errors
  [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [48]: `ES module mode is not supported in this build of compiler.`,
  [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [50]: `"scopeId" option is only supported in module mode.`,
  // deprecations
  [51]: `@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.`,
  [52]: `v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.`,
  // just to fulfill types
  [53]: ``
};
const FRAGMENT = Symbol( false ? 0 : ``);
const TELEPORT = Symbol( false ? 0 : ``);
const SUSPENSE = Symbol( false ? 0 : ``);
const KEEP_ALIVE = Symbol( false ? 0 : ``);
const BASE_TRANSITION = Symbol( false ? 0 : ``);
const OPEN_BLOCK = Symbol( false ? 0 : ``);
const CREATE_BLOCK = Symbol( false ? 0 : ``);
const CREATE_ELEMENT_BLOCK = Symbol( false ? 0 : ``);
const CREATE_VNODE = Symbol( false ? 0 : ``);
const CREATE_ELEMENT_VNODE = Symbol( false ? 0 : ``);
const CREATE_COMMENT = Symbol( false ? 0 : ``);
const CREATE_TEXT = Symbol( false ? 0 : ``);
const CREATE_STATIC = Symbol( false ? 0 : ``);
const RESOLVE_COMPONENT = Symbol( false ? 0 : ``);
const RESOLVE_DYNAMIC_COMPONENT = Symbol( false ? 0 : ``);
const RESOLVE_DIRECTIVE = Symbol( false ? 0 : ``);
const RESOLVE_FILTER = Symbol( false ? 0 : ``);
const WITH_DIRECTIVES = Symbol( false ? 0 : ``);
const RENDER_LIST = Symbol( false ? 0 : ``);
const RENDER_SLOT = Symbol( false ? 0 : ``);
const CREATE_SLOTS = Symbol( false ? 0 : ``);
const TO_DISPLAY_STRING = Symbol( false ? 0 : ``);
const MERGE_PROPS = Symbol( false ? 0 : ``);
const NORMALIZE_CLASS = Symbol( false ? 0 : ``);
const NORMALIZE_STYLE = Symbol( false ? 0 : ``);
const NORMALIZE_PROPS = Symbol( false ? 0 : ``);
const GUARD_REACTIVE_PROPS = Symbol( false ? 0 : ``);
const TO_HANDLERS = Symbol( false ? 0 : ``);
const CAMELIZE = Symbol( false ? 0 : ``);
const CAPITALIZE = Symbol( false ? 0 : ``);
const TO_HANDLER_KEY = Symbol( false ? 0 : ``);
const SET_BLOCK_TRACKING = Symbol( false ? 0 : ``);
const PUSH_SCOPE_ID = Symbol( false ? 0 : ``);
const POP_SCOPE_ID = Symbol( false ? 0 : ``);
const WITH_CTX = Symbol( false ? 0 : ``);
const UNREF = Symbol( false ? 0 : ``);
const IS_REF = Symbol( false ? 0 : ``);
const WITH_MEMO = Symbol( false ? 0 : ``);
const IS_MEMO_SAME = Symbol( false ? 0 : ``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach(s => {
    helperNameMap[s] = helpers[s];
  });
}
const locStub = {
  source: "",
  start: {
    line: 1,
    column: 1,
    offset: 0
  },
  end: {
    line: 1,
    column: 1,
    offset: 0
  }
};
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: /* @__PURE__ */new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: (0,shared_esm_bundler/* isString */.HD)(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, {
  helper,
  removeHelper,
  inSSR
}) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
const isStaticExp = p => p.type === 4 && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === (0,shared_esm_bundler/* hyphenate */.rs)(expected);
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = name => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const isMemberExpressionBrowser = path => {
  path = path.trim().replace(whitespaceRE, s => s.trim());
  let state = 0 /* inMemberExp */;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0 /* inMemberExp */:
        if (char === "[") {
          stateStack.push(state);
          state = 1 /* inBrackets */;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2 /* inParens */;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1 /* inBrackets */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (! --currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2 /* inParens */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (! --currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3 /* inString */:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = (/* unused pure expression or super */ null && (NOOP));
const isMemberExpression = isMemberExpressionBrowser;
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation((0,shared_esm_bundler/* extend */.l7)({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && ((0,shared_esm_bundler/* isString */.HD)(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(p => p.type === 7 && p.name === "bind" && (!p.arg ||
  // v-bind="obj"
  p.arg.type !== 4 ||
  // v-bind:[_ctx.foo]
  !p.arg.isStatic)
  // v-bind:[foo]
  );
}

function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !(0,shared_esm_bundler/* isString */.HD)(props) && props.type === 14) {
    const callee = props.callee;
    if (!(0,shared_esm_bundler/* isString */.HD)(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !(0,shared_esm_bundler/* isString */.HD)(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || (0,shared_esm_bundler/* isString */.HD)(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!(0,shared_esm_bundler/* isString */.HD)(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(p => p.key.type === 4 && p.key.content === propKeyName);
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some(c => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some(c => hasScopeRef(c, ids));
    case 9:
      return node.branches.some(b => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some(c => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some(c => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (false) {}
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: key => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_PROP"]: {
    message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTER"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (false) {}
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const {
    message,
    link
  } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
const defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: shared_esm_bundler.NO,
  isPreTag: shared_esm_bundler.NO,
  isCustomElement: shared_esm_bundler.NO,
  decodeEntities: rawText => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: !!("production" !== "production")
};
function compiler_core_esm_bundler_baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
  const options = (0,shared_esm_bundler/* extend */.l7)({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, TagType.End, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some(p => p.type === 7 && isSpecialTemplateDirective(p.name))) {
             false && 0;
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if ((0,shared_esm_bundler/* isArray */.kJ)(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.type === 2) {
        if (!context.inPre) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 && next.type === 3 || prev.type === 3 && next.type === 1 || prev.type === 1 && next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else {
          node.content = node.content.replace(/\r\n/g, "\n");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1,
      nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, TagType.Start, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find(p => p.type === 6 && p.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
var TagType = /* @__PURE__ */(TagType2 => {
  TagType2[TagType2["Start"] = 0] = "Start";
  TagType2[TagType2["End"] = 1] = "End";
  return TagType2;
})(TagType || {});
const isSpecialTemplateDirective = /* @__PURE__ */(0,shared_esm_bundler/* makeMap */.fY)(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 /* Start */ && !context.inVPre && props.some(p => p.type === 7 && p.name === "pre")) {
    context.inVPre = true;
    (0,shared_esm_bundler/* extend */.l7)(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter(p => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 /* End */ && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1 /* End */) {
    return;
  }
  if (false) {}
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some(p => p.type === 7 && isSpecialTemplateDirective(p.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
    // to be created during transform phase
  };
}

function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (
      // :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = /* @__PURE__ */new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1 /* End */) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0 /* Start */) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  var _a;
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match2[2], name.length - (((_a = match2[3]) == null ? void 0 : _a.length) || 0));
      const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand) modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
      if (false) {}
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return {
    content,
    isQuoted,
    loc: getSelection(context, start)
  };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const {
    column,
    line,
    offset
  } = context;
  return {
    column,
    line,
    offset
  };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const {
    source
  } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2:
      {
        const parent = last(ancestors);
        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true;
        }
        break;
      }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(root, context,
  // Root node is unfortunately non-hoistable due to potential parent
  // fallthrough attributes.
  isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
  const {
    children
  } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const {
    children
  } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + ( false ? 0 : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent = child.tagType === 1;
      if (isComponent) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && (0,shared_esm_bundler/* isArray */.kJ)(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context) {
  const {
    constantCache
  } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,shared_esm_bundler/* isString */.HD)(child) || (0,shared_esm_bundler/* isSymbol */.yk)(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (false) {}
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */new Set([NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !(0,shared_esm_bundler/* isString */.HD)(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const {
      properties
    } = props;
    for (let i = 0; i < properties.length; i++) {
      const {
        key,
        value
      } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = shared_esm_bundler/* NOOP */.dG,
  isCustomElement = shared_esm_bundler/* NOOP */.dG,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = shared_esm_bundler/* EMPTY_OBJ */.kT,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    selfName: nameMatch && (0,shared_esm_bundler/* capitalize */.kC)((0,shared_esm_bundler/* camelize */._A)(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */new Map(),
    components: /* @__PURE__ */new Set(),
    directives: /* @__PURE__ */new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (false) {}
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (false) {}
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (false) {}
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {},
    addIdentifiers(exp) {},
    removeIdentifiers(exp) {},
    hoist(exp) {
      if ((0,shared_esm_bundler/* isString */.HD)(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = /* @__PURE__ */new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const {
    helper
  } = context;
  const {
    children
  } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = shared_esm_bundler/* PatchFlagNames */.m[64];
    if (false) {}
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + ( false ? 0 : ``), void 0, void 0, true, void 0, false
    /* isComponent */);
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if ((0,shared_esm_bundler/* isString */.HD)(child)) continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const {
    nodeTransforms
  } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if ((0,shared_esm_bundler/* isArray */.kJ)(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = (0,shared_esm_bundler/* isString */.HD)(name) ? n => n === name : n => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const {
        props
      } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = s => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const isSetupInlined = false;
  const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC].filter(helper => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, {
  helper,
  push,
  newline,
  isTS
}) {
  const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const {
    push,
    newline,
    helper,
    scopeId,
    mode
  } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 ||  false && 0;
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const {
    push,
    newline
  } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if ((0,shared_esm_bundler/* isString */.HD)(node)) {
      push(node);
    } else if ((0,shared_esm_bundler/* isArray */.kJ)(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if ((0,shared_esm_bundler/* isString */.HD)(node)) {
    context.push(node);
    return;
  }
  if ((0,shared_esm_bundler/* isSymbol */.yk)(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
       false && 0;
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (false) {}
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const {
    content,
    isStatic
  } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const {
    push,
    helper,
    pure
  } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if ((0,shared_esm_bundler/* isString */.HD)(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const {
    push
  } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const {
    push,
    helper,
    pure
  } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const {
    push,
    helper,
    pure
  } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map(arg => arg || `null`);
}
function genCallExpression(node, context) {
  const {
    push,
    helper,
    pure
  } = context;
  const callee = (0,shared_esm_bundler/* isString */.HD)(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const {
    push,
    indent,
    deindent,
    newline
  } = context;
  const {
    properties
  } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 ||  false && 0;
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const {
      key,
      value
    } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const {
    push,
    indent,
    deindent
  } = context;
  const {
    params,
    returns,
    body,
    newline,
    isSlot
  } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if ((0,shared_esm_bundler/* isArray */.kJ)(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if ((0,shared_esm_bundler/* isArray */.kJ)(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const {
    test,
    consequent,
    alternate,
    newline: needNewline
  } = node;
  const {
    push,
    indent,
    deindent,
    newline
  } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true
  /* without newline */);
}

function genCacheExpression(node, context) {
  const {
    push,
    helper,
    indent,
    deindent,
    newline
  } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach(element => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
const isFunctionType = node => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = node => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
const TS_NODE_TYPES = (/* unused pure expression or super */ null && (["TSAsExpression",
// foo as number
"TSTypeAssertion",
// (<number>foo)
"TSNonNullExpression",
// foo!
"TSInstantiationExpression",
// foo<string>
"TSSatisfiesExpression"
// foo satisfies T
]));

const prohibitedKeywordRE = new RegExp("\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b");
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(createCompilerError(45, node.loc, void 0, message));
  }
}
const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(node.content, context);
  } else if (node.type === 1) {
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
          dir.exp = processExpression(exp, context,
          // slot args must be processed as function params
          dir.name === "slot");
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (false) {}
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
  return processIf(node, dir, context, (ifNode, branch, isRoot) => {
    const siblings = context.parent.children;
    let i = siblings.indexOf(ifNode);
    let key = 0;
    while (i-- >= 0) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 9) {
        key += sibling.branches.length;
      }
    }
    return () => {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        const parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
});
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (false) {}
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
         false && 0;
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (false) {}
        if (false) {}
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    createCallExpression(context.helper(CREATE_COMMENT), [ false ? 0 : '""', "true"]));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const {
    helper
  } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const {
    children
  } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = shared_esm_bundler/* PatchFlagNames */.m[64];
      if (false) {}
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ( false ? 0 : ``), void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
const transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
  const {
    helper,
    removeHelper
  } = context;
  return processFor(node, dir, context, forNode => {
    const renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);
    const isTemplate = isTemplateNode(node);
    const memo = findDir(node, "memo");
    const keyProp = findProp(node, `key`);
    const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
    const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
    const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
    const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + ( false ? 0 : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
    return () => {
      let childBlock;
      const {
        children
      } = forNode;
      if (false) {}
      const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
      const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
      if (slotOutlet) {
        childBlock = slotOutlet.codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + ( false ? 0 : ``), void 0, void 0, true, void 0, false
        /* isComponent */);
      } else {
        childBlock = children[0].codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            removeHelper(OPEN_BLOCK);
            removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        childBlock.isBlock = !isStableFragment;
        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
        } else {
          helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
        }
      }
      if (memo) {
        const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [createSimpleExpression(`_cached`)]));
        loop.body = createBlockStatement([createCompoundExpression([`const _memo = (`, memo.exp, `)`]), createCompoundExpression([`if (_cached`, ...(keyExp ? [` && _cached.key === `, keyExp] : []), ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`]), createCompoundExpression([`const _item = `, childBlock]), createSimpleExpression(`_item.memo = _memo`), createSimpleExpression(`return _item`)]);
        renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
      } else {
        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true
        /* force newline */));
      }
    };
  });
});

function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(
  // can only be simple expression because vFor transform is applied
  // before expression transform.
  dir.exp, context);
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const {
    addIdentifiers,
    removeIdentifiers,
    scopes
  } = context;
  const {
    source,
    value,
    key,
    index
  } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  if (false) {}
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (false) {}
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        if (false) {}
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (false) {}
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({
  value,
  key,
  index
}, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
    const result = vFor.parseResult = parseForExpression(vFor.exp, context);
    if (result) {
      const {
        value,
        key,
        index
      } = result;
      const {
        addIdentifiers,
        removeIdentifiers
      } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const {
    children,
    loc
  } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const {
      arg,
      exp
    } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const {
      children: slotChildren,
      loc: slotLoc
    } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true
    /* allowEmpty */)) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true
        /* force newline */)]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length &&
    // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some(node2 => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`,
  // 2 = compiled but dynamic = can skip normalization, but must run diff
  // 1 = compiled and static = can skip normalization AND diff as optimized
  createSimpleExpression(slotFlag + ( false ? 0 : ``), false))), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [createObjectProperty(`name`, name), createObjectProperty(`fn`, fn)];
  if (index != null) {
    props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12) return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
const directiveImportMap = /* @__PURE__ */new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const {
      tag,
      props
    } = node;
    const isComponent = node.tagType === 1;
    let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = (0,shared_esm_bundler/* isObject */.Kn)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock =
    // dynamic component may resolve to plain elements
    isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && (
    // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    tag === "svg" || tag === "foreignObject");
    if (props.length > 0) {
      const propsBuildResult = buildProps(node, context, void 0, isComponent, isDynamicComponent);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context))) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if (false) {}
      }
      const shouldBuildAsSlots = isComponent &&
      // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT &&
      // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const {
          slots,
          hasDynamicSlots
        } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      if (false) {} else {
        vnodePatchFlag = String(patchFlag);
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent, node.loc);
  };
};
function resolveComponentType(node, context, ssr = false) {
  let {
    tag
  } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    if (false) {}
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [isDir.exp]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
  const {
    tag,
    loc: elementLoc,
    children
  } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = arg => {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({
    key,
    value
  }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = (0,shared_esm_bundler/* isOn */.F7)(name);
      if (isEventHandler && (!isComponent || isDynamicComponent) &&
      // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" &&
      // omit v-model handlers
      name !== "onUpdate:modelValue" &&
      // omit onVnodeXXX hooks
      !(0,shared_esm_bundler/* isReservedProp */.Gg)(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && (0,shared_esm_bundler/* isReservedProp */.Gg)(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const {
        loc,
        name,
        value
      } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const {
        name,
        arg,
        exp,
        loc
      } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
      // #938: elements with dynamic keys should be forced into blocks
      isVBind && isStaticArgOf(arg, "key") ||
      // inline before-update hooks need to force block so that it is invoked
      // before children
      isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            {
              if (false) {}
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const {
          props: props2,
          needRuntime
        } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if ((0,shared_esm_bundler/* isSymbol */.yk)(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!(0,shared_esm_bundler/* isBuiltInDirective */.wh)(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && (
          // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` ||
          // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [propsExpression])]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || (0,shared_esm_bundler/* isOn */.F7)(name)) {
        compiler_core_esm_bundler_mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function compiler_core_esm_bundler_mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const {
    loc
  } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const {
      children,
      loc
    } = node;
    const {
      slotName,
      slotProps
    } = processSlotOutlet(node, context);
    const slotArgs = [context.prefixIdentifiers ? `_ctx.$slots` : `$slots`, slotName, "{}", "undefined", "true"];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = (0,shared_esm_bundler/* camelize */._A)(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = (0,shared_esm_bundler/* camelize */._A)(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const {
      props,
      directives
    } = buildProps(node, context, nonNameProps, false, false);
    slotProps = props;
    if (directives.length) {
      context.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
  const {
    loc,
    modifiers,
    arg
  } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (false) {}
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ?
      // for non-element and vnode lifecycle event listeners, auto convert
      // it to camelCase. See issue #2249
      (0,shared_esm_bundler/* toHandlerKey */.hR)((0,shared_esm_bundler/* camelize */._A)(rawName)) :
      // preserve case for plain element listeners that have uppercase
      // letters, as these may be custom elements' custom events
      `on:${rawName}`;
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([`${context.helperString(TO_HANDLER_KEY)}(`, arg, `)`]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (false) {}
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([`${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`, exp, hasMultipleStatements ? `}` : `)`]);
    }
  }
  let ret = {
    props: [createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach(p => p.key.isHandlerKey = true);
  return ret;
};
const transformBind = (dir, _node, context) => {
  const {
    exp,
    modifiers,
    loc
  } = dir;
  const arg = dir.arg;
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = (0,shared_esm_bundler/* camelize */._A)(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  if (!exp || exp.type === 4 && !exp.content.trim()) {
    context.onError(createCompilerError(34, loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
    };
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression([child], child.loc);
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText ||
      // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 &&
      // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(p => p.type === 7 && !context.directiveTransforms[p.name]) &&
      // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(1 + ( false ? 0 : ``));
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          };
        }
      }
    };
  }
};
const seen$1 = /* @__PURE__ */new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true
        /* isVNode */);
      }
    };
  }
};

const transformModel = (dir, node, context) => {
  const {
    exp,
    arg
  } = dir;
  if (!exp) {
    context.onError(createCompilerError(41, dir.loc));
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context.onError(createCompilerError(42, exp.loc));
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${(0,shared_esm_bundler/* camelize */._A)(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([`${eventArg} => ((`, exp, `) = $event)`]);
  }
  const props = [
  // modelValue: foo
  createObjectProperty(propName, dir.exp),
  // "onUpdate:modelValue": $event => (foo = $event)
  createObjectProperty(eventName, assignmentExp)];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return {
    props
  };
}
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTER", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  }
  if (node.type === 1) {
    node.props.forEach(prop => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c,
    prev,
    i,
    expression,
    filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 &&
    // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
     false && 0;
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
const seen = /* @__PURE__ */new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [dir.exp, createFunctionExpression(void 0, codegenNode), `_cache`, String(context.cached++)]);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [[transformOnce, transformIf, transformMemo, transformFor, ...[transformFilter], ...( false ? 0 : []), transformSlotOutlet, transformElement, trackSlotScopes, transformText], {
    on: transformOn,
    bind: transformBind,
    model: transformModel
  }];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const ast = (0,shared_esm_bundler/* isString */.HD)(template) ? compiler_core_esm_bundler_baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast, (0,shared_esm_bundler/* extend */.l7)({}, options, {
    prefixIdentifiers,
    nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])
    // user transforms
    ],

    directiveTransforms: (0,shared_esm_bundler/* extend */.l7)({}, directiveTransforms, options.directiveTransforms || {}
    // user transforms
    )
  }));

  return generate(ast, (0,shared_esm_bundler/* extend */.l7)({}, options, {
    prefixIdentifiers
  }));
}
const noopDirectiveTransform = () => ({
  props: []
});

;// CONCATENATED MODULE: ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js




const V_MODEL_RADIO = Symbol( false ? 0 : ``);
const V_MODEL_CHECKBOX = Symbol( false ? 0 : ``);
const V_MODEL_TEXT = Symbol( false ? 0 : ``);
const V_MODEL_SELECT = Symbol( false ? 0 : ``);
const V_MODEL_DYNAMIC = Symbol( false ? 0 : ``);
const V_ON_WITH_MODIFIERS = Symbol( false ? 0 : ``);
const V_ON_WITH_KEYS = Symbol( false ? 0 : ``);
const V_SHOW = Symbol( false ? 0 : ``);
const compiler_dom_esm_bundler_TRANSITION = Symbol( false ? 0 : ``);
const TRANSITION_GROUP = Symbol( false ? 0 : ``);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [compiler_dom_esm_bundler_TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
const isRawTextContainer = /* @__PURE__ */(0,shared_esm_bundler/* makeMap */.fY)("style,iframe,script,noscript", true);
const parserOptions = {
  isVoidTag: shared_esm_bundler/* isVoidTag */.WB,
  isNativeTag: tag => (0,shared_esm_bundler/* isHTMLTag */.eS)(tag) || (0,shared_esm_bundler/* isSVGTag */.aN)(tag),
  isPreTag: tag => tag === "pre",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: tag => {
    if (isBuiltInType(tag, `Transition`)) {
      return compiler_dom_esm_bundler_TRANSITION;
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : 0;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(a => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({
    tag,
    ns
  }) {
    if (ns === 0) {
      if (tag === "textarea" || tag === "title") {
        return 1;
      }
      if (isRawTextContainer(tag)) {
        return 2;
      }
    }
    return 0;
  }
};
const transformStyle = node => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = (0,shared_esm_bundler/* parseStringStyle */.yL)(cssText);
  return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
};
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc,  false ? 0 : void 0);
}
const DOMErrorMessages = {
  [53]: `v-html is missing expression.`,
  [54]: `v-html will override element children.`,
  [55]: `v-text is missing expression.`,
  [56]: `v-text will override element children.`,
  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [58]: `v-model argument is not supported on plain elements.`,
  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [61]: `v-show is missing expression.`,
  [62]: `<Transition> expects exactly one child element or component.`,
  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};
const transformVHtml = (dir, node, context) => {
  const {
    exp,
    loc
  } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(53, loc));
  }
  if (node.children.length) {
    context.onError(createDOMCompilerError(54, loc));
    node.children.length = 0;
  }
  return {
    props: [createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))]
  };
};
const transformVText = (dir, node, context) => {
  const {
    exp,
    loc
  } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(55, loc));
  }
  if (node.children.length) {
    context.onError(createDOMCompilerError(56, loc));
    node.children.length = 0;
  }
  return {
    props: [createObjectProperty(createSimpleExpression(`textContent`, true), exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))]
  };
};
const compiler_dom_esm_bundler_transformModel = (dir, node, context) => {
  const baseResult = transformModel(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(createDOMCompilerError(58, dir.arg.loc));
  }
  function checkDuplicatedValue() {
    const value = findProp(node, "value");
    if (value) {
      context.onError(createDOMCompilerError(60, value.loc));
    }
  }
  const {
    tag
  } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(createDOMCompilerError(59, dir.loc));
              break;
            default:
               false && 0;
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
         false && 0;
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
       false && 0;
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(createDOMCompilerError(57, dir.loc));
  }
  baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 && p.key.content === "modelValue"));
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */(0,shared_esm_bundler/* makeMap */.fY)(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */(0,shared_esm_bundler/* makeMap */.fY)(
// event propagation management
`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
const maybeKeyModifier = /* @__PURE__ */(0,shared_esm_bundler/* makeMap */.fY)("left,right");
const isKeyboardEvent = /* @__PURE__ */(0,shared_esm_bundler/* makeMap */.fY)(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i];
    if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([`(`, key, `) === "onClick" ? "${event}" : (`, key, `)`]) : key;
};
const compiler_dom_esm_bundler_transformOn = (dir, node, context) => {
  return transformOn(dir, node, context, baseResult => {
    const {
      modifiers
    } = dir;
    if (!modifiers.length) return baseResult;
    let {
      key,
      value: handlerExp
    } = baseResult.props[0];
    const {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);
    }
    if (keyModifiers.length && (
    // if event name is dynamic, always wrap with keys guard
    !isStaticExp(key) || isKeyboardEvent(key.content))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(shared_esm_bundler/* capitalize */.kC).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context) => {
  const {
    exp,
    loc
  } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(61, loc));
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
const transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === compiler_dom_esm_bundler_TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(createDOMCompilerError(62, {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ""
          }));
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p of child.props) {
            if (p.type === 7 && p.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                value: void 0,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(c => c.type !== 3 && !(c.type === 2 && !c.content.trim()));
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
     false && 0;
    context.removeNode();
  }
};
const DOMNodeTransforms = [transformStyle, ...( false ? 0 : [])];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: compiler_dom_esm_bundler_transformModel,
  // override compiler-core
  on: compiler_dom_esm_bundler_transformOn,
  // override compiler-core
  show: transformShow
};
function compiler_dom_esm_bundler_compile(template, options = {}) {
  return baseCompile(template, (0,shared_esm_bundler/* extend */.l7)({}, parserOptions, options, {
    nodeTransforms: [
    // ignore <script> and <tag>
    // this is not put inside DOMNodeTransforms because that list is used
    // by compiler-ssr to generate vnode fallback branches
    ignoreSideEffectTags, ...DOMNodeTransforms, ...(options.nodeTransforms || [])],
    directiveTransforms: (0,shared_esm_bundler/* extend */.l7)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}

;// CONCATENATED MODULE: ./node_modules/vue/dist/vue.esm-bundler.js





function initDev() {
  {
    initCustomFormatter();
  }
}
if (false) {}
const compileCache = /* @__PURE__ */Object.create(null);
function compileToFunction(template, options) {
  if (!(0,shared_esm_bundler/* isString */.HD)(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       false && 0;
      return shared_esm_bundler/* NOOP */.dG;
    }
  }
  const key = template;
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    if (false) {}
    template = el ? el.innerHTML : ``;
  }
  const opts = (0,shared_esm_bundler/* extend */.l7)({
    hoistStatic: true,
    onError:  false ? 0 : void 0,
    onWarn:  false ? 0 : shared_esm_bundler/* NOOP */.dG
  }, options);
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = tag => !!customElements.get(tag);
  }
  const {
    code
  } = compiler_dom_esm_bundler_compile(template, opts);
  function onError(err, asWarning = false) {
    const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
    const codeFrame = err.loc && (0,shared_esm_bundler/* generateCodeFrame */.Kp)(template, err.loc.start.offset, err.loc.end.offset);
    runtime_core_esm_bundler_warn(codeFrame ? `${message}
${codeFrame}` : message);
  }
  const render = new Function("Vue", code)(runtime_dom_esm_bundler_namespaceObject);
  render._rc = true;
  return compileCache[key] = render;
}
registerRuntimeCompiler(compileToFunction);


/***/ }),

/***/ 6385:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  hX: function() { return /* reexport */ AgChart; }
});

// UNUSED EXPORTS: Marker, VERSION, _ModuleSupport, _Scale, _Scene, _Theme, _Util, __FORCE_MODULE_DETECTION, time

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(7658);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/interval.mjs

/**
 * The interval methods don't mutate Date parameters.
 */
class TimeInterval {
  constructor(encode, decode, rangeCallback) {
    this._encode = encode;
    this._decode = decode;
    this._rangeCallback = rangeCallback;
  }
  /**
   * Returns a new date representing the latest interval boundary date before or equal to date.
   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.
   * @param date
   */
  floor(date) {
    const d = new Date(date);
    const e = this._encode(d);
    return this._decode(e);
  }
  /**
   * Returns a new date representing the earliest interval boundary date after or equal to date.
   * @param date
   */
  ceil(date) {
    const d = new Date(Number(date) - 1);
    const e = this._encode(d);
    return this._decode(e + 1);
  }
  /**
   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).
   * @param start Range start.
   * @param stop Range end.
   * @param extend If specified, the requested range will be extended to the closest "nice" values.
   */
  range(start, stop, extend) {
    var _a;
    const rangeCallback = (_a = this._rangeCallback) === null || _a === void 0 ? void 0 : _a.call(this, start, stop);
    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));
    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));
    if (e1 < e0) {
      return [];
    }
    const range = [];
    for (let e = e0; e <= e1; e++) {
      const d = this._decode(e);
      range.push(d);
    }
    rangeCallback === null || rangeCallback === void 0 ? void 0 : rangeCallback();
    return range;
  }
}
class CountableTimeInterval extends TimeInterval {
  getOffset(snapTo, step) {
    const s = typeof snapTo === 'number' || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;
    return Math.floor(s) % step;
  }
  /**
   * Returns a filtered view of this interval representing every step'th date.
   * It can be a number of minutes, hours, days etc.
   * Must be a positive integer.
   * @param step
   */
  every(step, options) {
    let offset = 0;
    let rangeCallback;
    const {
      snapTo = 'start'
    } = options !== null && options !== void 0 ? options : {};
    if (typeof snapTo === 'string') {
      const initialOffset = offset;
      rangeCallback = (start, stop) => {
        const s = snapTo === 'start' ? start : stop;
        offset = this.getOffset(s, step);
        return () => offset = initialOffset;
      };
    } else if (typeof snapTo === 'number') {
      offset = this.getOffset(new Date(snapTo), step);
    } else if (snapTo instanceof Date) {
      offset = this.getOffset(snapTo, step);
    }
    const encode = date => {
      const e = this._encode(date);
      return Math.floor((e - offset) / step);
    };
    const decode = encoded => {
      return this._decode(encoded * step + offset);
    };
    const interval = new TimeInterval(encode, decode, rangeCallback);
    return interval;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/millisecond.mjs

function encode(date) {
  return date.getTime();
}
function decode(encoded) {
  return new Date(encoded);
}
const millisecond = new CountableTimeInterval(encode, decode);
/* harmony default export */ var time_millisecond = (millisecond);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/duration.mjs
// Common time unit sizes in milliseconds.
const epochYear = new Date(0).getFullYear();
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/second.mjs


const offset = new Date().getTimezoneOffset() * durationMinute;
function second_encode(date) {
  return Math.floor((date.getTime() - offset) / durationSecond);
}
function second_decode(encoded) {
  return new Date(offset + encoded * durationSecond);
}
const second = new CountableTimeInterval(second_encode, second_decode);
/* harmony default export */ var time_second = (second);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/minute.mjs


const minute_offset = new Date().getTimezoneOffset() * durationMinute;
function minute_encode(date) {
  return Math.floor((date.getTime() - minute_offset) / durationMinute);
}
function minute_decode(encoded) {
  return new Date(minute_offset + encoded * durationMinute);
}
const minute = new CountableTimeInterval(minute_encode, minute_decode);
/* harmony default export */ var time_minute = (minute);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/hour.mjs


const hour_offset = new Date().getTimezoneOffset() * durationMinute;
function hour_encode(date) {
  return Math.floor((date.getTime() - hour_offset) / durationHour);
}
function hour_decode(encoded) {
  return new Date(hour_offset + encoded * durationHour);
}
const hour = new CountableTimeInterval(hour_encode, hour_decode);
/* harmony default export */ var time_hour = (hour);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/day.mjs


function day_encode(date) {
  const utc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
  return Math.floor(utc / durationDay);
}
function day_decode(encoded) {
  const d = new Date(0);
  d.setDate(d.getDate() + encoded);
  d.setHours(0, 0, 0, 0);
  return d;
}
const day = new CountableTimeInterval(day_encode, day_decode);
/* harmony default export */ var time_day = (day);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/week.mjs


const baseSunday = new Date(2023, 0, 1);
// Set date to n-th day of the week.
function weekday(n) {
  // Use UTC for weeks calculation to get into account time zone shifts
  const base = Date.UTC(baseSunday.getFullYear(), baseSunday.getMonth(), baseSunday.getDate()) + n * durationDay;
  function encode(date) {
    const utc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
    return Math.floor((utc - base) / durationWeek);
  }
  function decode(encoded) {
    const d = new Date(base);
    d.setDate(d.getDate() + encoded * 7);
    return d;
  }
  return new CountableTimeInterval(encode, decode);
}
const sunday = weekday(0);
const monday = weekday(1);
const tuesday = weekday(2);
const wednesday = weekday(3);
const thursday = weekday(4);
const friday = weekday(5);
const saturday = weekday(6);
/* harmony default export */ var week = (sunday);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/month.mjs

function month_encode(date) {
  return date.getFullYear() * 12 + date.getMonth();
}
function month_decode(encoded) {
  const year = Math.floor(encoded / 12);
  const month = encoded - year * 12;
  return new Date(year, month, 1);
}
const month = new CountableTimeInterval(month_encode, month_decode);
/* harmony default export */ var time_month = (month);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/year.mjs

function year_encode(date) {
  return date.getFullYear();
}
function year_decode(encoded) {
  // Note: assigning years through the constructor
  // will break for years 0 - 99 AD (will turn 1900's).
  const d = new Date();
  d.setFullYear(encoded);
  d.setMonth(0, 1);
  d.setHours(0, 0, 0, 0);
  return d;
}
const year = new CountableTimeInterval(year_encode, year_decode);
/* harmony default export */ var time_year = (year);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/utcMinute.mjs


function utcMinute_encode(date) {
  return Math.floor(date.getTime() / durationMinute);
}
function utcMinute_decode(encoded) {
  return new Date(encoded * durationMinute);
}
const utcMinute = new CountableTimeInterval(utcMinute_encode, utcMinute_decode);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/utcHour.mjs


function utcHour_encode(date) {
  return Math.floor(date.getTime() / durationHour);
}
function utcHour_decode(encoded) {
  return new Date(encoded * durationHour);
}
const utcHour = new CountableTimeInterval(utcHour_encode, utcHour_decode);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/utcDay.mjs


function utcDay_encode(date) {
  return Math.floor(date.getTime() / durationDay);
}
function utcDay_decode(encoded) {
  const d = new Date(0);
  d.setUTCDate(d.getUTCDate() + encoded);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
const utcDay = new CountableTimeInterval(utcDay_encode, utcDay_decode);
/* harmony default export */ var time_utcDay = ((/* unused pure expression or super */ null && (utcDay)));
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/utcMonth.mjs

function utcMonth_encode(date) {
  return date.getUTCFullYear() * 12 + date.getUTCMonth();
}
function utcMonth_decode(encoded) {
  const year = Math.floor(encoded / 12);
  const month = encoded - year * 12;
  return new Date(Date.UTC(year, month, 1));
}
const utcMonth = new CountableTimeInterval(utcMonth_encode, utcMonth_decode);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/utcYear.mjs

function utcYear_encode(date) {
  return date.getUTCFullYear();
}
function utcYear_decode(encoded) {
  // Note: assigning years through the constructor
  // will break for years 0 - 99 AD (will turn 1900's).
  const d = new Date();
  d.setUTCFullYear(encoded);
  d.setUTCMonth(0, 1);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
const utcYear = new CountableTimeInterval(utcYear_encode, utcYear_decode);
/* harmony default export */ var time_utcYear = ((/* unused pure expression or super */ null && (utcYear)));
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/time/index.mjs













;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/userAgent.mjs
const MOBILE = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];
function isDesktop() {
  const userAgent = navigator.userAgent;
  if (MOBILE.some(r => r.test(userAgent))) {
    return false;
  }
  return true;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/canvas/hdpiCanvas.mjs

/**
 * Wraps the native Canvas element and overrides its CanvasRenderingContext2D to
 * provide resolution independent rendering based on `window.devicePixelRatio`.
 */
class HdpiCanvas {
  // The width/height attributes of the Canvas element default to
  // 300/150 according to w3.org.
  constructor({
    document = window.document,
    width = 600,
    height = 300,
    domLayer = false,
    zIndex = 0,
    name = undefined,
    overrideDevicePixelRatio = undefined
  }) {
    this._container = undefined;
    this._enabled = true;
    // `NaN` is deliberate here, so that overrides are always applied
    // and the `resetTransform` inside the `resize` method works in IE11.
    this._pixelRatio = NaN;
    this._width = 0;
    this._height = 0;
    this.document = document;
    // Create canvas and immediately apply width + height to avoid out-of-memory
    // errors on iOS/iPadOS Safari.
    this.element = document.createElement('canvas');
    this.element.width = width;
    this.element.height = height;
    this.context = this.element.getContext('2d');
    this.imageSource = this.context.canvas;
    const {
      style
    } = this.element;
    style.userSelect = 'none';
    style.display = 'block';
    if (domLayer) {
      style.position = 'absolute';
      style.zIndex = String(zIndex);
      style.top = '0';
      style.left = '0';
      style.pointerEvents = 'none';
      style.opacity = `1`;
      if (name) {
        this.element.id = name;
      }
    }
    this.setPixelRatio(overrideDevicePixelRatio);
    this.resize(width, height);
  }
  set container(value) {
    if (this._container !== value) {
      this.remove();
      if (value) {
        value.appendChild(this.element);
      }
      this._container = value;
    }
  }
  get container() {
    return this._container;
  }
  set enabled(value) {
    this.element.style.display = value ? 'block' : 'none';
    this._enabled = !!value;
  }
  get enabled() {
    return this._enabled;
  }
  remove() {
    const {
      parentNode
    } = this.element;
    if (parentNode != null) {
      parentNode.removeChild(this.element);
    }
  }
  destroy() {
    this.element.remove();
    // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.
    // See https://bugs.webkit.org/show_bug.cgi?id=195325.
    this.element.width = 0;
    this.element.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    Object.freeze(this);
  }
  snapshot() {
    // No-op for compatibility with HdpiOffscreenCanvas.
  }
  clear() {
    this.context.save();
    this.context.resetTransform();
    this.context.clearRect(0, 0, this.width, this.height);
    this.context.restore();
  }
  toImage() {
    const img = this.document.createElement('img');
    img.src = this.getDataURL();
    return img;
  }
  getDataURL(type) {
    return this.element.toDataURL(type);
  }
  /**
   * @param fileName The name of the downloaded file.
   * @param fileFormat The file format, the default is `image/png`
   */
  download(fileName, fileFormat = 'image/png') {
    fileName = (fileName !== null && fileName !== void 0 ? fileName : '').trim() || 'image';
    const dataUrl = this.getDataURL(fileFormat);
    const document = this.document;
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = fileName;
    a.style.display = 'none';
    document.body.appendChild(a); // required for the `click` to work in Firefox
    a.click();
    document.body.removeChild(a);
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Changes the pixel ratio of the Canvas element to the given value,
   * or uses the window.devicePixelRatio (default), then resizes the Canvas
   * element accordingly (default).
   */
  setPixelRatio(ratio) {
    let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : window.devicePixelRatio;
    if (!isDesktop()) {
      // Mobile browsers have stricter memory limits, we reduce rendering resolution to
      // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they
      // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.
      pixelRatio = 1;
    }
    HdpiCanvas.overrideScale(this.context, pixelRatio);
    this._pixelRatio = pixelRatio;
  }
  set pixelated(value) {
    this.element.style.imageRendering = value ? 'pixelated' : 'auto';
  }
  get pixelated() {
    return this.element.style.imageRendering === 'pixelated';
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  resize(width, height) {
    if (!(width > 0 && height > 0)) {
      return;
    }
    const {
      element,
      context,
      pixelRatio
    } = this;
    element.width = Math.round(width * pixelRatio);
    element.height = Math.round(height * pixelRatio);
    element.style.width = width + 'px';
    element.style.height = height + 'px';
    context.resetTransform();
    this._width = width;
    this._height = height;
  }
  static get textMeasuringContext() {
    if (this._textMeasuringContext) {
      return this._textMeasuringContext;
    }
    const canvas = document.createElement('canvas');
    this._textMeasuringContext = canvas.getContext('2d');
    return this._textMeasuringContext;
  }
  static get svgText() {
    if (this._svgText) {
      return this._svgText;
    }
    const xmlns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(xmlns, 'svg');
    svg.setAttribute('width', '100');
    svg.setAttribute('height', '100');
    // Add a descriptive class name in case someone sees this SVG element
    // in devtools and wonders about its purpose:
    if (svg.classList) {
      svg.classList.add('text-measuring-svg');
    } else {
      svg.setAttribute('class', 'text-measuring-svg');
    }
    svg.style.position = 'absolute';
    svg.style.top = '-1000px';
    svg.style.visibility = 'hidden';
    const svgText = document.createElementNS(xmlns, 'text');
    svgText.setAttribute('x', '0');
    svgText.setAttribute('y', '30');
    svgText.setAttribute('text', 'black');
    svg.appendChild(svgText);
    document.body.appendChild(svg);
    this._svgText = svgText;
    return svgText;
  }
  static get has() {
    if (this._has) {
      return this._has;
    }
    const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
    const isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
    const isSafari = !isChrome && navigator.userAgent.indexOf('Safari') > -1;
    this._has = Object.freeze({
      textMetrics: this.textMeasuringContext.measureText('test').actualBoundingBoxDescent !== undefined &&
      // Firefox implemented advanced TextMetrics object in v74:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584
      // but it's buggy, so we'll keep using the SVG for text measurement in Firefox for now.
      !isFirefox && !isSafari,
      getTransform: this.textMeasuringContext.getTransform !== undefined
    });
    return this._has;
  }
  static measureText(text, font, textBaseline, textAlign) {
    const ctx = this.textMeasuringContext;
    ctx.font = font;
    ctx.textBaseline = textBaseline;
    ctx.textAlign = textAlign;
    return ctx.measureText(text);
  }
  /**
   * Returns the width and height of the measured text.
   * @param text The single-line text to measure.
   * @param font The font shorthand string.
   */
  static getTextSize(text, font) {
    if (this.has.textMetrics) {
      const ctx = this.textMeasuringContext;
      ctx.font = font;
      const metrics = ctx.measureText(text);
      return {
        width: metrics.width,
        height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
      };
    } else {
      return this.measureSvgText(text, font);
    }
  }
  static measureSvgText(text, font) {
    const cache = this.textSizeCache;
    const fontCache = cache[font];
    // Note: consider not caching the size of numeric strings.
    // For example: if (isNaN(+text)) { // skip
    if (fontCache) {
      const size = fontCache[text];
      if (size) {
        return size;
      }
    } else {
      cache[font] = {};
    }
    const svgText = this.svgText;
    svgText.style.font = font;
    svgText.textContent = text;
    // `getBBox` returns an instance of `SVGRect` with the same `width` and `height`
    // measurements as `DOMRect` instance returned by the `getBoundingClientRect`.
    // But the `SVGRect` instance has half the properties of the `DOMRect`,
    // so we use the `getBBox` method.
    const bbox = svgText.getBBox();
    const size = {
      width: bbox.width,
      height: bbox.height
    };
    cache[font][text] = size;
    return size;
  }
  static overrideScale(ctx, scale) {
    let depth = 0;
    const overrides = {
      save() {
        this.$save();
        depth++;
      },
      restore() {
        if (depth > 0) {
          this.$restore();
          depth--;
        } else {
          throw new Error('AG Charts - Unable to restore() past depth 0');
        }
      },
      setTransform(a, b, c, d, e, f) {
        if (typeof a === 'object') {
          this.$setTransform(a);
        } else {
          this.$setTransform(a * scale, b * scale, c * scale, d * scale, e * scale, f * scale);
        }
      },
      resetTransform() {
        // As of Jan 8, 2019, `resetTransform` is still an "experimental technology",
        // and doesn't work in IE11 and Edge 44.
        this.$setTransform(scale, 0, 0, scale, 0, 0);
      },
      verifyDepthZero() {
        if (depth !== 0) {
          throw new Error('AG Charts - Save/restore depth is non-zero: ' + depth);
        }
      }
    };
    for (const name in overrides) {
      if (Object.prototype.hasOwnProperty.call(overrides, name)) {
        // Save native methods under prefixed names,
        // if this hasn't been done by the previous overrides already.
        if (!ctx['$' + name]) {
          ctx['$' + name] = ctx[name];
        }
        // Replace native methods with overrides,
        // or previous overrides with the new ones.
        ctx[name] = overrides[name];
      }
    }
  }
}
HdpiCanvas.textSizeCache = {};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/bbox.mjs
// For small data structs like a bounding box, objects are superior to arrays
// in terms of performance (by 3-4% in Chrome 71, Safari 12 and by 20% in Firefox 64).
// They are also self descriptive and harder to abuse.
// For example, one has to do:
// `ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);`
// rather than become enticed by the much slower:
// `ctx.strokeRect(...bbox);`
// https://jsperf.com/array-vs-object-create-access
class BBox {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  clone() {
    const {
      x,
      y,
      width,
      height
    } = this;
    return new BBox(x, y, width, height);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  }
  containsPoint(x, y) {
    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
  }
  collidesBBox(other) {
    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
  }
  isInfinite() {
    return Math.abs(this.x) === Infinity || Math.abs(this.y) === Infinity || Math.abs(this.width) === Infinity || Math.abs(this.height) === Infinity;
  }
  shrink(amount, position) {
    const apply = (pos, amt) => {
      switch (pos) {
        case 'top':
          this.y += amt;
        // eslint-disable-next-line no-fallthrough
        case 'bottom':
          this.height -= amt;
          break;
        case 'left':
          this.x += amt;
        // eslint-disable-next-line no-fallthrough
        case 'right':
          this.width -= amt;
          break;
        case 'vertical':
          this.y += amt;
          this.height -= amt * 2;
          break;
        case 'horizontal':
          this.x += amt;
          this.width -= amt * 2;
          break;
        default:
          this.x += amt;
          this.width -= amt * 2;
          this.y += amt;
          this.height -= amt * 2;
      }
    };
    if (typeof amount === 'number') {
      apply(position, amount);
    } else {
      Object.entries(amount).forEach(([pos, amt]) => apply(pos, amt));
    }
    return this;
  }
  grow(amount, position) {
    if (typeof amount === 'number') {
      this.shrink(-amount, position);
    } else {
      const paddingCopy = Object.assign({}, amount);
      for (const key in paddingCopy) {
        paddingCopy[key] *= -1;
      }
      this.shrink(paddingCopy);
    }
    return this;
  }
  static merge(boxes) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    boxes.forEach(box => {
      if (box.x < left) {
        left = box.x;
      }
      if (box.y < top) {
        top = box.y;
      }
      if (box.x + box.width > right) {
        right = box.x + box.width;
      }
      if (box.y + box.height > bottom) {
        bottom = box.y + box.height;
      }
    });
    return new BBox(left, top, right - left, bottom - top);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/matrix.mjs

/**
 * As of Jan 8, 2019, Firefox still doesn't implement
 * `getTransform(): DOMMatrix;`
 * `setTransform(transform?: DOMMatrix2DInit)`
 * in the `CanvasRenderingContext2D`.
 * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150
 * IE11 and Edge 44 also don't have the support.
 * Thus this class, to keep track of the current transform and
 * combine transformations.
 * Standards:
 * https://html.spec.whatwg.org/dev/canvas.html
 * https://www.w3.org/TR/geometry-1/
 */
class Matrix {
  constructor(elements = [1, 0, 0, 1, 0, 0]) {
    this.elements = elements;
  }
  get e() {
    return [...this.elements];
  }
  setElements(elements) {
    const e = this.elements;
    // `this.elements = elements.slice()` is 4-5 times slower
    // (in Chrome 71 and FF 64) than manually copying elements,
    // since slicing allocates new memory.
    // The performance of passing parameters individually
    // vs as an array is about the same in both browsers, so we
    // go with a single (array of elements) parameter, because
    // `setElements(elements)` and `setElements([a, b, c, d, e, f])`
    // calls give us roughly the same performance, versus
    // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,
    // where the spread operator causes a 20-30x performance drop
    // (30x when compiled to ES5's `.apply(this, elements)`
    //  20x when used natively).
    e[0] = elements[0];
    e[1] = elements[1];
    e[2] = elements[2];
    e[3] = elements[3];
    e[4] = elements[4];
    e[5] = elements[5];
    return this;
  }
  get identity() {
    const e = this.elements;
    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;
  }
  /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */
  AxB(A, B, C) {
    const a = A[0] * B[0] + A[2] * B[1],
      b = A[1] * B[0] + A[3] * B[1],
      c = A[0] * B[2] + A[2] * B[3],
      d = A[1] * B[2] + A[3] * B[3],
      e = A[0] * B[4] + A[2] * B[5] + A[4],
      f = A[1] * B[4] + A[3] * B[5] + A[5];
    C = C !== null && C !== void 0 ? C : A;
    C[0] = a;
    C[1] = b;
    C[2] = c;
    C[3] = d;
    C[4] = e;
    C[5] = f;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */
  multiplySelf(other) {
    this.AxB(this.elements, other.elements);
    return this;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */
  multiply(other) {
    const elements = new Array(6);
    this.AxB(this.elements, other.elements, elements);
    return new Matrix(elements);
  }
  preMultiplySelf(other) {
    this.AxB(other.elements, this.elements, this.elements);
    return this;
  }
  /**
   * Returns the inverse of this matrix as a new matrix.
   */
  inverse() {
    const el = this.elements;
    let a = el[0],
      b = el[1],
      c = el[2],
      d = el[3];
    const e = el[4],
      f = el[5];
    const rD = 1 / (a * d - b * c); // reciprocal of determinant
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
  }
  /**
   * Save the inverse of this matrix to the given matrix.
   */
  inverseTo(other) {
    const el = this.elements;
    let a = el[0],
      b = el[1],
      c = el[2],
      d = el[3];
    const e = el[4],
      f = el[5];
    const rD = 1 / (a * d - b * c); // reciprocal of determinant
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);
    return this;
  }
  invertSelf() {
    const el = this.elements;
    let a = el[0],
      b = el[1],
      c = el[2],
      d = el[3];
    const e = el[4],
      f = el[5];
    const rD = 1 / (a * d - b * c); // reciprocal of determinant
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    el[0] = d;
    el[1] = -b;
    el[2] = -c;
    el[3] = a;
    el[4] = c * f - d * e;
    el[5] = b * e - a * f;
    return this;
  }
  transformPoint(x, y) {
    const e = this.elements;
    return {
      x: x * e[0] + y * e[2] + e[4],
      y: x * e[1] + y * e[3] + e[5]
    };
  }
  transformBBox(bbox, target) {
    const elements = this.elements;
    const xx = elements[0];
    const xy = elements[1];
    const yx = elements[2];
    const yy = elements[3];
    const h_w = bbox.width * 0.5;
    const h_h = bbox.height * 0.5;
    const cx = bbox.x + h_w;
    const cy = bbox.y + h_h;
    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
    if (!target) {
      target = new BBox(0, 0, 0, 0);
    }
    target.x = cx * xx + cy * yx + elements[4] - w;
    target.y = cx * xy + cy * yy + elements[5] - h;
    target.width = w + w;
    target.height = h + h;
    return target;
  }
  toContext(ctx) {
    // It's fair to say that matrix multiplications are not cheap.
    // However, updating path definitions on every frame isn't either, so
    // it may be cheaper to just translate paths. It's also fair to
    // say, that most paths will have to be re-rendered anyway, say
    // rectangle paths in a bar chart, where an animation would happen when
    // the data set changes and existing bars are morphed into new ones.
    // Or a pie chart, where old sectors are also morphed into new ones.
    // Same for the line chart. The only plausible case where translating
    // existing paths would be enough, is the scatter chart, where marker
    // icons, typically circles, stay the same size. But if circle radii
    // are bound to some data points, even circle paths would have to be
    // updated. And thus it makes sense to optimize for fewer matrix
    // transforms, where transform matrices of paths are mostly identity
    // matrices and `x`/`y`, `centerX`/`centerY` and similar properties
    // are used to define a path at specific coordinates. And only groups
    // are used to collectively apply a transform to a set of nodes.
    // If the matrix is mostly identity (95% of the time),
    // the `if (this.isIdentity)` check can make this call 3-4 times
    // faster on average: https://jsperf.com/matrix-check-first-vs-always-set
    if (this.identity) {
      return;
    }
    const e = this.elements;
    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
  static flyweight(sourceMatrix) {
    return Matrix.instance.setElements(sourceMatrix.elements);
  }
  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
    // Assume that centers of scaling and rotation are at the origin.
    const [bbcx, bbcy] = [0, 0];
    const sx = scalingX;
    const sy = scalingY;
    let scx;
    let scy;
    if (sx === 1 && sy === 1) {
      scx = 0;
      scy = 0;
    } else {
      scx = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.scalingCenterX;
      scy = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.scalingCenterY;
    }
    const r = rotation;
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    let rcx;
    let rcy;
    if (r === 0) {
      rcx = 0;
      rcy = 0;
    } else {
      rcx = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.rotationCenterX;
      rcy = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.rotationCenterY;
    }
    const tx = translationX;
    const ty = translationY;
    // The transform matrix `M` is a result of the following transformations:
    // 1) translate the center of scaling to the origin
    // 2) scale
    // 3) translate back
    // 4) translate the center of rotation to the origin
    // 5) rotate
    // 6) translate back
    // 7) translate
    //         (7)          (6)             (5)             (4)           (3)           (2)           (1)
    //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |
    // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |
    //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |
    // Translation after steps 1-4 above:
    const tx4 = scx * (1 - sx) - rcx;
    const ty4 = scy * (1 - sy) - rcy;
    matrix.setElements([cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx4 - sin * ty4 + rcx + tx, sin * tx4 + cos * ty4 + rcy + ty]);
    return matrix;
  }
  static fromContext(ctx) {
    const domMatrix = ctx.getTransform();
    return new Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);
  }
}
Matrix.instance = new Matrix();
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/id.mjs
const ID_MAP = {};
function resetIds() {
  for (const key in ID_MAP) {
    delete ID_MAP[key];
  }
}
function createId(instance) {
  var _a;
  const constructor = instance.constructor;
  const className = Object.prototype.hasOwnProperty.call(constructor, 'className') ? constructor.className : constructor.name;
  if (!className) {
    throw new Error(`The ${constructor} is missing the 'className' property.`);
  }
  const nextId = ((_a = ID_MAP[className]) !== null && _a !== void 0 ? _a : 0) + 1;
  ID_MAP[className] = nextId;
  return className + '-' + nextId;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/changeDetectable.mjs
var RedrawType;
(function (RedrawType) {
  RedrawType[RedrawType["NONE"] = 0] = "NONE";
  // Canvas doesn't need clearing, an incremental re-rerender is sufficient.
  RedrawType[RedrawType["TRIVIAL"] = 1] = "TRIVIAL";
  // Group needs clearing, a semi-incremental re-render is sufficient.
  RedrawType[RedrawType["MINOR"] = 2] = "MINOR";
  // Canvas needs to be cleared for these redraw types.
  RedrawType[RedrawType["MAJOR"] = 3] = "MAJOR";
})(RedrawType || (RedrawType = {}));
/** @returns true if new Function() is disabled in the current execution context. */
function functionConstructorAvailable() {
  try {
    new Function('return true');
    return true;
  } catch (e) {
    return false;
  }
}
const STRING_FUNCTION_USEABLE = functionConstructorAvailable();
function SceneChangeDetection(opts) {
  const {
    changeCb,
    convertor
  } = opts !== null && opts !== void 0 ? opts : {};
  return function (target, key) {
    // `target` is either a constructor (static member) or prototype (instance member)
    const privateKey = `__${key}`;
    if (target[key]) {
      return;
    }
    if (STRING_FUNCTION_USEABLE && changeCb == null && convertor == null) {
      prepareFastGetSet(target, key, privateKey, opts);
    } else {
      prepareSlowGetSet(target, key, privateKey, opts);
    }
  };
}
function prepareFastGetSet(target, key, privateKey, opts) {
  const {
    redraw = RedrawType.TRIVIAL,
    type = 'normal',
    checkDirtyOnAssignment = false
  } = opts !== null && opts !== void 0 ? opts : {};
  // Optimised code-path.
  // Remove all conditional logic from runtime - generate a setter with the exact necessary
  // steps, as these setters are called a LOT during update cycles.
  const setterJs = new Function('value', `
        const oldValue = this.${privateKey};
        if (value !== oldValue) {
            this.${privateKey} = value;
            ${type === 'normal' ? `this.markDirty(this, ${redraw});` : ''}
            ${type === 'transform' ? `this.markDirtyTransform(${redraw});` : ''}
            ${type === 'path' ? `if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, ${redraw}); }` : ''}
            ${type === 'font' ? `if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, ${redraw}); }` : ''}
        }
        ${checkDirtyOnAssignment ? `if (value != null && value._dirty > ${RedrawType.NONE}) { this.markDirty(value, value._dirty); }` : ''}
`);
  const getterJs = new Function(`return this.${privateKey};`);
  Object.defineProperty(target, key, {
    set: setterJs,
    get: getterJs,
    enumerable: true,
    configurable: true
  });
}
function prepareSlowGetSet(target, key, privateKey, opts) {
  const {
    redraw = RedrawType.TRIVIAL,
    type = 'normal',
    changeCb,
    convertor,
    checkDirtyOnAssignment = false
  } = opts !== null && opts !== void 0 ? opts : {};
  // Unoptimised but 'safe' code-path, for environments with CSP headers and no 'unsafe-eval'.
  // We deliberately do not support debug branches found in the optimised path above, since
  // for large data-set series performance deteriorates with every extra branch here.
  const setter = function (value) {
    const oldValue = this[privateKey];
    value = convertor ? convertor(value) : value;
    if (value !== oldValue) {
      this[privateKey] = value;
      if (type === 'normal') this.markDirty(this, redraw);
      if (type === 'transform') this.markDirtyTransform(redraw);
      if (type === 'path' && !this._dirtyPath) {
        this._dirtyPath = true;
        this.markDirty(this, redraw);
      }
      if (type === 'font' && !this._dirtyFont) {
        this._dirtyFont = true;
        this.markDirty(this, redraw);
      }
      if (changeCb) changeCb(this);
    }
    if (checkDirtyOnAssignment && value != null && value._dirty > RedrawType.NONE) this.markDirty(value, value._dirty);
  };
  const getter = function () {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
class ChangeDetectable {
  constructor() {
    this._dirty = RedrawType.MAJOR;
  }
  markDirty(_source, type = RedrawType.TRIVIAL) {
    if (this._dirty > type) {
      return;
    }
    this._dirty = type;
  }
  markClean(_opts) {
    this._dirty = RedrawType.NONE;
  }
  isDirty() {
    return this._dirty > RedrawType.NONE;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/node.mjs

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var PointerEvents;
(function (PointerEvents) {
  PointerEvents[PointerEvents["All"] = 0] = "All";
  PointerEvents[PointerEvents["None"] = 1] = "None";
})(PointerEvents || (PointerEvents = {}));
const zIndexChangedCallback = o => {
  if (o.parent) {
    o.parent.dirtyZIndex = true;
  }
  o.zIndexChanged();
};
/**
 * Abstract scene graph node.
 * Each node can have zero or one parent and belong to zero or one scene.
 */
class Node extends ChangeDetectable {
  constructor() {
    super(...arguments);
    /** Unique number to allow creation order to be easily determined. */
    this.serialNumber = Node._nextSerialNumber++;
    /**
     * Unique node ID in the form `ClassName-NaturalNumber`.
     */
    this.id = createId(this);
    /**
     * Some number to identify this node, typically within a `Group` node.
     * Usually this will be some enum value used as a selector.
     */
    this.tag = NaN;
    /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */
    this.isContainerNode = false;
    this._children = [];
    // Used to check for duplicate nodes.
    this.childSet = {}; // new Set<Node>()
    // These matrices may need to have package level visibility
    // for performance optimization purposes.
    this.matrix = new Matrix();
    this.inverseMatrix = new Matrix();
    this._dirtyTransform = false;
    this.scalingX = 1;
    this.scalingY = 1;
    /**
     * The center of scaling.
     * The default value of `null` means the scaling center will be
     * determined automatically, as the center of the bounding box
     * of a node.
     */
    this.scalingCenterX = null;
    this.scalingCenterY = null;
    this.rotationCenterX = null;
    this.rotationCenterY = null;
    /**
     * Rotation angle in radians.
     * The value is set as is. No normalization to the [-180, 180) or [0, 360)
     * interval is performed.
     */
    this.rotation = 0;
    this.translationX = 0;
    this.translationY = 0;
    this.visible = true;
    this.dirtyZIndex = false;
    this.zIndex = 0;
    /** Discriminators for render order within a zIndex. */
    this.zIndexSubOrder = undefined;
    this.pointerEvents = PointerEvents.All;
  }
  /**
   * Some arbitrary data bound to the node.
   */
  get datum() {
    var _a;
    if (this._datum !== undefined) {
      return this._datum;
    }
    return (_a = this._parent) === null || _a === void 0 ? void 0 : _a.datum;
  }
  set datum(datum) {
    this._datum = datum;
  }
  _setLayerManager(value) {
    this._layerManager = value;
    this._debug = value === null || value === void 0 ? void 0 : value.debug;
    for (const child of this.children) {
      child._setLayerManager(value);
    }
  }
  get layerManager() {
    return this._layerManager;
  }
  get parent() {
    return this._parent;
  }
  get children() {
    return this._children;
  }
  /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */
  append(nodes) {
    // Passing a single parameter to an open-ended version of `append`
    // would be 30-35% slower than this.
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (const node of nodes) {
      if (node.parent) {
        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);
      }
      if (node.layerManager) {
        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);
      }
      if (this.childSet[node.id]) {
        // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.
        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);
      }
      this._children.push(node);
      this.childSet[node.id] = true;
      node._parent = this;
      node._setLayerManager(this.layerManager);
    }
    this.dirtyZIndex = true;
    this.markDirty(this, RedrawType.MAJOR);
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  removeChild(node) {
    if (node.parent === this) {
      const i = this.children.indexOf(node);
      if (i >= 0) {
        this._children.splice(i, 1);
        delete this.childSet[node.id];
        node._parent = undefined;
        node._setLayerManager();
        this.dirtyZIndex = true;
        this.markDirty(node, RedrawType.MAJOR);
        return node;
      }
    }
    throw new Error(`The node to be removed is not a child of this node.`);
  }
  /**
   * Inserts the node `node` before the existing child node `nextNode`.
   * If `nextNode` is null, insert `node` at the end of the list of children.
   * If the `node` belongs to another parent, it is first removed.
   * Returns the `node`.
   * @param node
   * @param nextNode
   */
  insertBefore(node, nextNode) {
    const parent = node.parent;
    if (node.parent) {
      node.parent.removeChild(node);
    }
    if (nextNode && nextNode.parent === this) {
      const i = this.children.indexOf(nextNode);
      if (i >= 0) {
        this._children.splice(i, 0, node);
        this.childSet[node.id] = true;
        node._parent = this;
        node._setLayerManager(this.layerManager);
      } else {
        throw new Error(`${nextNode} has ${parent} as the parent, ` + `but is not in its list of children.`);
      }
      this.dirtyZIndex = true;
      this.markDirty(node, RedrawType.MAJOR);
    } else {
      this.append(node);
    }
    return node;
  }
  calculateCumulativeMatrix() {
    this.computeTransformMatrix();
    const matrix = Matrix.flyweight(this.matrix);
    let parent = this.parent;
    while (parent) {
      parent.computeTransformMatrix();
      matrix.preMultiplySelf(parent.matrix);
      parent = parent.parent;
    }
    return matrix;
  }
  transformPoint(x, y) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.invertSelf().transformPoint(x, y);
  }
  inverseTransformPoint(x, y) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.transformPoint(x, y);
  }
  transformBBox(bbox) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.invertSelf().transformBBox(bbox);
  }
  inverseTransformBBox(bbox) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.transformBBox(bbox);
  }
  markDirtyTransform() {
    this._dirtyTransform = true;
    this.markDirty(this, RedrawType.MAJOR);
  }
  containsPoint(_x, _y) {
    return false;
  }
  /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */
  pickNode(x, y) {
    var _a;
    if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {
      return;
    }
    const children = this.children;
    if (children.length > 1000) {
      // Try to optimise which children to interrogate; BBox calculation is an approximation
      // for more complex shapes, so discarding items based on this will save a lot of
      // processing when the point is nowhere near the child.
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const containsPoint = (_a = child.computeTransformedBBox()) === null || _a === void 0 ? void 0 : _a.containsPoint(x, y);
        const hit = containsPoint ? child.pickNode(x, y) : undefined;
        if (hit) {
          return hit;
        }
      }
    } else if (children.length) {
      // Nodes added later should be hit-tested first,
      // as they are rendered on top of the previously added nodes.
      for (let i = children.length - 1; i >= 0; i--) {
        const hit = children[i].pickNode(x, y);
        if (hit) {
          return hit;
        }
      }
    } else if (!this.isContainerNode) {
      // a leaf node, but not a container leaf
      return this;
    }
  }
  findNodes(predicate) {
    const result = predicate(this) ? [this] : [];
    for (const child of this.children) {
      const childResult = child.findNodes(predicate);
      if (childResult) {
        result.push(...childResult);
      }
    }
    return result;
  }
  computeBBox() {
    return;
  }
  computeTransformedBBox() {
    const bbox = this.computeBBox();
    if (!bbox) {
      return undefined;
    }
    this.computeTransformMatrix();
    const matrix = Matrix.flyweight(this.matrix);
    let parent = this.parent;
    while (parent) {
      parent.computeTransformMatrix();
      matrix.preMultiplySelf(parent.matrix);
      parent = parent.parent;
    }
    matrix.transformBBox(bbox, bbox);
    return bbox;
  }
  computeTransformMatrix() {
    if (!this._dirtyTransform) {
      return;
    }
    const {
      matrix,
      scalingX,
      scalingY,
      rotation,
      translationX,
      translationY,
      scalingCenterX,
      scalingCenterY,
      rotationCenterX,
      rotationCenterY
    } = this;
    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {
      scalingCenterX,
      scalingCenterY,
      rotationCenterX,
      rotationCenterY
    });
    matrix.inverseTo(this.inverseMatrix);
    this._dirtyTransform = false;
  }
  render(renderCtx) {
    const {
      stats
    } = renderCtx;
    this._dirty = RedrawType.NONE;
    if (stats) stats.nodesRendered++;
  }
  clearBBox(ctx) {
    const bbox = this.computeBBox();
    if (bbox == null) {
      return;
    }
    const {
      x,
      y,
      width,
      height
    } = bbox;
    const topLeft = this.transformPoint(x, y);
    const bottomRight = this.transformPoint(x + width, y + height);
    ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
  }
  markDirty(_source, type = RedrawType.TRIVIAL, parentType = type) {
    if (this._dirty > type) {
      return;
    }
    if (this._dirty === type && type === parentType) {
      return;
    }
    this._dirty = type;
    if (this.parent) {
      this.parent.markDirty(this, parentType);
    } else if (this.layerManager) {
      this.layerManager.markDirty();
    }
  }
  get dirty() {
    return this._dirty;
  }
  markClean(opts) {
    const {
      force = false,
      recursive = true
    } = opts !== null && opts !== void 0 ? opts : {};
    if (this._dirty === RedrawType.NONE && !force) {
      return;
    }
    this._dirty = RedrawType.NONE;
    if (recursive) {
      for (const child of this.children) {
        child.markClean();
      }
    }
  }
  visibilityChanged() {
    // Override point for sub-classes to react to visibility changes.
  }
  get nodeCount() {
    let count = 1;
    let dirtyCount = this._dirty >= RedrawType.NONE || this._dirtyTransform ? 1 : 0;
    let visibleCount = this.visible ? 1 : 0;
    for (const child of this._children) {
      const {
        count: childCount,
        visibleCount: childVisibleCount,
        dirtyCount: childDirtyCount
      } = child.nodeCount;
      count += childCount;
      visibleCount += childVisibleCount;
      dirtyCount += childDirtyCount;
    }
    return {
      count,
      visibleCount,
      dirtyCount
    };
  }
  zIndexChanged() {
    // Override point for sub-classes.
  }
}
Node._nextSerialNumber = 0;
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "scalingX", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "scalingY", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "scalingCenterX", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "scalingCenterY", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "rotationCenterX", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "rotationCenterY", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "rotation", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "translationX", void 0);
__decorate([SceneChangeDetection({
  type: 'transform'
})], Node.prototype, "translationY", void 0);
__decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR,
  changeCb: o => o.visibilityChanged()
})], Node.prototype, "visible", void 0);
__decorate([SceneChangeDetection({
  redraw: RedrawType.TRIVIAL,
  changeCb: zIndexChangedCallback
})], Node.prototype, "zIndex", void 0);
__decorate([SceneChangeDetection({
  redraw: RedrawType.TRIVIAL,
  changeCb: zIndexChangedCallback
})], Node.prototype, "zIndexSubOrder", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/compare.mjs
function ascendingStringNumberUndefined(a, b) {
  let diff = 0;
  if (typeof a === 'number' && typeof b === 'number') {
    diff = a - b;
  } else if (typeof a === 'string' && typeof b === 'string') {
    diff = a.localeCompare(b);
  } else if (a == null && b == null) {
    // Equal.
  } else if (a == null) {
    diff = -1;
  } else if (b == null) {
    diff = 1;
  } else {
    diff = String(a).localeCompare(String(b));
  }
  return diff;
}
function compoundAscending(a, b, comparator) {
  const toLiteral = v => {
    if (typeof v === 'function') {
      return v();
    }
    return v;
  };
  for (const idx in a) {
    const diff = comparator(toLiteral(a[idx]), toLiteral(b[idx]));
    if (diff !== 0) {
      return diff;
    }
  }
  return 0;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/function.mjs
const doOnceFlags = {};
/**
 * If the key was passed before, then doesn't execute the func
 */
function doOnce(func, key) {
  if (doOnceFlags[key]) {
    return;
  }
  func();
  doOnceFlags[key] = true;
}
/** Clear doOnce() state (for test purposes). */
function clearDoOnceFlags() {
  for (const key in doOnceFlags) {
    delete doOnceFlags[key];
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/logger.mjs
/* eslint-disable no-console */

const Logger = {
  debug(...logContent) {
    console.log(...logContent);
  },
  warn(message, ...logContent) {
    console.warn(`AG Charts - ${message}`, ...logContent);
  },
  error(message, ...logContent) {
    if (typeof message === 'object') {
      console.error(`AG Charts error`, message, ...logContent);
    } else {
      console.error(`AG Charts - ${message}`, ...logContent);
    }
  },
  warnOnce(message, ...logContent) {
    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);
  },
  errorOnce(message, ...logContent) {
    doOnce(() => Logger.error(message, ...logContent), `Logger.warn: ${message}`);
  }
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/group.mjs
var group_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Group extends Node {
  constructor(opts) {
    var _a;
    super();
    this.opts = opts;
    this.opacity = 1;
    this.lastBBox = undefined;
    const {
      zIndex,
      zIndexSubOrder
    } = opts !== null && opts !== void 0 ? opts : {};
    this.isContainerNode = true;
    if (zIndex !== undefined) {
      this.zIndex = zIndex;
    }
    if (zIndexSubOrder !== undefined) {
      this.zIndexSubOrder = zIndexSubOrder;
    }
    this.name = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.name;
  }
  zIndexChanged() {
    var _a;
    if (this.layer) {
      (_a = this._layerManager) === null || _a === void 0 ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);
    }
  }
  isLayer() {
    return this.layer != null;
  }
  _setLayerManager(scene) {
    var _a, _b;
    if (this._layerManager && this.layer) {
      this._layerManager.removeLayer(this.layer);
      this.layer = undefined;
    }
    if (this.layer) {
      throw new Error('AG Charts - unable to deregister scene rendering layer!');
    }
    super._setLayerManager(scene);
    if (scene && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.layer)) {
      const {
        zIndex,
        zIndexSubOrder,
        name
      } = (_b = this.opts) !== null && _b !== void 0 ? _b : {};
      const getComputedOpacity = () => this.getComputedOpacity();
      const getVisibility = () => this.getVisibility();
      this.layer = scene.addLayer({
        zIndex,
        zIndexSubOrder,
        name,
        getComputedOpacity,
        getVisibility
      });
    }
  }
  getComputedOpacity() {
    let opacity = 1;
    let node = this;
    do {
      if (node instanceof Group) {
        opacity *= node.opacity;
      }
    } while (node = node.parent);
    return opacity;
  }
  getVisibility() {
    let node = this;
    let visible = this.visible;
    while (node = node.parent) {
      if (node.visible) {
        continue;
      }
      visible = node.visible;
    }
    return visible;
  }
  visibilityChanged() {
    if (this.layer) {
      this.layer.enabled = this.visible;
    }
  }
  markDirty(source, type = RedrawType.TRIVIAL) {
    const parentType = type <= RedrawType.MINOR ? RedrawType.TRIVIAL : type;
    super.markDirty(source, type, parentType);
  }
  // We consider a group to be boundless, thus any point belongs to it.
  containsPoint(_x, _y) {
    return true;
  }
  computeBBox() {
    this.computeTransformMatrix();
    return Group.computeBBox(this.children);
  }
  computeTransformedBBox() {
    return this.computeBBox();
  }
  render(renderCtx) {
    var _a, _b;
    const {
      opts: {
        name = undefined
      } = {}
    } = this;
    const {
      _debug: {
        consoleLog = false
      } = {}
    } = this;
    const {
      dirty,
      dirtyZIndex,
      layer,
      children,
      clipRect
    } = this;
    let {
      ctx,
      forceRender,
      clipBBox
    } = renderCtx;
    const {
      resized,
      stats
    } = renderCtx;
    const canvasCtxTransform = ctx.getTransform();
    const isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;
    const isChildDirty = isDirty || children.some(n => n.dirty >= RedrawType.TRIVIAL);
    if (name && consoleLog) {
      Logger.debug({
        name,
        group: this,
        isDirty,
        isChildDirty,
        renderCtx,
        forceRender
      });
    }
    if (layer) {
      // If bounding-box of a layer changes, force re-render.
      const currentBBox = this.computeBBox();
      if (this.lastBBox === undefined || !this.lastBBox.equals(currentBBox)) {
        forceRender = true;
        this.lastBBox = currentBBox;
      } else if (!currentBBox.isInfinite()) {
        // bbox for path2D is currently (Infinity) not calculated
        // If it's not a path2D, turn off forceRender
        // By default there is no need to force redraw a group which has it's own canvas layer
        // as the layer is independent of any other layer
        forceRender = false;
      }
    }
    if (!isDirty && !isChildDirty && !forceRender) {
      if (name && consoleLog && stats) {
        const counts = this.nodeCount;
        Logger.debug({
          name,
          result: 'skipping',
          renderCtx,
          counts,
          group: this
        });
      }
      if (layer && stats) {
        stats.layersSkipped++;
        stats.nodesSkipped += this.nodeCount.count;
      }
      this.markClean({
        recursive: false
      });
      // Nothing to do.
      return;
    }
    const groupVisible = this.visible;
    if (layer) {
      // Switch context to the canvas layer we use for this group.
      ctx = layer.context;
      ctx.save();
      ctx.resetTransform();
      forceRender = true;
      layer.clear();
      if (clipBBox) {
        // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play
        const {
          width,
          height,
          x,
          y
        } = clipBBox;
        if (consoleLog) {
          Logger.debug({
            name,
            clipBBox,
            ctxTransform: ctx.getTransform(),
            renderCtx,
            group: this
          });
        }
        this.clipCtx(ctx, x, y, width, height);
      }
      ctx.setTransform(canvasCtxTransform);
    } else {
      // Only apply opacity if this isn't a distinct layer - opacity will be applied
      // at composition time.
      ctx.globalAlpha *= this.opacity;
    }
    // A group can have `scaling`, `rotation`, `translation` properties
    // that are applied to the canvas context before children are rendered,
    // so all children can be transformed at once.
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    if (clipRect) {
      // clipRect is in the group's coordinate space
      const {
        x,
        y,
        width,
        height
      } = clipRect;
      ctx.save();
      if (consoleLog) {
        Logger.debug({
          name,
          clipRect,
          ctxTransform: ctx.getTransform(),
          renderCtx,
          group: this
        });
      }
      this.clipCtx(ctx, x, y, width, height);
      // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play
      clipBBox = this.matrix.inverse().transformBBox(clipRect);
    }
    if (dirtyZIndex) {
      this.sortChildren();
      forceRender = true;
    }
    // Reduce churn if renderCtx is identical.
    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;
    const childRenderContext = renderContextChanged ? Object.assign(Object.assign({}, renderCtx), {
      ctx,
      forceRender,
      clipBBox
    }) : renderCtx;
    // Render visible children.
    let skipped = 0;
    for (const child of children) {
      if (!child.visible || !groupVisible) {
        // Skip invisible children, but make sure their dirty flag is reset.
        child.markClean();
        if (stats) skipped += child.nodeCount.count;
        continue;
      }
      if (!forceRender && child.dirty === RedrawType.NONE) {
        // Skip children that don't need to be redrawn.
        if (stats) skipped += child.nodeCount.count;
        continue;
      }
      // Render marks this node (and children) as clean - no need to explicitly markClean().
      ctx.save();
      child.render(childRenderContext);
      ctx.restore();
    }
    if (stats) stats.nodesSkipped += skipped;
    // Render marks this node as clean - no need to explicitly markClean().
    super.render(renderCtx);
    if (clipRect) {
      ctx.restore();
    }
    if (layer) {
      if (stats) stats.layersRendered++;
      ctx.restore();
      layer.snapshot();
      // Check for save/restore depth of zero!
      (_b = (_a = layer.context).verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    if (name && consoleLog && stats) {
      const counts = this.nodeCount;
      Logger.debug({
        name,
        result: 'rendered',
        skipped,
        renderCtx,
        counts,
        group: this
      });
    }
  }
  sortChildren() {
    this.dirtyZIndex = false;
    this.children.sort((a, b) => {
      var _a, _b;
      return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.serialNumber], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.serialNumber], ascendingStringNumberUndefined);
    });
  }
  clipCtx(ctx, x, y, width, height) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + width, y);
    ctx.lineTo(x + width, y + height);
    ctx.lineTo(x, y + height);
    ctx.closePath();
    ctx.clip();
  }
  static computeBBox(nodes) {
    let left = Infinity;
    let right = -Infinity;
    let top = Infinity;
    let bottom = -Infinity;
    nodes.forEach(n => {
      if (!n.visible) {
        return;
      }
      const bbox = n.computeTransformedBBox();
      if (!bbox) {
        return;
      }
      const x = bbox.x;
      const y = bbox.y;
      if (x < left) {
        left = x;
      }
      if (y < top) {
        top = y;
      }
      if (x + bbox.width > right) {
        right = x + bbox.width;
      }
      if (y + bbox.height > bottom) {
        bottom = y + bbox.height;
      }
    });
    return new BBox(left, top, right - left, bottom - top);
  }
  /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRectInGroupCoordinateSpace(bbox) {
    this.clipRect = bbox ? this.transformBBox(bbox) : undefined;
  }
}
Group.className = 'Group';
group_decorate([SceneChangeDetection({
  convertor: v => Math.min(1, Math.max(0, v))
})], Group.prototype, "opacity", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/canvas/hdpiOffscreenCanvas.mjs


/**
 * Wraps a native OffscreenCanvas and overrides its OffscreenCanvasRenderingContext2D to
 * provide resolution independent rendering based on `window.devicePixelRatio`.
 */
class HdpiOffscreenCanvas {
  // The width/height attributes of the Canvas element default to
  // 300/150 according to w3.org.
  constructor({
    width = 600,
    height = 300,
    overrideDevicePixelRatio = undefined
  }) {
    this.enabled = true;
    // `NaN` is deliberate here, so that overrides are always applied
    // and the `resetTransform` inside the `resize` method works in IE11.
    this._pixelRatio = NaN;
    this._width = 0;
    this._height = 0;
    this.canvas = new OffscreenCanvas(width, height);
    this.context = this.canvas.getContext('2d');
    this.imageSource = this.canvas.transferToImageBitmap();
    this.setPixelRatio(overrideDevicePixelRatio);
    this.resize(width, height);
  }
  static isSupported() {
    return window['OffscreenCanvas'] != null;
  }
  snapshot() {
    this.imageSource.close();
    this.imageSource = this.canvas.transferToImageBitmap();
  }
  destroy() {
    this.imageSource.close();
    // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.
    // See https://bugs.webkit.org/show_bug.cgi?id=195325.
    this.canvas.width = 0;
    this.canvas.height = 0;
    this.context.clearRect(0, 0, 0, 0);
  }
  clear() {
    this.context.save();
    this.context.resetTransform();
    this.context.clearRect(0, 0, this.width, this.height);
    this.context.restore();
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Changes the pixel ratio of the Canvas element to the given value,
   * or uses the window.devicePixelRatio (default), then resizes the Canvas
   * element accordingly (default).
   */
  setPixelRatio(ratio) {
    let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : window.devicePixelRatio;
    if (!isDesktop()) {
      // Mobile browsers have stricter memory limits, we reduce rendering resolution to
      // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they
      // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.
      pixelRatio = 1;
    }
    HdpiCanvas.overrideScale(this.context, pixelRatio);
    this._pixelRatio = pixelRatio;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  resize(width, height) {
    if (!(width > 0 && height > 0)) {
      return;
    }
    const {
      canvas,
      context,
      pixelRatio
    } = this;
    canvas.width = Math.round(width * pixelRatio);
    canvas.height = Math.round(height * pixelRatio);
    context.resetTransform();
    this._width = width;
    this._height = height;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/window.mjs
function windowValue(name) {
  /**
   * Redeclaration of window that is safe for use with Gatsby server-side (webpack) compilation.
   */
  const WINDOW = typeof window !== 'undefined' ? window :
  // typeof global !== 'undefined' ? (global as any) :
  undefined;
  return WINDOW === null || WINDOW === void 0 ? void 0 : WINDOW[name];
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/scene.mjs

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};








function buildSceneNodeHighlight() {
  var _a;
  let config = (_a = windowValue('agChartsSceneDebug')) !== null && _a !== void 0 ? _a : [];
  if (typeof config === 'string') {
    config = [config];
  }
  const result = [];
  config.forEach(name => {
    if (name === 'layout') {
      result.push('seriesRoot', 'legend', 'root', /.*Axis-\d+-axis.*/);
    } else {
      result.push(name);
    }
  });
  return result;
}
class Scene {
  constructor(opts) {
    var _a, _b, _c;
    this.id = createId(this);
    this.layers = [];
    this._nextZIndex = 0;
    this._nextLayerId = 0;
    this._dirty = false;
    this._root = null;
    this.debug = {
      dirtyTree: false,
      stats: false,
      renderBoundingBoxes: false,
      consoleLog: false,
      sceneNodeHighlight: []
    };
    const {
      document = window.document,
      mode = (_a = windowValue('agChartsSceneRenderModel')) !== null && _a !== void 0 ? _a : 'adv-composite',
      width,
      height,
      overrideDevicePixelRatio = undefined
    } = opts;
    this.overrideDevicePixelRatio = overrideDevicePixelRatio;
    this.opts = {
      document,
      mode
    };
    this.debug.consoleLog = windowValue('agChartsDebug') === true;
    this.debug.stats = (_b = windowValue('agChartsSceneStats')) !== null && _b !== void 0 ? _b : false;
    this.debug.dirtyTree = (_c = windowValue('agChartsSceneDirtyTree')) !== null && _c !== void 0 ? _c : false;
    this.debug.sceneNodeHighlight = buildSceneNodeHighlight();
    this.canvas = new HdpiCanvas({
      document,
      width,
      height,
      overrideDevicePixelRatio
    });
  }
  set container(value) {
    this.canvas.container = value;
  }
  get container() {
    return this.canvas.container;
  }
  download(fileName, fileFormat) {
    this.canvas.download(fileName, fileFormat);
  }
  getDataURL(type) {
    return this.canvas.getDataURL(type);
  }
  get width() {
    return this.pendingSize ? this.pendingSize[0] : this.canvas.width;
  }
  get height() {
    return this.pendingSize ? this.pendingSize[1] : this.canvas.height;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    // HdpiCanvas doesn't allow width/height <= 0.
    const lessThanZero = width <= 0 || height <= 0;
    const nan = isNaN(width) || isNaN(height);
    const unchanged = width === this.width && height === this.height;
    if (unchanged || nan || lessThanZero) {
      return false;
    }
    this.pendingSize = [width, height];
    this.markDirty();
    return true;
  }
  addLayer(opts) {
    var _a;
    const {
      mode
    } = this.opts;
    const layeredModes = ['composite', 'dom-composite', 'adv-composite'];
    if (!layeredModes.includes(mode)) {
      return undefined;
    }
    const {
      zIndex = this._nextZIndex++,
      name,
      zIndexSubOrder,
      getComputedOpacity,
      getVisibility
    } = opts;
    const {
      width,
      height,
      overrideDevicePixelRatio
    } = this;
    const domLayer = mode === 'dom-composite';
    const advLayer = mode === 'adv-composite';
    const canvas = !advLayer || !HdpiOffscreenCanvas.isSupported() ? new HdpiCanvas({
      document: this.opts.document,
      width,
      height,
      domLayer,
      zIndex,
      name,
      overrideDevicePixelRatio
    }) : new HdpiOffscreenCanvas({
      width,
      height,
      overrideDevicePixelRatio
    });
    const newLayer = {
      id: this._nextLayerId++,
      name,
      zIndex,
      zIndexSubOrder,
      canvas,
      getComputedOpacity,
      getVisibility
    };
    if (zIndex >= this._nextZIndex) {
      this._nextZIndex = zIndex + 1;
    }
    this.layers.push(newLayer);
    this.sortLayers();
    if (domLayer) {
      const domCanvases = this.layers.map(v => v.canvas).filter(v => v instanceof HdpiCanvas);
      const newLayerIndex = domCanvases.findIndex(v => v === canvas);
      const lastLayer = (_a = domCanvases[newLayerIndex - 1]) !== null && _a !== void 0 ? _a : this.canvas;
      lastLayer.element.insertAdjacentElement('afterend', canvas.element);
    }
    if (this.debug.consoleLog) {
      Logger.debug({
        layers: this.layers
      });
    }
    return newLayer.canvas;
  }
  removeLayer(canvas) {
    const index = this.layers.findIndex(l => l.canvas === canvas);
    if (index >= 0) {
      this.layers.splice(index, 1);
      canvas.destroy();
      this.markDirty();
      if (this.debug.consoleLog) {
        Logger.debug({
          layers: this.layers
        });
      }
    }
  }
  moveLayer(canvas, newZIndex, newZIndexSubOrder) {
    const layer = this.layers.find(l => l.canvas === canvas);
    if (layer) {
      layer.zIndex = newZIndex;
      layer.zIndexSubOrder = newZIndexSubOrder;
      this.sortLayers();
      this.markDirty();
      if (this.debug.consoleLog) {
        Logger.debug({
          layers: this.layers
        });
      }
    }
  }
  sortLayers() {
    this.layers.sort((a, b) => {
      var _a, _b;
      return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.id], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.id], ascendingStringNumberUndefined);
    });
  }
  markDirty() {
    this._dirty = true;
  }
  get dirty() {
    return this._dirty;
  }
  set root(node) {
    if (node === this._root) {
      return;
    }
    if (this._root) {
      this._root._setLayerManager();
    }
    this._root = node;
    if (node) {
      // If `node` is the root node of another scene ...
      if (node.parent === null && node.layerManager && node.layerManager !== this) {
        node.layerManager.root = null;
      }
      node._setLayerManager(this);
    }
    this.markDirty();
  }
  get root() {
    return this._root;
  }
  /** Alternative to destroy() that preserves re-usable resources. */
  strip() {
    const {
      layers
    } = this;
    for (const layer of layers) {
      layer.canvas.destroy();
      delete layer['canvas'];
    }
    layers.splice(0, layers.length);
    this.root = null;
    this._dirty = false;
    this.canvas.context.resetTransform();
  }
  destroy() {
    this.container = undefined;
    this.strip();
    this.canvas.destroy();
    Object.assign(this, {
      canvas: undefined,
      ctx: undefined
    });
  }
  render(opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const {
        debugSplitTimes = [performance.now()],
        extraDebugStats = {}
      } = opts !== null && opts !== void 0 ? opts : {};
      const {
        canvas,
        canvas: {
          context: ctx
        },
        root,
        layers,
        pendingSize,
        opts: {
          mode
        }
      } = this;
      if (pendingSize) {
        this.canvas.resize(...pendingSize);
        this.layers.forEach(layer => layer.canvas.resize(...pendingSize));
        this.pendingSize = undefined;
      }
      if (root && !root.visible) {
        this._dirty = false;
        return;
      }
      if (root && !this.dirty) {
        if (this.debug.consoleLog) {
          Logger.debug('no-op', {
            redrawType: RedrawType[root.dirty],
            tree: this.buildTree(root)
          });
        }
        this.debugStats(debugSplitTimes, ctx, undefined, extraDebugStats);
        return;
      }
      const renderCtx = {
        ctx,
        forceRender: true,
        resized: !!pendingSize,
        debugNodes: {}
      };
      if (this.debug.stats === 'detailed') {
        renderCtx.stats = {
          layersRendered: 0,
          layersSkipped: 0,
          nodesRendered: 0,
          nodesSkipped: 0
        };
      }
      let canvasCleared = false;
      if (!root || root.dirty >= RedrawType.TRIVIAL) {
        // start with a blank canvas, clear previous drawing
        canvasCleared = true;
        canvas.clear();
      }
      if (root && this.debug.dirtyTree) {
        const {
          dirtyTree,
          paths
        } = this.buildDirtyTree(root);
        Logger.debug({
          dirtyTree,
          paths
        });
      }
      if (root && canvasCleared) {
        if (this.debug.consoleLog) {
          Logger.debug('before', {
            redrawType: RedrawType[root.dirty],
            canvasCleared,
            tree: this.buildTree(root)
          });
        }
        if (root.visible) {
          ctx.save();
          root.render(renderCtx);
          ctx.restore();
        }
      }
      if (mode !== 'dom-composite' && layers.length > 0 && canvasCleared) {
        this.sortLayers();
        ctx.save();
        ctx.setTransform(1 / canvas.pixelRatio, 0, 0, 1 / canvas.pixelRatio, 0, 0);
        layers.forEach(({
          canvas: {
            imageSource,
            enabled
          },
          getComputedOpacity,
          getVisibility
        }) => {
          if (!enabled || !getVisibility()) {
            return;
          }
          ctx.globalAlpha = getComputedOpacity();
          ctx.drawImage(imageSource, 0, 0);
        });
        ctx.restore();
      }
      // Check for save/restore depth of zero!
      (_a = ctx.verifyDepthZero) === null || _a === void 0 ? void 0 : _a.call(ctx);
      this._dirty = false;
      this.debugStats(debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);
      this.debugSceneNodeHighlight(ctx, this.debug.sceneNodeHighlight, renderCtx.debugNodes);
      if (root && this.debug.consoleLog) {
        Logger.debug('after', {
          redrawType: RedrawType[root.dirty],
          canvasCleared,
          tree: this.buildTree(root)
        });
      }
    });
  }
  debugStats(debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {
    const end = performance.now();
    if (this.debug.stats) {
      const start = debugSplitTimes[0];
      debugSplitTimes.push(end);
      const pct = (rendered, skipped) => {
        const total = rendered + skipped;
        return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
      };
      const time = (start, end) => {
        return `${Math.round((end - start) * 100) / 100}ms`;
      };
      const {
        layersRendered = 0,
        layersSkipped = 0,
        nodesRendered = 0,
        nodesSkipped = 0
      } = renderCtxStats !== null && renderCtxStats !== void 0 ? renderCtxStats : {};
      const splits = debugSplitTimes.map((t, i) => i > 0 ? time(debugSplitTimes[i - 1], t) : null).filter(v => v != null).join(' + ');
      const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(' ; ');
      const stats = [`${time(start, end)} (${splits})`, `${extras}`, this.debug.stats === 'detailed' ? `Layers: ${pct(layersRendered, layersSkipped)}` : null, this.debug.stats === 'detailed' ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null].filter(v => v != null);
      const statsSize = stats.map(t => [t, HdpiCanvas.getTextSize(t, ctx.font)]);
      const width = Math.max(...statsSize.map(([, {
        width
      }]) => width));
      const height = statsSize.reduce((total, [, {
        height
      }]) => total + height, 0);
      ctx.save();
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = 'black';
      let y = 0;
      for (const [stat, size] of statsSize) {
        y += size.height;
        ctx.fillText(stat, 2, y);
      }
      ctx.restore();
    }
  }
  debugSceneNodeHighlight(ctx, sceneNodeHighlight, debugNodes) {
    var _a;
    const regexpPredicate = matcher => n => {
      if (matcher.test(n.id)) {
        return true;
      }
      return n instanceof Group && n.name != null && matcher.test(n.name);
    };
    const stringPredicate = match => n => {
      if (match === n.id) {
        return true;
      }
      return n instanceof Group && n.name != null && match === n.name;
    };
    for (const next of sceneNodeHighlight) {
      if (typeof next === 'string' && debugNodes[next] != null) continue;
      const predicate = typeof next === 'string' ? stringPredicate(next) : regexpPredicate(next);
      const nodes = (_a = this.root) === null || _a === void 0 ? void 0 : _a.findNodes(predicate);
      if (!nodes || nodes.length === 0) {
        Logger.debug(`no debugging node with id [${next}] in scene graph.`);
        continue;
      }
      for (const node of nodes) {
        if (node instanceof Group && node.name) {
          debugNodes[node.name] = node;
        } else {
          debugNodes[node.id] = node;
        }
      }
    }
    ctx.save();
    for (const [name, node] of Object.entries(debugNodes)) {
      const bbox = node.computeTransformedBBox();
      if (!bbox) {
        Logger.debug(`no bbox for debugged node [${name}].`);
        continue;
      }
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 1;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
      ctx.fillStyle = 'red';
      ctx.strokeStyle = 'white';
      ctx.font = '16px sans-serif';
      ctx.textBaseline = 'top';
      ctx.textAlign = 'left';
      ctx.lineWidth = 2;
      ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
      ctx.fillText(name, bbox.x, bbox.y, bbox.width);
    }
    ctx.restore();
  }
  buildTree(node) {
    var _a;
    const name = (_a = node instanceof Group ? node.name : null) !== null && _a !== void 0 ? _a : node.id;
    return Object.assign({
      name,
      node,
      dirty: RedrawType[node.dirty]
    }, node.children.map(c => this.buildTree(c)).reduce((result, childTree) => {
      let {
        name: treeNodeName
      } = childTree;
      const {
        node: {
          visible,
          opacity,
          zIndex,
          zIndexSubOrder
        },
        node: childNode
      } = childTree;
      if (!visible || opacity <= 0) {
        treeNodeName = `(${treeNodeName})`;
      }
      if (childNode instanceof Group && childNode.isLayer()) {
        treeNodeName = `*${treeNodeName}*`;
      }
      const key = [`${treeNodeName !== null && treeNodeName !== void 0 ? treeNodeName : '<unknown>'}`, `z: ${zIndex}`, zIndexSubOrder && `zo: ${zIndexSubOrder.join(' / ')}`].filter(v => !!v).join(' ');
      result[key] = childTree;
      return result;
    }, {}));
  }
  buildDirtyTree(node) {
    var _a;
    if (node.dirty === RedrawType.NONE) {
      return {
        dirtyTree: {},
        paths: []
      };
    }
    const childrenDirtyTree = node.children.map(c => this.buildDirtyTree(c)).filter(c => c.paths.length > 0);
    const name = (_a = node instanceof Group ? node.name : null) !== null && _a !== void 0 ? _a : node.id;
    const paths = childrenDirtyTree.length === 0 ? [name] : childrenDirtyTree.map(c => c.paths).reduce((r, p) => r.concat(p), []).map(p => `${name}.${p}`);
    return {
      dirtyTree: Object.assign({
        name,
        node,
        dirty: RedrawType[node.dirty]
      }, childrenDirtyTree.map(c => c.dirtyTree).filter(t => t.dirty !== undefined).reduce((result, childTree) => {
        var _a;
        result[(_a = childTree.name) !== null && _a !== void 0 ? _a : '<unknown>'] = childTree;
        return result;
      }, {})),
      paths
    };
  }
}
Scene.className = 'Scene';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/gradient/gradient.mjs
class Gradient {
  constructor() {
    this.stops = [];
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/angle.mjs
const twoPi = Math.PI * 2;
/**
 * Normalize the given angle to be in the [0, 2Ï) interval.
 * @param radians Angle in radians.
 */
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle360Inclusive(radians) {
  radians %= twoPi;
  radians += twoPi;
  if (radians !== twoPi) {
    radians %= twoPi;
  }
  return radians;
}
/**
 * Normalize the given angle to be in the [-Ï, Ï) interval.
 * @param radians Angle in radians.
 */
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function toDegrees(radians) {
  return radians / Math.PI * 180;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/gradient/linearGradient.mjs


class LinearGradient extends Gradient {
  constructor() {
    super(...arguments);
    this.angle = 0;
  }
  createGradient(ctx, bbox) {
    // Gradient 0Â° angle starts at top according to CSS spec
    const angleOffset = 90;
    const {
      stops,
      angle
    } = this;
    const radians = normalizeAngle360(toRadians(angle + angleOffset));
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const w = bbox.width;
    const h = bbox.height;
    const cx = bbox.x + w * 0.5;
    const cy = bbox.y + h * 0.5;
    if (w > 0 && h > 0) {
      const diagonal = Math.sqrt(h * h + w * w) / 2;
      const diagonalAngle = Math.atan2(h, w);
      let quarteredAngle;
      if (radians < Math.PI / 2) {
        quarteredAngle = radians;
      } else if (radians < Math.PI) {
        quarteredAngle = Math.PI - radians;
      } else if (radians < 3 * Math.PI / 2) {
        quarteredAngle = radians - Math.PI;
      } else {
        quarteredAngle = 2 * Math.PI - radians;
      }
      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
      stops.forEach(stop => {
        gradient.addColorStop(stop.offset, stop.color);
      });
      return gradient;
    }
    return 'black';
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/shape.mjs

var shape_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


const LINEAR_GRADIENT_REGEXP = /^linear-gradient\((.*?)deg,\s*(.*?)\s*\)$/i;
class Shape extends Node {
  constructor() {
    super(...arguments);
    this.lastInstanceId = 0;
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.fill = Shape.defaultStyles.fill;
    /**
     * Note that `strokeStyle = null` means invisible stroke,
     * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.
     * For example, a rect shape with an invisible stroke may not align to the pixel grid
     * properly because the stroke affects the rules of alignment, and arc shapes forming
     * a pie chart will have a gap between them if they have an invisible stroke, whereas
     * there would be not gap if there was no stroke at all.
     * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,
     * unless specific looks that is achieved by having an invisible stroke is desired.
     */
    this.stroke = Shape.defaultStyles.stroke;
    this.strokeWidth = Shape.defaultStyles.strokeWidth;
    this.lineDash = Shape.defaultStyles.lineDash;
    this.lineDashOffset = Shape.defaultStyles.lineDashOffset;
    this.lineCap = Shape.defaultStyles.lineCap;
    this.lineJoin = Shape.defaultStyles.lineJoin;
    this.opacity = Shape.defaultStyles.opacity;
    this.fillShadow = Shape.defaultStyles.fillShadow;
  }
  /**
   * Creates a light-weight instance of the given shape (that serves as a template).
   * The created instance only stores the properites set on the instance itself
   * and the rest of the properties come via the prototype chain from the template.
   * This can greatly reduce memory usage in cases where one has many similar shapes,
   * for example, circles of different size, position and color. The exact memory usage
   * reduction will depend on the size of the template and the number of own properties
   * set on its lightweight instances, but will typically be around an order of magnitude
   * or more.
   *
   * Note: template shapes are not supposed to be part of the scene graph (they should not
   * have a parent).
   *
   * @param template
   */
  static createInstance(template) {
    const shape = Object.create(template);
    shape._setParent(undefined);
    shape.id = template.id + '-Instance-' + String(++template.lastInstanceId);
    return shape;
  }
  /**
   * Restores the default styles introduced by this subclass.
   */
  restoreOwnStyles() {
    const styles = this.constructor.defaultStyles;
    const keys = Object.getOwnPropertyNames(styles);
    // getOwnPropertyNames is about 2.5 times faster than
    // for..in with the hasOwnProperty check and in this
    // case, where most properties are inherited, can be
    // more then an order of magnitude faster.
    for (let i = 0, n = keys.length; i < n; i++) {
      const key = keys[i];
      this[key] = styles[key];
    }
  }
  restoreAllStyles() {
    const styles = this.constructor.defaultStyles;
    for (const property in styles) {
      this[property] = styles[property];
    }
  }
  /**
   * Restores the base class default styles that have been overridden by this subclass.
   */
  restoreOverriddenStyles() {
    const styles = this.constructor.defaultStyles;
    const protoStyles = Object.getPrototypeOf(styles);
    for (const property in styles) {
      if (Object.prototype.hasOwnProperty.call(styles, property) && Object.prototype.hasOwnProperty.call(protoStyles, property)) {
        this[property] = styles[property];
      }
    }
  }
  updateGradient() {
    const {
      fill
    } = this;
    let linearGradientMatch;
    if ((fill === null || fill === void 0 ? void 0 : fill.startsWith('linear-gradient')) && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {
      const angle = parseFloat(linearGradientMatch[1]);
      const colors = [];
      const colorsPart = linearGradientMatch[2];
      const colorRegex = /(#[0-9a-f]+)|(rgba?\(.+?\))|([a-z]+)/gi;
      let c;
      while (c = colorRegex.exec(colorsPart)) {
        colors.push(c[0]);
      }
      this.gradient = new LinearGradient();
      this.gradient.angle = angle;
      this.gradient.stops = colors.map((color, index) => {
        const offset = index / (colors.length - 1);
        return {
          offset,
          color
        };
      });
    } else {
      this.gradient = undefined;
    }
  }
  /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */
  align(start, length) {
    var _a, _b, _c;
    const pixelRatio = (_c = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas) === null || _b === void 0 ? void 0 : _b.pixelRatio) !== null && _c !== void 0 ? _c : 1;
    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;
    if (length == undefined) {
      return alignedStart;
    }
    if (length === 0) {
      return 0;
    }
    if (length < 1) {
      // Avoid hiding crisp shapes
      return Math.ceil(length * pixelRatio) / pixelRatio;
    }
    // Account for the rounding of alignedStart by increasing length to compensate before
    // alignment.
    return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;
  }
  fillStroke(ctx) {
    this.renderFill(ctx);
    this.renderStroke(ctx);
  }
  renderFill(ctx) {
    if (this.fill) {
      const {
        globalAlpha
      } = ctx;
      this.applyFill(ctx);
      this.applyFillAlpha(ctx);
      this.applyShadow(ctx);
      ctx.fill();
      ctx.globalAlpha = globalAlpha;
    }
    ctx.shadowColor = 'rgba(0, 0, 0, 0)';
  }
  applyFill(ctx) {
    if (this.gradient) {
      ctx.fillStyle = this.gradient.createGradient(ctx, this.computeBBox());
    } else {
      ctx.fillStyle = this.fill;
    }
  }
  applyFillAlpha(ctx) {
    const {
      globalAlpha
    } = ctx;
    ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;
  }
  applyShadow(ctx) {
    var _a, _b;
    // The canvas context scaling (depends on the device's pixel ratio)
    // has no effect on shadows, so we have to account for the pixel ratio
    // manually here.
    const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;
    const fillShadow = this.fillShadow;
    if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {
      ctx.shadowColor = fillShadow.color;
      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
      ctx.shadowBlur = fillShadow.blur * pixelRatio;
    }
  }
  renderStroke(ctx) {
    if (this.stroke && this.strokeWidth) {
      const {
        globalAlpha
      } = ctx;
      ctx.strokeStyle = this.stroke;
      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;
      ctx.lineWidth = this.strokeWidth;
      if (this.lineDash) {
        ctx.setLineDash(this.lineDash);
      }
      if (this.lineDashOffset) {
        ctx.lineDashOffset = this.lineDashOffset;
      }
      if (this.lineCap) {
        ctx.lineCap = this.lineCap;
      }
      if (this.lineJoin) {
        ctx.lineJoin = this.lineJoin;
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
  }
  containsPoint(x, y) {
    return this.isPointInPath(x, y);
  }
}
/**
 * Defaults for style properties. Note that properties that affect the position
 * and shape of the node are not considered style properties, for example:
 * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.
 * Can be used to reset to the original styling after some custom styling
 * has been applied (using the `restoreOwnStyles` and `restoreAllStyles` methods).
 * These static defaults are meant to be inherited by subclasses.
 */
Shape.defaultStyles = Object.assign({}, {
  fill: 'black',
  stroke: undefined,
  strokeWidth: 0,
  lineDash: undefined,
  lineDashOffset: 0,
  lineCap: undefined,
  lineJoin: undefined,
  opacity: 1,
  fillShadow: undefined
});
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "fillOpacity", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "strokeOpacity", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR,
  changeCb: s => s.updateGradient()
})], Shape.prototype, "fill", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "stroke", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "strokeWidth", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "lineDash", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "lineDashOffset", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "lineCap", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Shape.prototype, "lineJoin", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR,
  convertor: v => Math.min(1, Math.max(0, v))
})], Shape.prototype, "opacity", void 0);
shape_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR,
  checkDirtyOnAssignment: true
})], Shape.prototype, "fillShadow", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/text.mjs

var text_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




const ellipsis = '\u2026';
function SceneFontChangeDetection(opts) {
  const {
    redraw = RedrawType.MAJOR,
    changeCb
  } = opts !== null && opts !== void 0 ? opts : {};
  return SceneChangeDetection({
    redraw,
    type: 'font',
    changeCb
  });
}
class Text extends Shape {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.lines = [];
    this.text = undefined;
    this._dirtyFont = true;
    this.fontSize = 10;
    this.fontFamily = 'sans-serif';
    this.textAlign = Text.defaultStyles.textAlign;
    this.textBaseline = Text.defaultStyles.textBaseline;
    // TextMetrics are used if lineHeight is not defined.
    this.lineHeight = undefined;
  }
  _setLines() {
    this.lines = splitText(this.text);
  }
  get font() {
    if (this._dirtyFont) {
      this._dirtyFont = false;
      this._font = getFont(this);
    }
    return this._font;
  }
  computeBBox() {
    return HdpiCanvas.has.textMetrics ? getPreciseBBox(this.lines, this.x, this.y, this) : getApproximateBBox(this.lines, this.x, this.y, this);
  }
  getLineHeight(line) {
    var _a, _b;
    if (this.lineHeight) return this.lineHeight;
    if (HdpiCanvas.has.textMetrics) {
      const metrics = HdpiCanvas.measureText(line, this.font, this.textBaseline, this.textAlign);
      return ((_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent) + ((_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent);
    }
    return HdpiCanvas.getTextSize(line, this.font).height;
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return bbox ? bbox.containsPoint(point.x, point.y) : false;
  }
  render(renderCtx) {
    const {
      ctx,
      forceRender,
      stats
    } = renderCtx;
    if (this.dirty === RedrawType.NONE && !forceRender) {
      if (stats) stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    if (!this.lines.length || !this.layerManager) {
      if (stats) stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    const {
      fill,
      stroke,
      strokeWidth
    } = this;
    ctx.font = this.font;
    ctx.textAlign = this.textAlign;
    ctx.textBaseline = this.textBaseline;
    const pixelRatio = this.layerManager.canvas.pixelRatio || 1;
    const {
      globalAlpha
    } = ctx;
    if (fill) {
      ctx.fillStyle = fill;
      ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;
      const {
        fillShadow
      } = this;
      if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {
        ctx.shadowColor = fillShadow.color;
        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
        ctx.shadowBlur = fillShadow.blur * pixelRatio;
      }
      this.renderLines((line, x, y) => ctx.fillText(line, x, y));
    }
    if (stroke && strokeWidth) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = strokeWidth;
      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;
      const {
        lineDash,
        lineDashOffset,
        lineCap,
        lineJoin
      } = this;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));
    }
    super.render(renderCtx);
  }
  renderLines(renderCallback) {
    const {
      lines,
      x,
      y
    } = this;
    const lineHeights = this.lines.map(line => this.getLineHeight(line));
    const totalHeight = lineHeights.reduce((a, b) => a + b, 0);
    let offsetY = -(totalHeight - lineHeights[0]) * getVerticalOffset(this.textBaseline);
    for (let i = 0; i < lines.length; i++) {
      renderCallback(lines[i], x, y + offsetY);
      offsetY += lineHeights[i];
    }
  }
  static wrap(text, maxWidth, maxHeight, textProps, wrapping) {
    const font = getFont(textProps);
    const measurer = createTextMeasurer(font);
    const lines = text.split(/\r?\n/g);
    if (lines.length === 0) {
      return '';
    }
    if (wrapping === 'never') {
      return Text.truncateLine(lines[0], maxWidth, measurer, false);
    }
    const result = [];
    let cumulativeHeight = 0;
    for (const line of lines) {
      const wrappedLine = Text.wrapLine(line, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight);
      result.push(wrappedLine.result);
      cumulativeHeight = wrappedLine.cumulativeHeight;
      if (wrappedLine.truncated) {
        break;
      }
    }
    return result.join('\n').trim();
  }
  static wrapLine(text, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight) {
    text = text.trim();
    if (!text) {
      return {
        result: '',
        truncated: false,
        cumulativeHeight
      };
    }
    const initialSize = measurer.size(text);
    if (initialSize.width <= maxWidth) {
      // Text fits into a single line
      return {
        result: text,
        truncated: false,
        cumulativeHeight: cumulativeHeight + initialSize.height
      };
    }
    if (initialSize.height > maxHeight || measurer.width('W') > maxWidth) {
      // Not enough space for a single line or character
      return {
        result: '',
        truncated: true,
        cumulativeHeight
      };
    }
    const words = text.split(/\s+/g);
    const wrapResult = Text.wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight);
    cumulativeHeight = wrapResult.cumulativeHeight;
    let {
      lines
    } = wrapResult;
    if (!(wrapResult.wordsBrokenOrTruncated || wrapResult.linesTruncated)) {
      // If no word breaks or truncations, try the balanced wrapping
      const linesCount = wrapResult.lines.length;
      const balanced = Text.wrapLineBalanced(words, maxWidth, measurer, linesCount);
      if (balanced.length === lines.length) {
        // Some lines can't be balanced properly because of unusually long words
        lines = balanced;
      }
    }
    const wrappedText = lines.map(ln => ln.join(' ')).join('\n');
    return {
      result: wrappedText,
      truncated: wrapResult.linesTruncated,
      cumulativeHeight
    };
  }
  static breakWord(word, firstLineWidth, maxWidth, hyphens, measurer) {
    const isPunctuationAt = index => Text.punctuationMarks.includes(word[index]);
    const h = hyphens ? measurer.width('-') : 0;
    const breaks = [];
    let partWidth = 0;
    let p = 0;
    for (let i = 0; i < word.length; i++) {
      const c = word[i];
      const w = measurer.width(c);
      const limit = p === 0 ? firstLineWidth : maxWidth;
      if (partWidth + w + h > limit) {
        breaks.push(i);
        partWidth = 0;
        p++;
      }
      partWidth += w;
    }
    const parts = [];
    let start = 0;
    for (const index of breaks) {
      let part = word.substring(start, index);
      if (hyphens && part.length > 0 && !isPunctuationAt(index - 1) && !isPunctuationAt(index)) {
        part += '-';
      }
      parts.push(part);
      start = index;
    }
    parts.push(word.substring(start));
    return parts;
  }
  static truncateLine(text, maxWidth, measurer, forceEllipsis) {
    const lineWidth = measurer.width(text);
    if (lineWidth < maxWidth && !forceEllipsis) {
      return text;
    }
    const ellipsisWidth = measurer.width(ellipsis);
    if (lineWidth + ellipsisWidth <= maxWidth) {
      return `${text}${ellipsis}`;
    }
    let index = Math.floor(text.length * maxWidth / lineWidth) + 1;
    let trunc;
    let truncWidth;
    do {
      trunc = text.substring(0, index);
      truncWidth = measurer.width(trunc);
    } while (--index >= 0 && truncWidth + ellipsisWidth > maxWidth);
    return `${trunc}${ellipsis}`;
  }
  static wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight) {
    const {
      fontSize,
      lineHeight = fontSize * Text.defaultLineHeightRatio
    } = textProps;
    const breakWord = wrapping === 'always' || wrapping === 'hyphenate';
    const hyphenate = wrapping === 'hyphenate';
    const spaceWidth = measurer.width(' ');
    let wordsBrokenOrTruncated = false;
    let linesTruncated = false;
    const lines = [];
    let currentLine = [];
    let lineWidth = 0;
    const addNewLine = () => {
      const expectedHeight = cumulativeHeight + lineHeight;
      if (expectedHeight >= maxHeight) {
        // Truncate the last line
        const lastLine = currentLine.join(' ');
        const trunc = Text.truncateLine(lastLine, maxWidth, measurer, true);
        currentLine.splice(0, currentLine.length, trunc);
        linesTruncated = true;
        return false;
      }
      // Add new line
      currentLine = [];
      lineWidth = 0;
      cumulativeHeight = expectedHeight;
      lines.push(currentLine);
      return true;
    };
    if (!addNewLine()) {
      return {
        lines,
        linesTruncated: true,
        wordsBrokenOrTruncated,
        cumulativeHeight
      };
    }
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const wordWidth = measurer.width(word);
      const expectedSpaceWidth = currentLine.length === 0 ? 0 : spaceWidth;
      const expectedLineWidth = lineWidth + expectedSpaceWidth + wordWidth;
      if (expectedLineWidth <= maxWidth) {
        // If the word fits, add it to the current line
        currentLine.push(word);
        lineWidth = expectedLineWidth;
        continue;
      }
      if (wordWidth <= maxWidth) {
        // If the word is not too long, put it onto new line
        if (!addNewLine()) {
          break;
        }
        currentLine.push(word);
        lineWidth = wordWidth;
        continue;
      }
      // Handle a long word
      wordsBrokenOrTruncated = true;
      if (breakWord) {
        // Break the word into parts
        const availWidth = maxWidth - lineWidth - expectedSpaceWidth;
        const parts = Text.breakWord(word, availWidth, maxWidth, hyphenate, measurer);
        let breakLoop = false;
        for (let p = 0; p < parts.length; p++) {
          const part = parts[p];
          part && currentLine.push(part);
          if (p === parts.length - 1) {
            lineWidth = measurer.width(part);
          } else if (!addNewLine()) {
            breakLoop = true;
            break;
          }
        }
        if (breakLoop) break;
      } else {
        // Truncate the word
        if (!addNewLine()) {
          break;
        }
        const trunc = Text.truncateLine(word, maxWidth, measurer, true);
        currentLine.push(trunc);
        if (i < words.length - 1) {
          linesTruncated = true;
        }
        break;
      }
    }
    return {
      lines,
      linesTruncated,
      wordsBrokenOrTruncated,
      cumulativeHeight
    };
  }
  static wrapLineBalanced(words, maxWidth, measurer, linesCount) {
    const totalWordsWidth = words.reduce((sum, w) => sum + measurer.width(w), 0);
    const spaceWidth = measurer.width(' ');
    const totalSpaceWidth = spaceWidth * (words.length - linesCount - 2);
    const averageLineWidth = (totalWordsWidth + totalSpaceWidth) / linesCount;
    const lines = [];
    let currentLine = [];
    let lineWidth = measurer.width(words[0]);
    let newLine = true;
    for (const word of words) {
      const width = measurer.width(word);
      if (newLine) {
        // New line
        currentLine = [];
        currentLine.push(word);
        lineWidth = width;
        newLine = false;
        lines.push(currentLine);
        continue;
      }
      const expectedLineWidth = lineWidth + spaceWidth + width;
      if (expectedLineWidth <= averageLineWidth) {
        // Keep adding words to the line
        currentLine.push(word);
        lineWidth = expectedLineWidth;
      } else if (expectedLineWidth <= maxWidth) {
        // Add the last word to the line
        currentLine.push(word);
        newLine = true;
      } else {
        // Put the word onto the next line
        currentLine = [word];
        lineWidth = width;
        lines.push(currentLine);
      }
    }
    return lines;
  }
}
Text.className = 'Text';
// The default line spacing for document editors is usually 1.15
Text.defaultLineHeightRatio = 1.15;
Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {
  textAlign: 'start',
  fontStyle: undefined,
  fontWeight: undefined,
  fontSize: 10,
  fontFamily: 'sans-serif',
  textBaseline: 'alphabetic'
});
Text.punctuationMarks = ['.', ',', '-', ':', ';', '!', '?', `'`, '"', '(', ')'];
text_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Text.prototype, "x", void 0);
text_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Text.prototype, "y", void 0);
text_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR,
  changeCb: o => o._setLines()
})], Text.prototype, "text", void 0);
text_decorate([SceneFontChangeDetection()], Text.prototype, "fontStyle", void 0);
text_decorate([SceneFontChangeDetection()], Text.prototype, "fontWeight", void 0);
text_decorate([SceneFontChangeDetection()], Text.prototype, "fontSize", void 0);
text_decorate([SceneFontChangeDetection()], Text.prototype, "fontFamily", void 0);
text_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Text.prototype, "textAlign", void 0);
text_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Text.prototype, "textBaseline", void 0);
text_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Text.prototype, "lineHeight", void 0);
function createTextMeasurer(font) {
  const cache = new Map();
  const getTextSize = text => HdpiCanvas.getTextSize(text, font);
  const getLineWidth = text => {
    if (cache.has(text)) {
      return cache.get(text);
    }
    const {
      width
    } = getTextSize(text);
    cache.set(text, width);
    return width;
  };
  return {
    size: getTextSize,
    width: getLineWidth
  };
}
function getFont(fontProps) {
  const {
    fontFamily,
    fontSize,
    fontStyle,
    fontWeight
  } = fontProps;
  return [fontStyle !== null && fontStyle !== void 0 ? fontStyle : '', fontWeight !== null && fontWeight !== void 0 ? fontWeight : '', fontSize + 'px', fontFamily].join(' ').trim();
}
function measureText(lines, x, y, textProps) {
  return HdpiCanvas.has.textMetrics ? getPreciseBBox(lines, x, y, textProps) : getApproximateBBox(lines, x, y, textProps);
}
function getPreciseBBox(lines, x, y, textProps) {
  var _a, _b;
  let left = 0;
  let top = 0;
  let width = 0;
  let height = 0;
  // Distance between first and last base lines.
  let baselineDistance = 0;
  const font = getFont(textProps);
  const {
    lineHeight,
    textBaseline = Text.defaultStyles.textBaseline,
    textAlign = Text.defaultStyles.textAlign
  } = textProps;
  for (let i = 0; i < lines.length; i++) {
    const metrics = HdpiCanvas.measureText(lines[i], font, textBaseline, textAlign);
    left = Math.max(left, metrics.actualBoundingBoxLeft);
    width = Math.max(width, metrics.width);
    if (i == 0) {
      top += metrics.actualBoundingBoxAscent;
      height += metrics.actualBoundingBoxAscent;
    } else {
      baselineDistance += (_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent;
    }
    if (i == lines.length - 1) {
      height += metrics.actualBoundingBoxDescent;
    } else {
      baselineDistance += (_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent;
    }
  }
  if (lineHeight !== undefined) {
    baselineDistance = (lines.length - 1) * lineHeight;
  }
  height += baselineDistance;
  top += baselineDistance * getVerticalOffset(textBaseline);
  return new BBox(x - left, y - top, width, height);
}
function getApproximateBBox(lines, x, y, textProps) {
  let width = 0;
  let firstLineHeight = 0;
  // Distance between first and last base lines.
  let baselineDistance = 0;
  const font = getFont(textProps);
  const {
    lineHeight,
    textBaseline = Text.defaultStyles.textBaseline,
    textAlign = Text.defaultStyles.textAlign
  } = textProps;
  if (lines.length > 0) {
    const lineSize = HdpiCanvas.getTextSize(lines[0], font);
    width = lineSize.width;
    firstLineHeight = lineSize.height;
  }
  for (let i = 1; i < lines.length; i++) {
    const lineSize = HdpiCanvas.getTextSize(lines[i], font);
    width = Math.max(width, lineSize.width);
    baselineDistance += lineHeight !== null && lineHeight !== void 0 ? lineHeight : lineSize.height;
  }
  switch (textAlign) {
    case 'end':
    case 'right':
      x -= width;
      break;
    case 'center':
      x -= width / 2;
  }
  switch (textBaseline) {
    case 'alphabetic':
      y -= firstLineHeight * 0.7 + baselineDistance * 0.5;
      break;
    case 'middle':
      y -= firstLineHeight * 0.45 + baselineDistance * 0.5;
      break;
    case 'ideographic':
      y -= firstLineHeight + baselineDistance;
      break;
    case 'hanging':
      y -= firstLineHeight * 0.2 + baselineDistance * 0.5;
      break;
    case 'bottom':
      y -= firstLineHeight + baselineDistance;
      break;
  }
  return new BBox(x, y, width, firstLineHeight + baselineDistance);
}
function getVerticalOffset(textBaseline) {
  switch (textBaseline) {
    case 'top':
    case 'hanging':
      return 0;
    case 'bottom':
    case 'alphabetic':
    case 'ideographic':
      return 1;
    case 'middle':
      return 0.5;
  }
}
function splitText(text) {
  return typeof text === 'string' ? text.split(/\r?\n/g) : [];
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/observable.mjs
class Observable {
  constructor() {
    this.allEventListeners = new Map();
  }
  addEventListener(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('AG Charts - listener must be a Function');
    }
    const {
      allEventListeners
    } = this;
    let eventListeners = allEventListeners.get(type);
    if (!eventListeners) {
      eventListeners = new Set();
      allEventListeners.set(type, eventListeners);
    }
    if (!eventListeners.has(listener)) {
      eventListeners.add(listener);
    }
  }
  removeEventListener(type, listener) {
    const {
      allEventListeners
    } = this;
    const eventListeners = allEventListeners.get(type);
    if (!eventListeners) {
      return;
    }
    eventListeners.delete(listener);
    if (eventListeners.size === 0) {
      allEventListeners.delete(type);
    }
  }
  hasEventListener(type) {
    return this.allEventListeners.has(type);
  }
  clearEventListeners() {
    this.allEventListeners.clear();
  }
  fireEvent(event) {
    const listeners = this.allEventListeners.get(event.type);
    listeners === null || listeners === void 0 ? void 0 : listeners.forEach(listener => listener(event));
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/value.mjs
const isString = v => typeof v === 'string';
const isStringObject = v => !!v && Object.prototype.hasOwnProperty.call(v, 'toString') && isString(v.toString());
const isDate = v => v instanceof Date && !isNaN(+v);
function isDiscrete(value) {
  return isString(value) || isStringObject(value);
}
function isContinuous(value) {
  const isNumberObject = v => !!v && Object.prototype.hasOwnProperty.call(v, 'valueOf') && isNumber(v.valueOf());
  const isDate = v => v instanceof Date && !isNaN(+v);
  return isNumber(value) || isNumberObject(value) || isDate(value);
}
function checkDatum(value, isContinuousScale) {
  if (isContinuousScale && isContinuous(value)) {
    return value;
  } else if (!isContinuousScale) {
    if (!isDiscrete(value)) {
      return String(value);
    }
    return value;
  }
  return undefined;
}
const isNumber = v => typeof v === 'number' && Number.isFinite(v);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/color.mjs


class Color {
  /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */
  constructor(r, g, b, a = 1) {
    // NaN is treated as 0.
    this.r = Math.min(1, Math.max(0, r || 0));
    this.g = Math.min(1, Math.max(0, g || 0));
    this.b = Math.min(1, Math.max(0, b || 0));
    this.a = Math.min(1, Math.max(0, a || 0));
  }
  /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */
  static validColorString(str) {
    if (str.indexOf('#') >= 0) {
      return !!Color.parseHex(str);
    }
    if (str.indexOf('rgb') >= 0) {
      return !!Color.stringToRgba(str);
    }
    return !!Color.nameToHex[str.toLowerCase()];
  }
  /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */
  static fromString(str) {
    // hexadecimal notation
    if (str.indexOf('#') >= 0) {
      // there can be some leading whitespace
      return Color.fromHexString(str);
    }
    // color name
    const hex = Color.nameToHex[str.toLowerCase()];
    if (hex) {
      return Color.fromHexString(hex);
    }
    // rgb(a) notation
    if (str.indexOf('rgb') >= 0) {
      return Color.fromRgbaString(str);
    }
    throw new Error(`Invalid color string: '${str}'`);
  }
  static tryParseFromString(str) {
    try {
      return Color.fromString(str);
    } catch (e) {
      Logger.warnOnce(`invalid color string: '${str}'.`);
      return Color.fromArray([0, 0, 0]);
    }
  }
  // See https://drafts.csswg.org/css-color/#hex-notation
  static parseHex(input) {
    input = input.replace(/ /g, '').slice(1);
    let parts;
    switch (input.length) {
      case 6:
      case 8:
        parts = [];
        for (let i = 0; i < input.length; i += 2) {
          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
        }
        break;
      case 3:
      case 4:
        parts = input.split('').map(p => parseInt(p, 16)).map(p => p + p * 16);
        break;
    }
    if ((parts === null || parts === void 0 ? void 0 : parts.length) >= 3) {
      if (parts.every(p => p >= 0)) {
        if (parts.length === 3) {
          parts.push(255);
        }
        return parts;
      }
    }
  }
  static fromHexString(str) {
    const values = Color.parseHex(str);
    if (values) {
      const [r, g, b, a] = values;
      return new Color(r / 255, g / 255, b / 255, a / 255);
    }
    throw new Error(`Malformed hexadecimal color string: '${str}'`);
  }
  static stringToRgba(str) {
    // Find positions of opening and closing parentheses.
    let [po, pc] = [NaN, NaN];
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (!po && c === '(') {
        po = i;
      } else if (c === ')') {
        pc = i;
        break;
      }
    }
    const contents = po && pc && str.substring(po + 1, pc);
    if (!contents) {
      return;
    }
    const parts = contents.split(',');
    const rgba = [];
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      let value = parseFloat(part);
      if (isNaN(value)) {
        return;
      }
      if (part.indexOf('%') >= 0) {
        // percentage r, g, or b value
        value = Math.max(0, Math.min(100, value));
        value /= 100;
      } else {
        if (i === 3) {
          // alpha component
          value = Math.max(0, Math.min(1, value));
        } else {
          // absolute r, g, or b value
          value = Math.max(0, Math.min(255, value));
          value /= 255;
        }
      }
      rgba.push(value);
    }
    return rgba;
  }
  static fromRgbaString(str) {
    const rgba = Color.stringToRgba(str);
    if (rgba) {
      if (rgba.length === 3) {
        return new Color(rgba[0], rgba[1], rgba[2]);
      } else if (rgba.length === 4) {
        return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
    }
    throw new Error(`Malformed rgb/rgba color string: '${str}'`);
  }
  static fromArray(arr) {
    if (arr.length === 4) {
      return new Color(arr[0], arr[1], arr[2], arr[3]);
    }
    if (arr.length === 3) {
      return new Color(arr[0], arr[1], arr[2]);
    }
    throw new Error('The given array should contain 3 or 4 color components (numbers).');
  }
  static fromHSB(h, s, b, alpha = 1) {
    const rgb = Color.HSBtoRGB(h, s, b);
    return new Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static padHex(str) {
    // Can't use `padStart(2, '0')` here because of IE.
    return str.length === 1 ? '0' + str : str;
  }
  toHexString() {
    let hex = '#' + Color.padHex(Math.round(this.r * 255).toString(16)) + Color.padHex(Math.round(this.g * 255).toString(16)) + Color.padHex(Math.round(this.b * 255).toString(16));
    if (this.a < 1) {
      hex += Color.padHex(Math.round(this.a * 255).toString(16));
    }
    return hex;
  }
  toRgbaString(fractionDigits = 3) {
    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
    const k = Math.pow(10, fractionDigits);
    if (this.a !== 1) {
      components.push(Math.round(this.a * k) / k);
      return `rgba(${components.join(', ')})`;
    }
    return `rgb(${components.join(', ')})`;
  }
  toString() {
    if (this.a === 1) {
      return this.toHexString();
    }
    return this.toRgbaString();
  }
  toHSB() {
    return Color.RGBtoHSB(this.r, this.g, this.b);
  }
  /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   * The hue component will be `NaN` for achromatic colors.
   */
  static RGBtoHSB(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const S = max !== 0 ? (max - min) / max : 0;
    let H = NaN;
    // min == max, means all components are the same
    // and the color is a shade of gray with no hue (H is NaN)
    if (min !== max) {
      const delta = max - min;
      const rc = (max - r) / delta;
      const gc = (max - g) / delta;
      const bc = (max - b) / delta;
      if (r === max) {
        H = bc - gc;
      } else if (g === max) {
        H = 2.0 + rc - bc;
      } else {
        H = 4.0 + gc - rc;
      }
      H /= 6.0;
      if (H < 0) {
        H = H + 1.0;
      }
    }
    return [H * 360, S, max];
  }
  /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */
  static HSBtoRGB(H, S, B) {
    if (isNaN(H)) {
      H = 0;
    }
    H = (H % 360 + 360) % 360 / 360; // normalize hue to [0, 360] interval, then scale to [0, 1]
    let r = 0;
    let g = 0;
    let b = 0;
    if (S === 0) {
      r = g = b = B;
    } else {
      const h = (H - Math.floor(H)) * 6;
      const f = h - Math.floor(h);
      const p = B * (1 - S);
      const q = B * (1 - S * f);
      const t = B * (1 - S * (1 - f));
      switch (h >> 0 // discard the floating point part of the number
      ) {
        case 0:
          r = B;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = B;
          b = p;
          break;
        case 2:
          r = p;
          g = B;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = B;
          break;
        case 4:
          r = t;
          g = p;
          b = B;
          break;
        case 5:
          r = B;
          g = p;
          b = q;
          break;
      }
    }
    return [r, g, b];
  }
  derive(hueShift, saturationFactor, brightnessFactor, opacityFactor) {
    const hsb = Color.RGBtoHSB(this.r, this.g, this.b);
    let b = hsb[2];
    if (b == 0 && brightnessFactor > 1.0) {
      b = 0.05;
    }
    const h = ((hsb[0] + hueShift) % 360 + 360) % 360;
    const s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);
    b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);
    const a = Math.max(Math.min(this.a * opacityFactor, 1.0), 0.0);
    const rgba = Color.HSBtoRGB(h, s, b);
    rgba.push(a);
    return Color.fromArray(rgba);
  }
  brighter() {
    return this.derive(0, 1.0, 1.0 / 0.7, 1.0);
  }
  darker() {
    return this.derive(0, 1.0, 0.7, 1.0);
  }
  static interpolate(color, other) {
    const c0 = Color.tryParseFromString(color);
    const c1 = Color.tryParseFromString(other);
    return t => {
      const i = (x, y) => x * (1 - t) + y * t;
      const c = new Color(i(c0.r, c1.r), i(c0.g, c1.g), i(c0.b, c1.b), i(c0.a, c1.a));
      return c.toString();
    };
  }
}
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */
Color.nameToHex = Object.freeze({
  aliceblue: '#F0F8FF',
  antiquewhite: '#FAEBD7',
  aqua: '#00FFFF',
  aquamarine: '#7FFFD4',
  azure: '#F0FFFF',
  beige: '#F5F5DC',
  bisque: '#FFE4C4',
  black: '#000000',
  blanchedalmond: '#FFEBCD',
  blue: '#0000FF',
  blueviolet: '#8A2BE2',
  brown: '#A52A2A',
  burlywood: '#DEB887',
  cadetblue: '#5F9EA0',
  chartreuse: '#7FFF00',
  chocolate: '#D2691E',
  coral: '#FF7F50',
  cornflowerblue: '#6495ED',
  cornsilk: '#FFF8DC',
  crimson: '#DC143C',
  cyan: '#00FFFF',
  darkblue: '#00008B',
  darkcyan: '#008B8B',
  darkgoldenrod: '#B8860B',
  darkgray: '#A9A9A9',
  darkgreen: '#006400',
  darkgrey: '#A9A9A9',
  darkkhaki: '#BDB76B',
  darkmagenta: '#8B008B',
  darkolivegreen: '#556B2F',
  darkorange: '#FF8C00',
  darkorchid: '#9932CC',
  darkred: '#8B0000',
  darksalmon: '#E9967A',
  darkseagreen: '#8FBC8F',
  darkslateblue: '#483D8B',
  darkslategray: '#2F4F4F',
  darkslategrey: '#2F4F4F',
  darkturquoise: '#00CED1',
  darkviolet: '#9400D3',
  deeppink: '#FF1493',
  deepskyblue: '#00BFFF',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1E90FF',
  firebrick: '#B22222',
  floralwhite: '#FFFAF0',
  forestgreen: '#228B22',
  fuchsia: '#FF00FF',
  gainsboro: '#DCDCDC',
  ghostwhite: '#F8F8FF',
  gold: '#FFD700',
  goldenrod: '#DAA520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#ADFF2F',
  grey: '#808080',
  honeydew: '#F0FFF0',
  hotpink: '#FF69B4',
  indianred: '#CD5C5C',
  indigo: '#4B0082',
  ivory: '#FFFFF0',
  khaki: '#F0E68C',
  lavender: '#E6E6FA',
  lavenderblush: '#FFF0F5',
  lawngreen: '#7CFC00',
  lemonchiffon: '#FFFACD',
  lightblue: '#ADD8E6',
  lightcoral: '#F08080',
  lightcyan: '#E0FFFF',
  lightgoldenrodyellow: '#FAFAD2',
  lightgray: '#D3D3D3',
  lightgreen: '#90EE90',
  lightgrey: '#D3D3D3',
  lightpink: '#FFB6C1',
  lightsalmon: '#FFA07A',
  lightseagreen: '#20B2AA',
  lightskyblue: '#87CEFA',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#B0C4DE',
  lightyellow: '#FFFFE0',
  lime: '#00FF00',
  limegreen: '#32CD32',
  linen: '#FAF0E6',
  magenta: '#FF00FF',
  maroon: '#800000',
  mediumaquamarine: '#66CDAA',
  mediumblue: '#0000CD',
  mediumorchid: '#BA55D3',
  mediumpurple: '#9370DB',
  mediumseagreen: '#3CB371',
  mediumslateblue: '#7B68EE',
  mediumspringgreen: '#00FA9A',
  mediumturquoise: '#48D1CC',
  mediumvioletred: '#C71585',
  midnightblue: '#191970',
  mintcream: '#F5FFFA',
  mistyrose: '#FFE4E1',
  moccasin: '#FFE4B5',
  navajowhite: '#FFDEAD',
  navy: '#000080',
  oldlace: '#FDF5E6',
  olive: '#808000',
  olivedrab: '#6B8E23',
  orange: '#FFA500',
  orangered: '#FF4500',
  orchid: '#DA70D6',
  palegoldenrod: '#EEE8AA',
  palegreen: '#98FB98',
  paleturquoise: '#AFEEEE',
  palevioletred: '#DB7093',
  papayawhip: '#FFEFD5',
  peachpuff: '#FFDAB9',
  peru: '#CD853F',
  pink: '#FFC0CB',
  plum: '#DDA0DD',
  powderblue: '#B0E0E6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#FF0000',
  rosybrown: '#BC8F8F',
  royalblue: '#4169E1',
  saddlebrown: '#8B4513',
  salmon: '#FA8072',
  sandybrown: '#F4A460',
  seagreen: '#2E8B57',
  seashell: '#FFF5EE',
  sienna: '#A0522D',
  silver: '#C0C0C0',
  skyblue: '#87CEEB',
  slateblue: '#6A5ACD',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#FFFAFA',
  springgreen: '#00FF7F',
  steelblue: '#4682B4',
  tan: '#D2B48C',
  teal: '#008080',
  thistle: '#D8BFD8',
  tomato: '#FF6347',
  transparent: '#00000000',
  turquoise: '#40E0D0',
  violet: '#EE82EE',
  wheat: '#F5DEB3',
  white: '#FFFFFF',
  whitesmoke: '#F5F5F5',
  yellow: '#FFFF00',
  yellowgreen: '#9ACD32'
});
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/decorator.mjs

const BREAK_TRANSFORM_CHAIN = Symbol('BREAK');
const CONFIG_KEY = '__decorator_config';
function initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, {
      value: {}
    });
  }
  const config = target[CONFIG_KEY];
  if (config[propertyKey] != null) {
    return config[propertyKey];
  }
  config[propertyKey] = {
    setters: [],
    getters: []
  };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  const prevSet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set;
  const prevGet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.get;
  const getter = function () {
    var _a, _b;
    let value = prevGet ? prevGet.call(this) : this[valueStoreKey];
    for (const transformFn of (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.getters) !== null && _b !== void 0 ? _b : []) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return undefined;
      }
    }
    return value;
  };
  const setter = function (value) {
    var _a, _b;
    const setters = (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.setters) !== null && _b !== void 0 ? _b : [];
    let oldValue;
    if (setters.some(f => f.length > 2)) {
      // Lazily retrieve old value.
      oldValue = prevGet ? prevGet.call(this) : this[valueStoreKey];
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    if (prevSet) {
      prevSet.call(this, value);
    } else {
      this[valueStoreKey] = value;
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function decorator_addTransformToInstanceProperty(setTransform, getTransform) {
  return (target, propertyKeyOrSymbol) => {
    const propertyKey = propertyKeyOrSymbol.toString();
    const valueStoreKey = `__${propertyKey}`;
    const {
      getters,
      setters
    } = initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey);
    setters.push(setTransform);
    if (getTransform) {
      getters.splice(0, 0, getTransform);
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/validation.mjs



function Validate(predicate) {
  return decorator_addTransformToInstanceProperty((target, prop, v) => {
    var _a, _b, _c;
    if (predicate(v, {
      target
    })) {
      return v;
    }
    const cleanKey = prop.toString().replace(/^_*/, '');
    let targetClass = (_b = (_a = target.constructor) === null || _a === void 0 ? void 0 : _a.className) !== null && _b !== void 0 ? _b : (_c = target.constructor) === null || _c === void 0 ? void 0 : _c.name;
    if ((targetClass === null || targetClass === void 0 ? void 0 : targetClass.length) < 3) {
      targetClass = null;
    }
    const targetClassName = targetClass ? `of [${targetClass}] ` : '';
    if (predicate.message) {
      Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${JSON.stringify(v)}]; ${predicate.message}, ignoring.`);
    } else {
      Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${JSON.stringify(v)}], ignoring.`);
    }
    return BREAK_TRANSFORM_CHAIN;
  });
}
function predicateWithMessage(predicate, message) {
  predicate.message = message;
  return predicate;
}
const OPTIONAL = (v, ctx, predicate) => v === undefined || predicate(v, ctx);
const ARRAY = (length, predicate) => {
  return predicateWithMessage((v, ctx) => Array.isArray(v) && (length ? v.length === length : true) && (predicate ? v.every(e => predicate(e, ctx)) : true), `expecting an Array`);
};
const OPT_ARRAY = length => {
  return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, ARRAY(length)), 'expecting an optional Array');
};
const AND = (...predicates) => {
  return predicateWithMessage((v, ctx) => predicates.every(p => p(v, ctx)), predicates.map(p => p.message).filter(m => m != null).join(' AND '));
};
const OR = (...predicates) => {
  return predicateWithMessage((v, ctx) => predicates.some(p => p(v, ctx)), predicates.map(p => p.message).filter(m => m != null).join(' OR '));
};
const isComparable = v => {
  return v != null && !isNaN(v);
};
const LESS_THAN = otherField => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField], `expected to be less than ${otherField}`);
const GREATER_THAN = otherField => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField], `expected to be greater than ${otherField}`);
const FUNCTION = predicateWithMessage(v => typeof v === 'function', 'expecting a Function');
const OPT_FUNCTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FUNCTION), `expecting an optional Function`);
const BOOLEAN = predicateWithMessage(v => v === true || v === false, 'expecting a Boolean');
const OPT_BOOLEAN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN), 'expecting an optional Boolean');
const STRING = predicateWithMessage(v => typeof v === 'string', 'expecting a String');
const OPT_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING), 'expecting an optional String');
const DATE = predicateWithMessage(v => v instanceof Date && !isNaN(+v), 'expecting a Date object');
const OPT_DATE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATE), 'expecting an optional Date');
const DATE_ARRAY = predicateWithMessage(ARRAY(undefined, DATE), 'expecting an Array of Date objects');
const DATETIME_MS = NUMBER(0);
const OPT_DATETIME_MS = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATETIME_MS), 'expecting an optional number');
const OPT_DATE_OR_DATETIME_MS = OR(OPT_DATE, OPT_DATETIME_MS);
const colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;
const COLOR_STRING = predicateWithMessage(v => {
  if (typeof v !== 'string') {
    return false;
  }
  return Color.validColorString(v);
}, `expecting a color String. ${colorMessage}`);
const OPT_COLOR_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING), `expecting an optional color String. ${colorMessage}`);
const COLOR_STRING_ARRAY = predicateWithMessage(ARRAY(undefined, COLOR_STRING), `expecting an Array of color strings. ${colorMessage}`);
const OPT_COLOR_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING_ARRAY), `expecting an optional Array of color strings. ${colorMessage}`);
function NUMBER(min, max) {
  const message = `expecting a finite Number${(min !== undefined ? ', more than or equal to ' + min : '') + (max !== undefined ? ', less than or equal to ' + max : '')}`;
  return predicateWithMessage(v => typeof v === 'number' && Number.isFinite(v) && (min !== undefined ? v >= min : true) && (max !== undefined ? v <= max : true), message);
}
function OPT_NUMBER(min, max) {
  const message = `expecting an optional finite Number${(min !== undefined ? ', more than or equal to ' + min : '') + (max !== undefined ? ', less than or equal to ' + max : '')}`;
  return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER(min, max)), message);
}
function NUMBER_OR_NAN(min, max) {
  // Can be NaN or finite number
  const message = `expecting a finite Number${(min !== undefined ? ', more than or equal to ' + min : '') + (max !== undefined ? ', less than or equal to ' + max : '')}`;
  return predicateWithMessage(v => typeof v === 'number' && (isNaN(v) || Number.isFinite(v) && (min !== undefined ? v >= min : true) && (max !== undefined ? v <= max : true)), message);
}
const NUMBER_ARRAY = predicateWithMessage(ARRAY(undefined, NUMBER()), 'expecting an Array of numbers');
const OPT_NUMBER_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER_ARRAY), 'expecting an optional Array of numbers');
const STRING_ARRAY = predicateWithMessage(ARRAY(undefined, STRING), 'expecting an Array of strings');
const OPT_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING_ARRAY), 'expecting an optional Array of strings');
function STRING_UNION(...values) {
  const message = `expecting one of: ${values.join(', ')}`;
  return predicateWithMessage(v => typeof v === 'string' && values.indexOf(v) >= 0, message);
}
const BOOLEAN_ARRAY = predicateWithMessage(ARRAY(undefined, BOOLEAN), 'expecting an Array of boolean values');
const OPT_BOOLEAN_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN_ARRAY), 'expecting an optional Array of boolean values');
const FONT_WEIGHTS = ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900'];
const FONT_STYLE = predicateWithMessage(v => v === 'normal' || v === 'italic' || v === 'oblique', `expecting a font style keyword such as 'normal', 'italic' or 'oblique'`);
const OPT_FONT_STYLE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_STYLE), `expecting an optional font style keyword such as 'normal', 'italic' or 'oblique'`);
const FONT_WEIGHT = predicateWithMessage(v => FONT_WEIGHTS.includes(v), `expecting a font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);
const OPT_FONT_WEIGHT = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_WEIGHT), `expecting an optional font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);
const LINE_DASH = predicateWithMessage(ARRAY(undefined, NUMBER(0)), 'expecting an Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');
const OPT_LINE_DASH = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_DASH), 'expecting an optional Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');
const LINE_CAPS = ['butt', 'round', 'square'];
const LINE_CAP = predicateWithMessage(v => LINE_CAPS.includes(v), `expecting a line cap keyword such as 'butt', 'round' or 'square'`);
const OPT_LINE_CAP = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_CAP), `expecting an optional line cap keyword such as 'butt', 'round' or 'square'`);
const LINE_JOINS = ['round', 'bevel', 'miter'];
const LINE_JOIN = predicateWithMessage(v => LINE_JOINS.includes(v), `expecting a line join keyword such as 'round', 'bevel' or 'miter'`);
const OPT_LINE_JOIN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_JOIN), `expecting an optional line join keyword such as 'round', 'bevel' or 'miter'`);
const POSITIONS = ['top', 'right', 'bottom', 'left'];
const POSITION = predicateWithMessage(v => POSITIONS.includes(v), `expecting a position keyword such as 'top', 'right', 'bottom' or 'left`);
const INTERACTION_RANGES = ['exact', 'nearest'];
const INTERACTION_RANGE = predicateWithMessage(v => typeof v === 'number' && Number.isFinite(v) || INTERACTION_RANGES.includes(v), `expecting an interaction range of 'exact', 'nearest' or a number`);
const TEXT_WRAPS = ['never', 'always', 'hyphenate', 'on-space'];
const TEXT_WRAP = predicateWithMessage(v => TEXT_WRAPS.includes(v), `expecting a text wrap strategy keyword such as 'never', 'always', 'hyphenate', 'on-space'`);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/layers.mjs
/**
 * Constants to declare the expected nominal zIndex for all types of layer in chart rendering.
 */
var Layers;
(function (Layers) {
  Layers[Layers["SERIES_BACKGROUND_ZINDEX"] = -10] = "SERIES_BACKGROUND_ZINDEX";
  Layers[Layers["AXIS_GRID_ZINDEX"] = 0] = "AXIS_GRID_ZINDEX";
  Layers[Layers["AXIS_ZINDEX"] = 20] = "AXIS_ZINDEX";
  Layers[Layers["SERIES_CROSSLINE_RANGE_ZINDEX"] = 30] = "SERIES_CROSSLINE_RANGE_ZINDEX";
  Layers[Layers["SERIES_LAYER_ZINDEX"] = 500] = "SERIES_LAYER_ZINDEX";
  Layers[Layers["SERIES_CROSSHAIR_ZINDEX"] = 1000] = "SERIES_CROSSHAIR_ZINDEX";
  Layers[Layers["SERIES_LABEL_ZINDEX"] = 1500] = "SERIES_LABEL_ZINDEX";
  Layers[Layers["SERIES_CROSSLINE_LINE_ZINDEX"] = 2500] = "SERIES_CROSSLINE_LINE_ZINDEX";
  Layers[Layers["LEGEND_ZINDEX"] = 3000] = "LEGEND_ZINDEX";
})(Layers || (Layers = {}));
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chartAxisDirection.mjs
var ChartAxisDirection;
(function (ChartAxisDirection) {
  ChartAxisDirection["X"] = "x";
  ChartAxisDirection["Y"] = "y";
})(ChartAxisDirection || (ChartAxisDirection = {}));
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/data/utilFunctions.mjs
function utilFunctions_extendDomain(values, domain = [Infinity, -Infinity]) {
  for (const value of values) {
    if (typeof value !== 'number') {
      continue;
    }
    if (value < domain[0]) {
      domain[0] = value;
    }
    if (value > domain[1]) {
      domain[1] = value;
    }
  }
  return domain;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/data/dataModel.mjs





function toKeyString(keys) {
  return keys.map(v => {
    if (v == null) {
      return v;
    } else if (typeof v === 'number' || typeof v === 'string' || typeof v === 'boolean') {
      return v;
    } else if (typeof v === 'object') {
      return JSON.stringify(v);
    }
    return v;
  }).join('-');
}
function round(val) {
  const accuracy = 10000;
  if (Number.isInteger(val)) {
    return val;
  } else if (Math.abs(val) > accuracy) {
    return Math.trunc(val);
  }
  return Math.round(val * accuracy) / accuracy;
}
function fixNumericExtent(extent) {
  if (extent === undefined) {
    // Don't return a range, there is no range.
    return [];
  }
  let [min, max] = extent;
  min = +min;
  max = +max;
  if (min === 0 && max === 0) {
    // domain has zero length and the single valid value is 0. Use the default of [0, 1].
    return [0, 1];
  }
  if (min === Infinity && max === -Infinity) {
    // There's no data in the domain.
    return [];
  }
  if (min === Infinity) {
    min = 0;
  }
  if (max === -Infinity) {
    max = 0;
  }
  if (!(isNumber(min) && isNumber(max))) {
    return [];
  }
  return [min, max];
}
const INVALID_VALUE = Symbol('invalid');
class DataModel {
  constructor(opts) {
    var _a;
    const {
      props
    } = opts;
    // Validate that keys appear before values in the definitions, as output ordering depends
    // on configuration ordering, but we process keys before values.
    let keys = true;
    for (const next of props) {
      if (next.type === 'key' && !keys) {
        throw new Error('AG Charts - internal config error: keys must come before values.');
      }
      if (next.type === 'value' && keys) {
        keys = false;
      }
    }
    this.opts = Object.assign({
      dataVisible: true
    }, opts);
    this.keys = props.filter(def => def.type === 'key').map((def, index) => Object.assign(Object.assign({}, def), {
      index,
      missing: false
    }));
    this.values = props.filter(def => def.type === 'value').map((def, index) => Object.assign(Object.assign({}, def), {
      index,
      missing: false
    }));
    this.aggregates = props.filter(def => def.type === 'aggregate');
    this.groupProcessors = props.filter(def => def.type === 'group-value-processor');
    this.propertyProcessors = props.filter(def => def.type === 'property-value-processor');
    this.reducers = props.filter(def => def.type === 'reducer');
    this.processors = props.filter(def => def.type === 'processor');
    for (const {
      properties
    } of (_a = this.aggregates) !== null && _a !== void 0 ? _a : []) {
      if (properties.length === 0) continue;
      for (const property of properties) {
        if (typeof property === 'string' && !this.values.some(def => def.property === property)) {
          throw new Error(`AG Charts - internal config error: aggregate properties must match defined properties (${properties}).`);
        }
        if (typeof property !== 'string' && !this.values.some(def => def.id === property.id)) {
          throw new Error(`AG Charts - internal config error: aggregate properties must match defined properties (${properties}).`);
        }
      }
    }
  }
  resolveProcessedDataIndexById(searchId) {
    const {
      keys,
      values
    } = this;
    const def = [...keys, ...values].find(({
      id
    }) => id === searchId);
    if (!def) return undefined;
    if ((def === null || def === void 0 ? void 0 : def.type) === 'key' || (def === null || def === void 0 ? void 0 : def.type) === 'value') {
      return {
        type: def.type,
        index: def.index
      };
    }
  }
  resolveProcessedDataDefById(searchId) {
    const {
      keys,
      values
    } = this;
    const def = [...keys, ...values].find(({
      id
    }) => id === searchId);
    if (!def) return undefined;
    return def;
  }
  getDomain(searchId, processedData) {
    const idx = this.resolveProcessedDataIndexById(searchId);
    if (!idx) {
      return [];
    }
    return processedData.domain[idx.type === 'key' ? 'keys' : 'values'][idx.index];
  }
  processData(data) {
    const {
      opts: {
        groupByKeys,
        groupByFn
      },
      aggregates,
      groupProcessors,
      reducers,
      processors,
      propertyProcessors
    } = this;
    const start = performance.now();
    for (const def of [...this.keys, ...this.values]) {
      def.missing = false;
    }
    if (groupByKeys && this.keys.length === 0) {
      return undefined;
    }
    let processedData = this.extractData(data);
    if (groupByKeys) {
      processedData = this.groupData(processedData);
    } else if (groupByFn) {
      processedData = this.groupData(processedData, groupByFn(processedData));
    }
    if (groupProcessors.length > 0) {
      this.postProcessGroups(processedData);
    }
    if (aggregates.length > 0) {
      this.aggregateData(processedData);
    }
    if (propertyProcessors.length > 0) {
      this.postProcessProperties(processedData);
    }
    if (reducers.length > 0) {
      this.reduceData(processedData);
    }
    if (processors.length > 0) {
      this.postProcessData(processedData);
    }
    for (const def of [...this.keys, ...this.values]) {
      if (def.missing) {
        Logger.warnOnce(`the key '${def.property}' was not found in at least one data element.`);
      }
    }
    const end = performance.now();
    processedData.time = end - start;
    if (DataModel.DEBUG()) {
      logProcessedData(processedData);
    }
    return processedData;
  }
  valueIdxLookup(prop) {
    let result;
    if (typeof prop === 'string') {
      result = this.values.findIndex(def => def.property === prop);
    } else {
      result = this.values.findIndex(def => def.id === prop.id);
    }
    if (result >= 0) {
      return result;
    }
    throw new Error('AG Charts - configuration error, unknown property: ' + prop);
  }
  extractData(data) {
    const {
      keys: keyDefs,
      values: valueDefs,
      opts: {
        dataVisible
      }
    } = this;
    const {
      dataDomain,
      processValue
    } = this.initDataDomainProcessor();
    const resultData = new Array(dataVisible ? data.length : 0);
    let resultDataIdx = 0;
    for (const datum of data) {
      const keys = dataVisible ? new Array(keyDefs.length) : undefined;
      let keyIdx = 0;
      let key;
      for (const def of keyDefs) {
        key = processValue(def, datum, key);
        if (key === INVALID_VALUE) break;
        if (keys) {
          keys[keyIdx++] = key;
        }
      }
      if (key === INVALID_VALUE) continue;
      const values = dataVisible && valueDefs.length > 0 ? new Array(valueDefs.length) : undefined;
      let valueIdx = 0;
      let value;
      for (const def of valueDefs) {
        value = processValue(def, datum, value);
        if (value === INVALID_VALUE) break;
        if (values) {
          values[valueIdx++] = value;
        }
      }
      if (value === INVALID_VALUE) continue;
      if (dataVisible) {
        resultData[resultDataIdx++] = {
          datum,
          keys,
          values
        };
      }
    }
    resultData.length = resultDataIdx;
    const propertyDomain = def => {
      var _a;
      const result = dataDomain.get((_a = def.id) !== null && _a !== void 0 ? _a : def.property).domain;
      if (Array.isArray(result) && result[0] > result[1]) {
        // Ignore starting values.
        return [];
      }
      return [...result];
    };
    return {
      type: 'ungrouped',
      data: resultData,
      domain: {
        keys: keyDefs.map(def => propertyDomain(def)),
        values: valueDefs.map(def => propertyDomain(def))
      },
      indices: {
        keys: keyDefs.reduce((r, {
          property,
          index
        }) => {
          r[property] = index;
          return r;
        }, {}),
        values: valueDefs.reduce((r, {
          property,
          index
        }) => {
          r[property] = index;
          return r;
        }, {})
      },
      defs: {
        keys: keyDefs,
        values: valueDefs
      },
      time: 0
    };
  }
  groupData(data, groupingFn) {
    const processedData = new Map();
    for (const dataEntry of data.data) {
      const {
        keys,
        values,
        datum
      } = dataEntry;
      const group = groupingFn ? groupingFn(dataEntry) : keys;
      const groupStr = toKeyString(group);
      if (processedData.has(groupStr)) {
        const existingData = processedData.get(groupStr);
        existingData.values.push(values);
        existingData.datum.push(datum);
      } else {
        processedData.set(groupStr, {
          keys: group,
          values: [values],
          datum: [datum]
        });
      }
    }
    const resultData = new Array(processedData.size);
    const resultGroups = new Array(processedData.size);
    let dataIndex = 0;
    for (const [, {
      keys,
      values,
      datum
    }] of processedData.entries()) {
      resultGroups[dataIndex] = keys;
      resultData[dataIndex++] = {
        keys,
        values,
        datum
      };
    }
    return Object.assign(Object.assign({}, data), {
      type: 'grouped',
      data: resultData,
      domain: Object.assign(Object.assign({}, data.domain), {
        groups: resultGroups
      })
    });
  }
  aggregateData(processedData) {
    var _a, _b, _c, _d, _e, _f, _g;
    const {
      aggregates: aggDefs
    } = this;
    if (!aggDefs) return;
    const resultAggValues = aggDefs.map(() => [Infinity, -Infinity]);
    const resultAggValueIndices = aggDefs.map(defs => defs.properties.map(prop => this.valueIdxLookup(prop)));
    const resultAggFns = aggDefs.map(def => def.aggregateFunction);
    const resultGroupAggFns = aggDefs.map(def => def.groupAggregateFunction);
    const resultFinalFns = aggDefs.map(def => def.finalFunction);
    for (const group of processedData.data) {
      let {
        values
      } = group;
      (_a = group.aggValues) !== null && _a !== void 0 ? _a : group.aggValues = new Array(resultAggValueIndices.length);
      if (processedData.type === 'ungrouped') {
        values = [values];
      }
      let resultIdx = 0;
      for (const indices of resultAggValueIndices) {
        let groupAggValues = (_c = (_b = resultGroupAggFns[resultIdx]) === null || _b === void 0 ? void 0 : _b.call(resultGroupAggFns)) !== null && _c !== void 0 ? _c : utilFunctions_extendDomain([]);
        for (const distinctValues of values) {
          const valuesToAgg = indices.map(valueIdx => distinctValues[valueIdx]);
          const valuesAgg = resultAggFns[resultIdx](valuesToAgg, group.keys);
          if (valuesAgg) {
            groupAggValues = (_e = (_d = resultGroupAggFns[resultIdx]) === null || _d === void 0 ? void 0 : _d.call(resultGroupAggFns, valuesAgg, groupAggValues)) !== null && _e !== void 0 ? _e : utilFunctions_extendDomain(valuesAgg, groupAggValues);
          }
        }
        const finalValues = ((_g = (_f = resultFinalFns[resultIdx]) === null || _f === void 0 ? void 0 : _f.call(resultFinalFns, groupAggValues)) !== null && _g !== void 0 ? _g : groupAggValues).map(v => round(v));
        utilFunctions_extendDomain(finalValues, resultAggValues[resultIdx]);
        group.aggValues[resultIdx++] = finalValues;
      }
    }
    processedData.domain.aggValues = resultAggValues;
  }
  postProcessGroups(processedData) {
    const {
      groupProcessors
    } = this;
    if (!groupProcessors) return;
    for (const processor of groupProcessors) {
      const valueIndexes = processor.properties.map(p => this.valueIdxLookup(p));
      const adjustFn = processor.adjust();
      if (processedData.type === 'grouped') {
        for (const group of processedData.data) {
          for (const values of group.values) {
            if (values) {
              adjustFn(values, valueIndexes);
            }
          }
        }
      } else {
        for (const group of processedData.data) {
          if (group.values) {
            adjustFn(group.values, valueIndexes);
          }
        }
      }
    }
  }
  postProcessProperties(processedData) {
    const {
      propertyProcessors
    } = this;
    if (!propertyProcessors) return;
    for (const {
      adjust,
      property
    } of propertyProcessors) {
      adjust()(processedData, this.valueIdxLookup(property));
    }
  }
  reduceData(processedData) {
    var _a;
    const {
      reducers: reducerDefs
    } = this;
    const reducers = reducerDefs.map(def => def.reducer());
    const accValues = reducerDefs.map(def => def.initialValue);
    for (const group of processedData.data) {
      let reducerIndex = 0;
      for (const reducer of reducers) {
        accValues[reducerIndex] = reducer(accValues[reducerIndex], group);
        reducerIndex++;
      }
    }
    for (let accIdx = 0; accIdx < accValues.length; accIdx++) {
      (_a = processedData.reduced) !== null && _a !== void 0 ? _a : processedData.reduced = {};
      processedData.reduced[reducerDefs[accIdx].property] = accValues[accIdx];
    }
  }
  postProcessData(processedData) {
    var _a;
    const {
      processors: processorDefs
    } = this;
    for (const def of processorDefs) {
      (_a = processedData.reduced) !== null && _a !== void 0 ? _a : processedData.reduced = {};
      processedData.reduced[def.property] = def.calculate(processedData);
    }
  }
  initDataDomainProcessor() {
    const {
      keys: keyDefs,
      values: valueDefs
    } = this;
    const dataDomain = new Map();
    const processorFns = new Map();
    const initDataDomainKey = (key, type, updateDataDomain) => {
      if (type === 'category') {
        updateDataDomain.set(key, {
          type,
          domain: new Set()
        });
      } else {
        updateDataDomain.set(key, {
          type,
          domain: [Infinity, -Infinity]
        });
      }
    };
    const initDataDomain = (updateDataDomain = dataDomain) => {
      keyDefs.forEach(def => {
        var _a;
        return initDataDomainKey((_a = def.id) !== null && _a !== void 0 ? _a : def.property, def.valueType, updateDataDomain);
      });
      valueDefs.forEach(def => {
        var _a;
        return initDataDomainKey((_a = def.id) !== null && _a !== void 0 ? _a : def.property, def.valueType, updateDataDomain);
      });
      return updateDataDomain;
    };
    initDataDomain();
    const processValue = (def, datum, previousDatum) => {
      var _a, _b, _c, _d, _e;
      const valueInDatum = (def.property in datum);
      const missingValueDef = ('missingValue' in def);
      if (!def.missing && !valueInDatum && !missingValueDef) {
        def.missing = true;
      }
      if (!dataDomain.has((_a = def.id) !== null && _a !== void 0 ? _a : def.property)) {
        initDataDomain(dataDomain);
      }
      let value = valueInDatum ? datum[def.property] : def.missingValue;
      if (valueInDatum) {
        const valid = (_c = (_b = def.validation) === null || _b === void 0 ? void 0 : _b.call(def, value)) !== null && _c !== void 0 ? _c : true;
        if (!valid) {
          if ('invalidValue' in def) {
            value = def.invalidValue;
          } else {
            return INVALID_VALUE;
          }
        }
      }
      if (def.processor) {
        if (!processorFns.has(def)) {
          processorFns.set(def, def.processor());
        }
        value = (_d = processorFns.get(def)) === null || _d === void 0 ? void 0 : _d(value, previousDatum !== INVALID_VALUE ? previousDatum : undefined);
      }
      const meta = dataDomain.get((_e = def.id) !== null && _e !== void 0 ? _e : def.property);
      if ((meta === null || meta === void 0 ? void 0 : meta.type) === 'category') {
        meta.domain.add(value);
      } else if ((meta === null || meta === void 0 ? void 0 : meta.type) === 'range') {
        if (meta.domain[0] > value) {
          meta.domain[0] = value;
        }
        if (meta.domain[1] < value) {
          meta.domain[1] = value;
        }
      }
      return value;
    };
    return {
      dataDomain,
      processValue,
      initDataDomain
    };
  }
}
DataModel.DEBUG = () => {
  var _a;
  return (_a = [true, 'data-model'].includes(windowValue('agChartsDebug'))) !== null && _a !== void 0 ? _a : false;
};
function logProcessedData(processedData) {
  var _a, _b;
  const log = (name, data) => {
    if (data.length > 0) {
      // eslint-disable-next-line no-console
      console.log(name);
      // eslint-disable-next-line no-console
      console.table(data);
    }
  };
  // eslint-disable-next-line no-console
  console.log({
    processedData
  });
  log('Key Domains', processedData.domain.keys);
  log('Group Domains', (_a = processedData.domain.groups) !== null && _a !== void 0 ? _a : []);
  log('Value Domains', processedData.domain.values);
  log('Aggregate Domains', (_b = processedData.domain.aggValues) !== null && _b !== void 0 ? _b : []);
  if (processedData.type === 'grouped') {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      var _a, _b;
      const keys = (_a = next.keys) !== null && _a !== void 0 ? _a : [];
      const aggValues = (_b = next.aggValues) !== null && _b !== void 0 ? _b : [];
      const skipKeys = next.keys.map(() => undefined);
      const skipAggValues = aggValues === null || aggValues === void 0 ? void 0 : aggValues.map(() => undefined);
      acc.push(...next.values.map((v, i) => [...(i === 0 ? keys : skipKeys), ...(v !== null && v !== void 0 ? v : []), ...(i == 0 ? aggValues : skipAggValues)]));
      return acc;
    }, []);
    log('Values', flattenedValues);
  } else {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      var _a;
      const aggValues = (_a = next.aggValues) !== null && _a !== void 0 ? _a : [];
      acc.push([...next.keys, ...next.values, ...aggValues]);
      return acc;
    }, []);
    log('Values', flattenedValues);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/deprecation.mjs


function createDeprecationWarning() {
  return (key, message) => {
    const msg = [`Property [${key}] is deprecated.`, message].filter(v => v != null).join(' ');
    Logger.warnOnce(msg);
  };
}
function Deprecated(message, opts) {
  const def = opts === null || opts === void 0 ? void 0 : opts.default;
  const warn = createDeprecationWarning();
  return decorator_addTransformToInstanceProperty((_, key, value) => {
    if (value !== def) {
      warn(key.toString(), message);
    }
    return value;
  });
}
function DeprecatedAndRenamedTo(newPropName, mapValue) {
  const warnDeprecated = createDeprecationWarning();
  return decorator_addTransformToInstanceProperty((target, key, value) => {
    if (value !== target[newPropName]) {
      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
      target[newPropName] = mapValue ? mapValue(value) : value;
    }
    return BREAK_TRANSFORM_CHAIN;
  }, (target, key) => {
    warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
    return target[newPropName];
  });
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/tooltip/tooltip.mjs

var tooltip_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



const DEFAULT_TOOLTIP_CLASS = 'ag-chart-tooltip';
const defaultTooltipCss = `
.${DEFAULT_TOOLTIP_CLASS} {
    transition: transform 0.1s ease;
    display: table;
    position: fixed;
    left: 0px;
    top: 0px;
    white-space: nowrap;
    z-index: 99999;
    font: 12px Verdana, sans-serif;
    color: black;
    background: rgb(244, 244, 244);
    border-radius: 5px;
    box-shadow: 0 0 1px rgba(3, 3, 3, 0.7), 0.5vh 0.5vh 1vh rgba(3, 3, 3, 0.25);
}

.${DEFAULT_TOOLTIP_CLASS}-no-interaction {
    pointer-events: none;
    user-select: none;
}

.${DEFAULT_TOOLTIP_CLASS}-no-animation {
    transition: none !important;
}

.${DEFAULT_TOOLTIP_CLASS}-hidden {
    visibility: hidden;
}

.${DEFAULT_TOOLTIP_CLASS}-title {
    font-weight: bold;
    padding: 7px;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    color: white;
    background-color: #888888;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
}

.${DEFAULT_TOOLTIP_CLASS}-content {
    padding: 7px;
    line-height: 1.7em;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    overflow: hidden;
}

.${DEFAULT_TOOLTIP_CLASS}-content:empty {
    padding: 0;
    height: 7px;
}

.${DEFAULT_TOOLTIP_CLASS}-arrow::before {
    content: "";

    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);

    border: 6px solid #989898;

    border-left-color: transparent;
    border-right-color: transparent;
    border-top-color: #989898;
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.${DEFAULT_TOOLTIP_CLASS}-arrow::after {
    content: "";

    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);

    border: 5px solid black;

    border-left-color: transparent;
    border-right-color: transparent;
    border-top-color: rgb(244, 244, 244);
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.ag-chart-wrapper {
    box-sizing: border-box;
    overflow: hidden;
}
`;
function toTooltipHtml(input, defaults) {
  var _a, _b, _c, _d;
  if (typeof input === 'string') {
    return input;
  }
  defaults = defaults !== null && defaults !== void 0 ? defaults : {};
  const {
    content = (_a = defaults.content) !== null && _a !== void 0 ? _a : '',
    title = (_b = defaults.title) !== null && _b !== void 0 ? _b : undefined,
    color = (_c = defaults.color) !== null && _c !== void 0 ? _c : 'white',
    backgroundColor = (_d = defaults.backgroundColor) !== null && _d !== void 0 ? _d : '#888'
  } = input;
  const titleHtml = title ? `<div class="${DEFAULT_TOOLTIP_CLASS}-title"
        style="color: ${color}; background-color: ${backgroundColor}">${title}</div>` : '';
  return `${titleHtml}<div class="${DEFAULT_TOOLTIP_CLASS}-content">${content}</div>`;
}
const POSITION_TYPES = ['pointer', 'node'];
const POSITION_TYPE = predicateWithMessage(v => POSITION_TYPES.includes(v), `expecting a position type keyword such as 'pointer' or 'node'`);
class TooltipPosition {
  constructor() {
    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */
    this.type = 'pointer';
    /** The horizontal offset in pixels for the position of the tooltip. */
    this.xOffset = 0;
    /** The vertical offset in pixels for the position of the tooltip. */
    this.yOffset = 0;
  }
}
tooltip_decorate([Validate(POSITION_TYPE)], TooltipPosition.prototype, "type", void 0);
tooltip_decorate([Validate(NUMBER())], TooltipPosition.prototype, "xOffset", void 0);
tooltip_decorate([Validate(NUMBER())], TooltipPosition.prototype, "yOffset", void 0);
class Tooltip {
  constructor(canvasElement, document, container) {
    this.enableInteraction = false;
    this.enabled = true;
    this.showArrow = undefined;
    this.class = undefined;
    this.lastClass = undefined;
    this.delay = 0;
    this.range = 'nearest';
    this.position = new TooltipPosition();
    this.showTimeout = 0;
    this._showArrow = true;
    this.tooltipRoot = container;
    const element = document.createElement('div');
    this.element = this.tooltipRoot.appendChild(element);
    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);
    this.canvasElement = canvasElement;
    // Detect when the chart becomes invisible and hide the tooltip as well.
    if (window.IntersectionObserver) {
      const observer = new IntersectionObserver(entries => {
        for (const entry of entries) {
          if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {
            this.toggle(false);
          }
        }
      }, {
        root: this.tooltipRoot
      });
      observer.observe(this.canvasElement);
      this.observer = observer;
    }
    if (Tooltip.tooltipDocuments.indexOf(document) < 0) {
      const styleElement = document.createElement('style');
      styleElement.innerHTML = defaultTooltipCss;
      // Make sure the default tooltip style goes before other styles so it can be overridden.
      document.head.insertBefore(styleElement, document.head.querySelector('style'));
      Tooltip.tooltipDocuments.push(document);
    }
  }
  destroy() {
    const {
      parentNode
    } = this.element;
    if (parentNode) {
      parentNode.removeChild(this.element);
    }
    if (this.observer) {
      this.observer.unobserve(this.canvasElement);
    }
  }
  isVisible() {
    const {
      element
    } = this;
    return !element.classList.contains(DEFAULT_TOOLTIP_CLASS + '-hidden');
  }
  updateClass(visible, showArrow) {
    const {
      element,
      class: newClass,
      lastClass,
      enableInteraction
    } = this;
    const wasVisible = this.isVisible();
    const toggleClass = (name, include) => {
      const className = `${DEFAULT_TOOLTIP_CLASS}-${name}`;
      if (include) {
        element.classList.add(className);
      } else {
        element.classList.remove(className);
      }
    };
    toggleClass('no-animation', !wasVisible && !!visible); // No animation on first show.
    toggleClass('no-interaction', !enableInteraction); // Prevent interaction.
    toggleClass('hidden', !visible); // Hide if not visible.
    toggleClass('arrow', !!showArrow); // Add arrow if tooltip is constrained.
    if (newClass !== lastClass) {
      if (lastClass) {
        element.classList.remove(lastClass);
      }
      if (newClass) {
        element.classList.add(newClass);
      }
      this.lastClass = newClass;
    }
  }
  /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */
  show(meta, html, instantly = false) {
    var _a, _b, _c, _d, _e, _f, _g;
    const {
      element,
      canvasElement
    } = this;
    if (html !== undefined) {
      element.innerHTML = html;
    } else if (!element.innerHTML) {
      return;
    }
    const limit = (low, actual, high) => {
      return Math.max(Math.min(actual, high), low);
    };
    const xOffset = (_b = (_a = meta.position) === null || _a === void 0 ? void 0 : _a.xOffset) !== null && _b !== void 0 ? _b : 0;
    const yOffset = (_d = (_c = meta.position) === null || _c === void 0 ? void 0 : _c.yOffset) !== null && _d !== void 0 ? _d : 0;
    const canvasRect = canvasElement.getBoundingClientRect();
    const naiveLeft = canvasRect.left + meta.offsetX - element.clientWidth / 2 + xOffset;
    const naiveTop = canvasRect.top + meta.offsetY - element.clientHeight - 8 + yOffset;
    const windowBounds = this.getWindowBoundingBox();
    const maxLeft = windowBounds.x + windowBounds.width - element.clientWidth - 1;
    const maxTop = windowBounds.y + windowBounds.height - element.clientHeight;
    const left = limit(windowBounds.x, naiveLeft, maxLeft);
    const top = limit(windowBounds.y, naiveTop, maxTop);
    const constrained = left !== naiveLeft || top !== naiveTop;
    const defaultShowArrow = !constrained && !xOffset && !yOffset;
    const showArrow = (_f = (_e = meta.showArrow) !== null && _e !== void 0 ? _e : this.showArrow) !== null && _f !== void 0 ? _f : defaultShowArrow;
    this.updateShowArrow(showArrow);
    element.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;
    this.enableInteraction = (_g = meta.enableInteraction) !== null && _g !== void 0 ? _g : false;
    if (this.delay > 0 && !instantly) {
      this.toggle(false);
      this.showTimeout = window.setTimeout(() => {
        this.toggle(true);
      }, this.delay);
      return;
    }
    this.toggle(true);
  }
  getWindowBoundingBox() {
    return new BBox(0, 0, window.innerWidth, window.innerHeight);
  }
  toggle(visible) {
    if (!visible) {
      window.clearTimeout(this.showTimeout);
    }
    this.updateClass(visible, this._showArrow);
  }
  pointerLeftOntoTooltip(event) {
    var _a;
    if (!this.enableInteraction) return false;
    const classList = (_a = event.sourceEvent.relatedTarget) === null || _a === void 0 ? void 0 : _a.classList;
    const classes = ['', '-title', '-content'];
    const classListContains = Boolean(classes.filter(c => classList === null || classList === void 0 ? void 0 : classList.contains(`${DEFAULT_TOOLTIP_CLASS}${c}`)));
    return classList !== undefined && classListContains;
  }
  updateShowArrow(show) {
    this._showArrow = show;
  }
}
Tooltip.tooltipDocuments = [];
tooltip_decorate([Validate(BOOLEAN)], Tooltip.prototype, "enabled", void 0);
tooltip_decorate([Validate(OPT_BOOLEAN)], Tooltip.prototype, "showArrow", void 0);
tooltip_decorate([Validate(OPT_STRING)], Tooltip.prototype, "class", void 0);
tooltip_decorate([Validate(NUMBER(0))], Tooltip.prototype, "delay", void 0);
tooltip_decorate([DeprecatedAndRenamedTo('range', value => value ? 'nearest' : 'exact')], Tooltip.prototype, "tracking", void 0);
tooltip_decorate([Validate(INTERACTION_RANGE)], Tooltip.prototype, "range", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/data/aggregateFunctions.mjs

function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== 'number') {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function sum(props) {
  const result = {
    properties: props,
    type: 'aggregate',
    aggregateFunction: values => sumValues(values)
  };
  return result;
}
function groupSum(props) {
  return {
    type: 'aggregate',
    properties: props,
    aggregateFunction: values => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      var _a, _b;
      acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;
      acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;
      return acc;
    }
  };
}
function range(props) {
  const result = {
    properties: props,
    type: 'aggregate',
    aggregateFunction: values => extendDomain(values)
  };
  return result;
}
function count() {
  const result = {
    properties: [],
    type: 'aggregate',
    aggregateFunction: () => [0, 1]
  };
  return result;
}
function groupCount() {
  return {
    type: 'aggregate',
    properties: [],
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      var _a, _b;
      acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;
      acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;
      return acc;
    }
  };
}
function average(props) {
  const result = {
    properties: props,
    type: 'aggregate',
    aggregateFunction: values => sumValues(values).map(v => v / values.length)
  };
  return result;
}
function groupAverage(props) {
  const result = {
    properties: props,
    type: 'aggregate',
    aggregateFunction: values => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      var _a, _b;
      acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;
      acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result = acc[0] + acc[1];
      if (result >= 0) {
        return [0, result / acc[2]];
      }
      return [result / acc[2], 0];
    }
  };
  return result;
}
function aggregateFunctions_area(props, aggFn) {
  const result = {
    properties: props,
    type: 'aggregate',
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map(v => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue() {
  return () => {
    let value = 0;
    return datum => {
      if (typeof datum !== 'number') return datum;
      if (isNaN(datum)) return datum;
      value += datum;
      return value;
    };
  };
}
function aggregateFunctions_trailingAccumulatedValue() {
  return () => {
    let value = 0;
    return datum => {
      if (typeof datum !== 'number') return datum;
      if (isNaN(datum)) return datum;
      const trailingValue = value;
      value += datum;
      return trailingValue;
    };
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/series.mjs

var series_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










/** Modes of matching user interactions to rendered nodes (e.g. hover or click) */
var SeriesNodePickMode;
(function (SeriesNodePickMode) {
  /** Pick matches based upon pick coordinates being inside a matching shape/marker. */
  SeriesNodePickMode[SeriesNodePickMode["EXACT_SHAPE_MATCH"] = 0] = "EXACT_SHAPE_MATCH";
  /** Pick matches by nearest category/X-axis value, then distance within that category/X-value. */
  SeriesNodePickMode[SeriesNodePickMode["NEAREST_BY_MAIN_AXIS_FIRST"] = 1] = "NEAREST_BY_MAIN_AXIS_FIRST";
  /** Pick matches by nearest category value, then distance within that category. */
  SeriesNodePickMode[SeriesNodePickMode["NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST"] = 2] = "NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST";
  /** Pick matches based upon distance to ideal position */
  SeriesNodePickMode[SeriesNodePickMode["NEAREST_NODE"] = 3] = "NEAREST_NODE";
})(SeriesNodePickMode || (SeriesNodePickMode = {}));
function keyProperty(propName, continuous, opts = {}) {
  const result = Object.assign({
    property: propName,
    type: 'key',
    valueType: continuous ? 'range' : 'category',
    validation: v => checkDatum(v, continuous) != null
  }, opts);
  return result;
}
function valueProperty(propName, continuous, opts = {}) {
  const result = Object.assign({
    property: propName,
    type: 'value',
    valueType: continuous ? 'range' : 'category',
    validation: v => checkDatum(v, continuous) != null
  }, opts);
  return result;
}
function rangedValueProperty(propName, opts = {}) {
  const {
      min = -Infinity,
      max = Infinity
    } = opts,
    defOpts = __rest(opts, ["min", "max"]);
  return Object.assign({
    type: 'value',
    property: propName,
    valueType: 'range',
    validation: v => checkDatum(v, true) != null,
    processor: () => datum => {
      if (typeof datum !== 'number') return datum;
      if (isNaN(datum)) return datum;
      return Math.min(Math.max(datum, min), max);
    }
  }, defOpts);
}
function accumulativeValueProperty(propName, continuous, opts = {}) {
  const result = Object.assign(Object.assign({}, valueProperty(propName, continuous, opts)), {
    processor: accumulatedValue()
  });
  return result;
}
function trailingAccumulatedValueProperty(propName, continuous, opts = {}) {
  const result = Object.assign(Object.assign({}, valueProperty(propName, continuous, opts)), {
    processor: trailingAccumulatedValue()
  });
  return result;
}
class SeriesNodeBaseClickEvent {
  constructor(nativeEvent, datum, series) {
    this.type = 'nodeClick';
    this.event = nativeEvent;
    this.datum = datum.datum;
    this.seriesId = series.id;
  }
}
class SeriesNodeClickEvent extends SeriesNodeBaseClickEvent {}
class SeriesNodeDoubleClickEvent extends SeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeDoubleClick';
  }
}
class SeriesItemHighlightStyle {
  constructor() {
    this.fill = 'yellow';
    this.fillOpacity = undefined;
    this.stroke = undefined;
    this.strokeWidth = undefined;
  }
}
series_decorate([Validate(OPT_COLOR_STRING)], SeriesItemHighlightStyle.prototype, "fill", void 0);
series_decorate([Validate(OPT_NUMBER(0, 1))], SeriesItemHighlightStyle.prototype, "fillOpacity", void 0);
series_decorate([Validate(OPT_COLOR_STRING)], SeriesItemHighlightStyle.prototype, "stroke", void 0);
series_decorate([Validate(OPT_NUMBER(0))], SeriesItemHighlightStyle.prototype, "strokeWidth", void 0);
class SeriesHighlightStyle {
  constructor() {
    this.strokeWidth = undefined;
    this.dimOpacity = undefined;
    this.enabled = undefined;
  }
}
series_decorate([Validate(OPT_NUMBER(0))], SeriesHighlightStyle.prototype, "strokeWidth", void 0);
series_decorate([Validate(OPT_NUMBER(0, 1))], SeriesHighlightStyle.prototype, "dimOpacity", void 0);
series_decorate([Validate(OPT_BOOLEAN)], SeriesHighlightStyle.prototype, "enabled", void 0);
class TextHighlightStyle {
  constructor() {
    this.color = 'black';
  }
}
series_decorate([Validate(OPT_COLOR_STRING)], TextHighlightStyle.prototype, "color", void 0);
class HighlightStyle {
  constructor() {
    this.item = new SeriesItemHighlightStyle();
    this.series = new SeriesHighlightStyle();
    this.text = new TextHighlightStyle();
  }
}
class SeriesTooltip {
  constructor() {
    this.enabled = true;
    this.showArrow = undefined;
    this.interaction = new SeriesTooltipInteraction();
    this.position = new TooltipPosition();
  }
}
series_decorate([Validate(BOOLEAN)], SeriesTooltip.prototype, "enabled", void 0);
series_decorate([Validate(OPT_BOOLEAN)], SeriesTooltip.prototype, "showArrow", void 0);
class SeriesTooltipInteraction {
  constructor() {
    this.enabled = false;
  }
}
series_decorate([Validate(BOOLEAN)], SeriesTooltipInteraction.prototype, "enabled", void 0);
class Series extends Observable {
  constructor(opts) {
    super();
    this.id = createId(this);
    // The group node that contains all the nodes used to render this series.
    this.rootGroup = new Group({
      name: 'seriesRoot'
    });
    this.directions = [ChartAxisDirection.X, ChartAxisDirection.Y];
    // Flag to determine if we should recalculate node data.
    this.nodeDataRefresh = true;
    this._data = undefined;
    this._visible = true;
    this.showInLegend = true;
    this.cursor = 'default';
    this.nodeClickRange = 'exact';
    this._declarationOrder = -1;
    this.highlightStyle = new HighlightStyle();
    this.ctx = opts.moduleCtx;
    const {
      useSeriesGroupLayer = true,
      useLabelLayer = false,
      pickModes = [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST],
      directionKeys = {},
      directionNames = {}
    } = opts;
    const {
      rootGroup
    } = this;
    this.directionKeys = directionKeys;
    this.directionNames = directionNames;
    this.contentGroup = rootGroup.appendChild(new Group({
      name: `${this.id}-content`,
      layer: useSeriesGroupLayer,
      zIndex: Layers.SERIES_LAYER_ZINDEX,
      zIndexSubOrder: [() => this._declarationOrder, 0]
    }));
    this.highlightGroup = rootGroup.appendChild(new Group({
      name: `${this.id}-highlight`,
      layer: true,
      zIndex: Layers.SERIES_LAYER_ZINDEX,
      zIndexSubOrder: [() => this._declarationOrder, 15000]
    }));
    this.highlightNode = this.highlightGroup.appendChild(new Group({
      name: 'highlightNode'
    }));
    this.highlightLabel = this.highlightGroup.appendChild(new Group({
      name: 'highlightLabel'
    }));
    this.highlightNode.zIndex = 0;
    this.highlightLabel.zIndex = 10;
    this.pickModes = pickModes;
    if (useLabelLayer) {
      this.labelGroup = rootGroup.appendChild(new Group({
        name: `${this.id}-series-labels`,
        layer: true,
        zIndex: Layers.SERIES_LABEL_ZINDEX
      }));
    }
  }
  get type() {
    var _a;
    return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';
  }
  set data(input) {
    this._data = input;
    this.nodeDataRefresh = true;
  }
  get data() {
    return this._data;
  }
  hasData() {
    const {
      data
    } = this;
    return data && (!Array.isArray(data) || data.length > 0);
  }
  set visible(value) {
    this._visible = value;
    this.visibleChanged();
  }
  get visible() {
    return this._visible;
  }
  getBandScalePadding() {
    return {
      inner: 1,
      outer: 0
    };
  }
  addChartEventListeners() {
    return;
  }
  destroy() {
    // Override point for sub-classes.
  }
  getDirectionValues(direction, properties) {
    const resolvedDirection = this.resolveKeyDirection(direction);
    const keys = properties === null || properties === void 0 ? void 0 : properties[resolvedDirection];
    const values = [];
    const flatten = (...array) => {
      for (const value of array) {
        addValue(value);
      }
    };
    const addValue = value => {
      if (Array.isArray(value)) {
        flatten(...value);
      } else if (typeof value === 'object') {
        flatten(Object.values(value));
      } else {
        values.push(value);
      }
    };
    if (!keys) return values;
    keys.forEach(key => {
      const value = this[key];
      addValue(value);
    });
    return values;
  }
  getKeys(direction) {
    return this.getDirectionValues(direction, this.directionKeys);
  }
  getNames(direction) {
    return this.getDirectionValues(direction, this.directionNames);
  }
  resolveKeyDirection(direction) {
    return direction;
  }
  // Indicate that something external changed and we should recalculate nodeData.
  markNodeDataDirty() {
    this.nodeDataRefresh = true;
  }
  visibleChanged() {
    // Override point for this.visible change post-processing.
  }
  getOpacity(datum) {
    const {
      highlightStyle: {
        series: {
          dimOpacity = 1,
          enabled = true
        }
      }
    } = this;
    const defaultOpacity = 1;
    if (enabled === false || dimOpacity === defaultOpacity) {
      return defaultOpacity;
    }
    switch (this.isItemIdHighlighted(datum)) {
      case 'no-highlight':
      case 'highlighted':
        return defaultOpacity;
      case 'peer-highlighted':
      case 'other-highlighted':
        return dimOpacity;
    }
  }
  getStrokeWidth(defaultStrokeWidth, datum) {
    const {
      highlightStyle: {
        series: {
          strokeWidth,
          enabled = true
        }
      }
    } = this;
    if (enabled === false || strokeWidth === undefined) {
      // No change in styling for highlight cases.
      return defaultStrokeWidth;
    }
    switch (this.isItemIdHighlighted(datum)) {
      case 'highlighted':
        return strokeWidth;
      case 'no-highlight':
      case 'other-highlighted':
      case 'peer-highlighted':
        return defaultStrokeWidth;
    }
  }
  isItemIdHighlighted(datum) {
    var _a;
    const highlightedDatum = (_a = this.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();
    const {
      series,
      itemId
    } = highlightedDatum !== null && highlightedDatum !== void 0 ? highlightedDatum : {};
    const highlighting = series != null;
    if (!highlighting) {
      // Highlighting not active.
      return 'no-highlight';
    }
    if (series !== this) {
      // Highlighting active, this series not highlighted.
      return 'other-highlighted';
    }
    if (itemId === undefined) {
      // Series doesn't use itemIds - so no further refinement needed, series is highlighted.
      return 'highlighted';
    }
    if (datum && highlightedDatum !== datum && itemId !== datum.itemId) {
      // A peer (in same Series instance) sub-series has highlight active, but this sub-series
      // does not.
      return 'peer-highlighted';
    }
    return 'highlighted';
  }
  pickNode(point, limitPickModes) {
    const {
      pickModes,
      visible,
      rootGroup
    } = this;
    if (!visible || !rootGroup.visible) {
      return;
    }
    for (const pickMode of pickModes) {
      if (limitPickModes && !limitPickModes.includes(pickMode)) {
        continue;
      }
      let match = undefined;
      switch (pickMode) {
        case SeriesNodePickMode.EXACT_SHAPE_MATCH:
          match = this.pickNodeExactShape(point);
          break;
        case SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST:
        case SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST:
          match = this.pickNodeMainAxisFirst(point, pickMode === SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST);
          break;
        case SeriesNodePickMode.NEAREST_NODE:
          match = this.pickNodeClosestDatum(point);
          break;
      }
      if (match) {
        return {
          pickMode,
          match: match.datum,
          distance: match.distance
        };
      }
    }
  }
  pickNodeExactShape(point) {
    const match = this.contentGroup.pickNode(point.x, point.y);
    if (match) {
      return {
        datum: match.datum,
        distance: 0
      };
    }
  }
  pickNodeClosestDatum(_point) {
    // Override point for sub-classes - but if this is invoked, the sub-class specified it wants
    // to use this feature.
    throw new Error('AG Charts - Series.pickNodeClosestDatum() not implemented');
  }
  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
    // Override point for sub-classes - but if this is invoked, the sub-class specified it wants
    // to use this feature.
    throw new Error('AG Charts - Series.pickNodeMainAxisFirst() not implemented');
  }
  fireNodeClickEvent(event, _datum) {
    const eventObject = this.getNodeClickEvent(event, _datum);
    this.fireEvent(eventObject);
  }
  fireNodeDoubleClickEvent(event, _datum) {
    const eventObject = this.getNodeDoubleClickEvent(event, _datum);
    this.fireEvent(eventObject);
  }
  getNodeClickEvent(event, datum) {
    return new SeriesNodeClickEvent(event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    return new SeriesNodeDoubleClickEvent(event, datum, this);
  }
  toggleSeriesItem(_itemId, enabled) {
    this.visible = enabled;
    this.nodeDataRefresh = true;
  }
  isEnabled() {
    return this.visible;
  }
  fixNumericExtent(extent, axis) {
    var _a;
    const fixedExtent = fixNumericExtent(extent);
    if (fixedExtent.length === 0) {
      return fixedExtent;
    }
    let [min, max] = fixedExtent;
    if (min === max) {
      // domain has zero length, there is only a single valid value in data
      const padding = (_a = axis === null || axis === void 0 ? void 0 : axis.calculatePadding(min, max)) !== null && _a !== void 0 ? _a : 1;
      min -= padding;
      max += padding;
    }
    return [min, max];
  }
}
Series.highlightedZIndex = 1000000000000;
series_decorate([Validate(STRING)], Series.prototype, "id", void 0);
series_decorate([Validate(BOOLEAN)], Series.prototype, "_visible", void 0);
series_decorate([Validate(BOOLEAN)], Series.prototype, "showInLegend", void 0);
series_decorate([Validate(STRING)], Series.prototype, "cursor", void 0);
series_decorate([Validate(INTERACTION_RANGE)], Series.prototype, "nodeClickRange", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/padding.mjs
var padding_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class Padding {
  constructor(top = 0, right = top, bottom = top, left = right) {
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
  clear() {
    this.top = this.right = this.bottom = this.left = 0;
  }
}
padding_decorate([Validate(NUMBER(0))], Padding.prototype, "top", void 0);
padding_decorate([Validate(NUMBER(0))], Padding.prototype, "right", void 0);
padding_decorate([Validate(NUMBER(0))], Padding.prototype, "bottom", void 0);
padding_decorate([Validate(NUMBER(0))], Padding.prototype, "left", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/sizeMonitor.mjs
class SizeMonitor {
  static init() {
    const NativeResizeObserver = window.ResizeObserver;
    if (NativeResizeObserver) {
      this.resizeObserver = new NativeResizeObserver(entries => {
        for (const entry of entries) {
          const {
            width,
            height
          } = entry.contentRect;
          this.checkSize(this.elements.get(entry.target), entry.target, width, height);
        }
      });
    } else {
      // polyfill (more reliable even in browsers that support ResizeObserver)
      const step = () => {
        this.elements.forEach((entry, element) => {
          this.checkClientSize(element, entry);
        });
      };
      window.setInterval(step, 100);
    }
    this.ready = true;
  }
  static checkSize(entry, element, width, height) {
    if (entry) {
      if (!entry.size || width !== entry.size.width || height !== entry.size.height) {
        entry.size = {
          width,
          height
        };
        entry.cb(entry.size, element);
      }
    }
  }
  // Only a single callback is supported.
  static observe(element, cb) {
    if (!this.ready) {
      this.init();
    }
    this.unobserve(element);
    if (this.resizeObserver) {
      this.resizeObserver.observe(element);
    }
    this.elements.set(element, {
      cb
    });
    // Ensure first size callback happens synchronously.
    this.checkClientSize(element, {
      cb
    });
  }
  static unobserve(element) {
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(element);
    }
    this.elements.delete(element);
  }
  static checkClientSize(element, entry) {
    const width = element.clientWidth ? element.clientWidth : 0;
    const height = element.clientHeight ? element.clientHeight : 0;
    this.checkSize(entry, element, width, height);
  }
}
SizeMonitor.elements = new Map();
SizeMonitor.ready = false;
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/labelPlacement.mjs

function circleRectOverlap(c, x, y, w, h) {
  // Find closest horizontal and vertical edges.
  let edgeX = c.x;
  if (c.x < x) {
    edgeX = x;
  } else if (c.x > x + w) {
    edgeX = x + w;
  }
  let edgeY = c.y;
  if (c.y < y) {
    edgeY = y;
  } else if (c.y > y + h) {
    edgeY = y + h;
  }
  // Find distance to closest edges.
  const dx = c.x - edgeX;
  const dy = c.y - edgeY;
  const d = Math.sqrt(dx * dx + dy * dy);
  return d <= c.size * 0.5;
}
function rectRectOverlap(r1, x2, y2, w2, h2) {
  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;
  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;
  return xOverlap && yOverlap;
}
function rectContainsRect(r1, r2x, r2y, r2w, r2h) {
  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === 'object' && typeof x.label === 'object';
}
/**
 * @param data Points and labels for one or more series. The order of series determines label placement precedence.
 * @param bounds Bounds to fit the labels into. If a label can't be fully contained, it doesn't fit.
 * @returns Placed labels for the given series (in the given order).
 */
function placeLabels(data, bounds, padding = 5) {
  const result = [];
  data = data.map(d => d.slice().sort((a, b) => b.point.size - a.point.size));
  for (let j = 0; j < data.length; j++) {
    const labels = result[j] = [];
    const datum = data[j];
    if (!((datum === null || datum === void 0 ? void 0 : datum.length) && datum[0].label)) {
      continue;
    }
    for (let i = 0, ln = datum.length; i < ln; i++) {
      const d = datum[i];
      const l = d.label;
      const r = d.point.size * 0.5;
      const x = d.point.x - l.width * 0.5;
      const y = d.point.y - r - l.height - padding;
      const {
        width,
        height
      } = l;
      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);
      if (!withinBounds) {
        continue;
      }
      const overlapPoints = data.some(datum => datum.some(d => circleRectOverlap(d.point, x, y, width, height)));
      if (overlapPoints) {
        continue;
      }
      const overlapLabels = result.some(labels => labels.some(l => rectRectOverlap(l, x, y, width, height)));
      if (overlapLabels) {
        continue;
      }
      labels.push({
        index: i,
        text: l.text,
        x,
        y,
        width,
        height,
        datum: d
      });
    }
  }
  return result;
}
function axisLabelsOverlap(data, padding) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    const datum = data[i];
    const {
      point: {
        x,
        y
      },
      label: {
        text
      }
    } = datum;
    let {
      label: {
        width,
        height
      }
    } = datum;
    width += padding !== null && padding !== void 0 ? padding : 0;
    height += padding !== null && padding !== void 0 ? padding : 0;
    const overlapLabels = result.some(l => {
      const overlap = rectRectOverlap(l, x, y, width, height);
      return overlap;
    });
    if (overlapLabels) {
      return true;
    }
    result.push({
      index: i,
      text,
      x,
      y,
      width,
      height,
      datum
    });
  }
  return false;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/render.mjs
var render_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/**
 * Wrap a function in debouncing trigger function. A requestAnimationFrame() is scheduled
 * after the first schedule() call, and subsequent schedule() calls will be ignored until the
 * animation callback executes.
 */
function debouncedAnimationFrame(cb) {
  return buildScheduler(cb => requestAnimationFrame(cb), cb);
}
function debouncedCallback(cb) {
  return buildScheduler(cb => setTimeout(cb, 0), cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone === null || awaitingDone === void 0 ? void 0 : awaitingDone();
    awaitingDone = undefined;
    awaitingPromise = undefined;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({
      count
    });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done).catch(done);
  };
  return {
    schedule() {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb);
      }
      scheduleCount++;
    },
    await() {
      return render_awaiter(this, void 0, void 0, function* () {
        if (!busy()) {
          return;
        }
        if (!awaitingPromise) {
          awaitingPromise = new Promise(resolve => {
            awaitingDone = resolve;
          });
        }
        while (busy()) {
          yield awaitingPromise;
        }
      });
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/polyRoots.mjs

/**
 * Finds the roots of a parametric linear equation in `t`,
 * where `t` lies in the interval of `[0,1]`.
 */
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
/**
 * Finds the roots of a parametric quadratic equation in `t`,
 * where `t` lies in the interval of `[0,1]`.
 */
function quadraticRoots(a, b, c) {
  if (a === 0) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c; // The polynomial's discriminant.
  const roots = [];
  if (D === 0) {
    // A single real root.
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    // A pair of distinct real roots.
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  // else -> Complex roots.
  return roots;
}
/**
 * Finds the roots of a parametric cubic equation in `t`,
 * where `t` lies in the interval of `[0,1]`.
 * Returns an array of parametric intersection locations along the cubic,
 * excluding out-of-bounds intersections (before or after the end point
 * or in the imaginary plane).
 * An adaptation of http://www.particleincell.com/blog/2013/cubic-line-intersection/
 */
function cubicRoots(a, b, c, d) {
  if (a === 0) {
    return quadraticRoots(b, c, d);
  }
  const A = b / a;
  const B = c / a;
  const C = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R; // The polynomial's discriminant.
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    // Complex or duplicate roots.
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2); // Complex part of the root pair.
    const t = -third * A + (S + T); // A real root.
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Im === 0) {
      const t = -third * A - (S + T) / 2; // The real part of a complex root.
      if (t >= 0 && t <= 1) {
        roots.push(t);
      }
    }
  } else {
    // Distinct real roots.
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/intersection.mjs



/**
 * Returns the intersection point for the given pair of line segments, or null,
 * if the segments are parallel or don't intersect.
 * Based on http://paulbourke.net/geometry/pointlineplane/
 */
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    // The lines are parallel.
    return null;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return {
      x: ax1 + ua * (ax2 - ax1),
      y: ay1 + ua * (ay2 - ay1)
    };
  }
  return null; // The intersection point is outside either or both segments.
}
/**
 * Returns intersection points of the given cubic curve and the line segment.
 * Takes in x/y components of cubic control points and line segment start/end points
 * as parameters.
 */
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  const intersections = [];
  // Find line equation coefficients.
  const A = y1 - y2;
  const B = x2 - x1;
  const C = x1 * (y2 - y1) - y1 * (x2 - x1);
  // Find cubic Bezier curve equation coefficients from control points.
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0]; // t^3
  const b = A * bx[1] + B * by[1]; // t^2
  const c = A * bx[2] + B * by[2]; // t
  const d = A * bx[3] + B * by[3] + C; // 1
  const roots = cubicRoots(a, b, c, d);
  // Verify that the roots are within bounds of the linear segment.
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    // Find the cartesian plane coordinates for the parametric root `t`.
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    // The parametric cubic roots we found are intersection points
    // with an infinite line, and so the x/y coordinates above are as well.
    // Make sure the x/y is also within the bounds of the given segment.
    let s;
    if (x1 !== x2) {
      s = (x - x1) / (x2 - x1);
    } else {
      // the line is vertical
      s = (y - y1) / (y2 - y1);
    }
    if (s >= 0 && s <= 1) {
      intersections.push({
        x,
        y
      });
    }
  }
  return intersections;
}
/**
 * Returns the given coordinates vector multiplied by the coefficient matrix
 * of the parametric cubic BÃ©zier equation.
 */
function bezierCoefficients(P1, P2, P3, P4) {
  return [
  // BÃ©zier expressed as matrix operations:
  -P1 + 3 * P2 - 3 * P3 + P4, 3 * P1 - 6 * P2 + 3 * P3, -3 * P1 + 3 * P2, P1 //                 | 1  0  0  0| |P4|
  ];
}
/**
 * Returns intersection points of the arc and the line segment.
 * Takes in arc parameters and line segment start/end points.
 */
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  // Solving the quadratic equation:
  // 1. y = k * x + y0
  // 2. (x - cx)^2 + (y - cy)^2 = r^2
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return [];
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  const intersections = [];
  [i1x, i2x].forEach(x => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x;
    const a1 = normalizeAngle360(counterClockwise ? endAngle : startAngle);
    let a2 = normalizeAngle360(counterClockwise ? startAngle : endAngle);
    let intersectionAngle = normalizeAngle360(Math.atan2(y, x));
    // Order angles clockwise after the start angle
    // (end angle if counter-clockwise)
    if (a2 <= a1) {
      a2 += 2 * Math.PI;
    }
    if (intersectionAngle < a1) {
      intersectionAngle += 2 * Math.PI;
    }
    if (intersectionAngle >= a1 && intersectionAngle <= a2) {
      intersections.push({
        x,
        y
      });
    }
  });
  return intersections;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/path2D.mjs


var Command;
(function (Command) {
  Command[Command["Move"] = 0] = "Move";
  Command[Command["Line"] = 1] = "Line";
  Command[Command["Arc"] = 2] = "Arc";
  Command[Command["Curve"] = 3] = "Curve";
  Command[Command["ClosePath"] = 4] = "ClosePath";
})(Command || (Command = {}));
class Path2D {
  constructor() {
    // The methods of this class will likely be called many times per animation frame,
    // and any allocation can trigger a GC cycle during animation, so we attempt
    // to minimize the number of allocations.
    this.previousCommands = [];
    this.previousParams = [];
    this.previousClosedPath = false;
    this.commands = [];
    this.params = [];
    this._closedPath = false;
  }
  isDirty() {
    if (this._closedPath !== this.previousClosedPath) {
      return true;
    }
    if (this.previousCommands.length !== this.commands.length) {
      return true;
    }
    if (this.previousParams.length !== this.params.length) {
      return true;
    }
    for (let i = 0; i < this.commands.length; i++) {
      if (this.commands[i] !== this.previousCommands[i]) {
        return true;
      }
    }
    for (let i = 0; i < this.params.length; i++) {
      if (this.params[i] !== this.previousParams[i]) {
        return true;
      }
    }
    return false;
  }
  draw(ctx) {
    const commands = this.commands;
    const params = this.params;
    let j = 0;
    ctx.beginPath();
    for (const command of commands) {
      switch (command) {
        case Command.Move:
          ctx.moveTo(params[j++], params[j++]);
          break;
        case Command.Line:
          ctx.lineTo(params[j++], params[j++]);
          break;
        case Command.Curve:
          ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);
          break;
        case Command.Arc:
          ctx.arc(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++] === 1);
          break;
        case Command.ClosePath:
          ctx.closePath();
          break;
      }
    }
    if (commands.length === 0) {
      ctx.closePath();
    }
  }
  moveTo(x, y) {
    if (this.xy) {
      this.xy[0] = x;
      this.xy[1] = y;
    } else {
      this.xy = [x, y];
    }
    this.commands.push(Command.Move);
    this.params.push(x, y);
  }
  lineTo(x, y) {
    if (this.xy) {
      this.commands.push(Command.Line);
      this.params.push(x, y);
      this.xy[0] = x;
      this.xy[1] = y;
    } else {
      this.moveTo(x, y);
    }
  }
  rect(x, y, width, height) {
    this.moveTo(x, y);
    this.lineTo(x + width, y);
    this.lineTo(x + width, y + height);
    this.lineTo(x, y + height);
    this.closePath();
  }
  arc(x, y, r, sAngle, eAngle, antiClockwise = false) {
    const endX = x + r * Math.cos(eAngle);
    const endY = y + r * Math.sin(eAngle);
    if (this.xy) {
      this.xy[0] = endX;
      this.xy[1] = endY;
    } else {
      this.xy = [endX, endY];
    }
    this.commands.push(Command.Arc);
    this.params.push(x, y, r, sAngle, eAngle, antiClockwise ? 1 : 0);
  }
  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
    if (!this.xy) {
      this.moveTo(cx1, cy1);
    }
    this.commands.push(Command.Curve);
    this.params.push(cx1, cy1, cx2, cy2, x, y);
    this.xy[0] = x;
    this.xy[1] = y;
  }
  get closedPath() {
    return this._closedPath;
  }
  closePath() {
    if (this.xy) {
      this.xy = undefined;
      this.commands.push(Command.ClosePath);
      this._closedPath = true;
    }
  }
  clear({
    trackChanges
  } = {
    trackChanges: false
  }) {
    if (trackChanges) {
      this.previousCommands = this.commands;
      this.previousParams = this.params;
      this.previousClosedPath = this._closedPath;
      this.commands = [];
      this.params = [];
    } else {
      this.commands.length = 0;
      this.params.length = 0;
    }
    this.xy = undefined;
    this._closedPath = false;
  }
  isPointInPath(x, y) {
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    // Hit testing using ray casting method, where the ray's origin is some point
    // outside the path. In this case, an offscreen point that is remote enough, so that
    // even if the path itself is large and is partially offscreen, the ray's origin
    // will likely be outside the path anyway. To test if the given point is inside the
    // path or not, we cast a ray from the origin to the given point and check the number
    // of intersections of this segment with the path. If the number of intersections is
    // even, then the ray both entered and exited the path an equal number of times,
    // therefore the point is outside the path, and inside the path, if the number of
    // intersections is odd. Since the path is compound, we check if the ray segment
    // intersects with each of the path's segments, which can be either a line segment
    // (one or no intersection points) or a BÃ©zier curve segment (up to 3 intersection
    // points).
    const ox = -10000;
    const oy = -10000;
    // the starting point of the  current path
    let sx = NaN;
    let sy = NaN;
    // the previous point of the current path
    let px = 0;
    let py = 0;
    let intersectionCount = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case Command.Move:
          if (!isNaN(sx)) {
            if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {
              intersectionCount++;
            }
          }
          px = params[pi++];
          sx = px;
          py = params[pi++];
          sy = py;
          break;
        case Command.Line:
          if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {
            intersectionCount++;
          }
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case Command.Curve:
          intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y).length;
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case Command.Arc:
          intersectionCount += arcIntersections(params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], Boolean(params[pi++]), ox, oy, x, y).length;
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case Command.ClosePath:
          if (!isNaN(sx)) {
            if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {
              intersectionCount++;
            }
          }
          break;
      }
    }
    return intersectionCount % 2 === 1;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/path.mjs
var path_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



function ScenePathChangeDetection(opts) {
  const {
    redraw = RedrawType.MAJOR,
    changeCb,
    convertor
  } = opts !== null && opts !== void 0 ? opts : {};
  return SceneChangeDetection({
    redraw,
    type: 'path',
    convertor,
    changeCb
  });
}
class Path extends Shape {
  constructor() {
    super(...arguments);
    /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */
    this.path = new Path2D();
    /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */
    this._dirtyPath = true;
  }
  set dirtyPath(value) {
    if (this._dirtyPath !== value) {
      this._dirtyPath = value;
      if (value) {
        this.markDirty(this, RedrawType.MAJOR);
      }
    }
  }
  get dirtyPath() {
    return this._dirtyPath;
  }
  checkPathDirty() {
    var _a, _b;
    if (this._dirtyPath) {
      return;
    }
    this.dirtyPath = this.path.isDirty() || ((_b = (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.isDirty()) !== null && _b !== void 0 ? _b : false);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);
  }
  isDirtyPath() {
    // Override point for more expensive dirty checks.
    return false;
  }
  updatePath() {
    // Override point for subclasses.
  }
  render(renderCtx) {
    var _a, _b;
    const {
      ctx,
      forceRender,
      stats
    } = renderCtx;
    if (this.dirty === RedrawType.NONE && !forceRender) {
      if (stats) stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
    if (this.clipPath) {
      ctx.save();
      if (this.clipMode === 'normal') {
        // Bound the shape rendered to the clipping path.
        this.clipPath.draw(ctx);
        ctx.clip();
      }
      this.path.draw(ctx);
      this.fillStroke(ctx);
      if (this.clipMode === 'punch-out') {
        // Bound the shape rendered to outside the clipping path.
        this.clipPath.draw(ctx);
        ctx.clip();
        // Fallback values, but practically these should never be used.
        const {
          x = -10000,
          y = -10000,
          width = 20000,
          height = 20000
        } = (_a = this.computeBBox()) !== null && _a !== void 0 ? _a : {};
        ctx.clearRect(x, y, width, height);
      }
      ctx.restore();
    } else {
      this.path.draw(ctx);
      this.fillStroke(ctx);
    }
    (_b = this.fillShadow) === null || _b === void 0 ? void 0 : _b.markClean();
    super.render(renderCtx);
  }
}
Path.className = 'Path';
path_decorate([ScenePathChangeDetection()], Path.prototype, "clipPath", void 0);
path_decorate([ScenePathChangeDetection()], Path.prototype, "clipMode", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/marker.mjs
var marker_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class Marker extends Path {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.size = 12;
  }
  computeBBox() {
    const {
      x,
      y,
      size
    } = this;
    const half = size / 2;
    return new BBox(x - half, y - half, size, size);
  }
  applyPath(s, moves) {
    const {
      path
    } = this;
    let {
      x,
      y
    } = this;
    path.clear();
    for (const {
      x: mx,
      y: my,
      t
    } of moves) {
      x += mx * s;
      y += my * s;
      if (t === 'move') {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.closePath();
  }
}
marker_decorate([ScenePathChangeDetection()], Marker.prototype, "x", void 0);
marker_decorate([ScenePathChangeDetection()], Marker.prototype, "y", void 0);
marker_decorate([ScenePathChangeDetection({
  convertor: Math.abs
})], Marker.prototype, "size", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/circle.mjs

class Circle extends Marker {
  updatePath() {
    const {
      x,
      y,
      path,
      size
    } = this;
    const r = size / 2;
    path.clear();
    path.arc(x, y, r, 0, Math.PI * 2);
    path.closePath();
  }
}
Circle.className = 'Circle';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/seriesMarker.mjs
var seriesMarker_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




const MARKER_SHAPES = ['circle', 'cross', 'diamond', 'heart', 'plus', 'square', 'triangle'];
const MARKER_SHAPE = predicateWithMessage(v => MARKER_SHAPES.includes(v) || Object.getPrototypeOf(v) === Marker, `expecting a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`);
class SeriesMarker extends ChangeDetectable {
  constructor() {
    super(...arguments);
    this.enabled = true;
    /**
     * One of the predefined marker names, or a marker constructor function (for user-defined markers).
     * A series will create one marker instance per data point.
     */
    this.shape = Circle;
    this.size = 6;
    /**
     * In case a series has the `sizeKey` set, the `sizeKey` values along with the `size` and `maxSize` configs
     * will be used to determine the size of the marker. All values will be mapped to a marker size
     * within the `[size, maxSize]` range, where the largest values will correspond to the `maxSize`
     * and the lowest to the `size`.
     */
    this.maxSize = 30;
    this.domain = undefined;
    this.fill = undefined;
    this.stroke = undefined;
    this.strokeWidth = 1;
    this.fillOpacity = undefined;
    this.strokeOpacity = undefined;
  }
}
seriesMarker_decorate([Validate(BOOLEAN), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "enabled", void 0);
seriesMarker_decorate([Validate(MARKER_SHAPE), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "shape", void 0);
seriesMarker_decorate([Validate(NUMBER(0)), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "size", void 0);
seriesMarker_decorate([Validate(NUMBER(0)), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "maxSize", void 0);
seriesMarker_decorate([Validate(OPT_NUMBER_ARRAY), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "domain", void 0);
seriesMarker_decorate([Validate(OPT_COLOR_STRING), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "fill", void 0);
seriesMarker_decorate([Validate(OPT_COLOR_STRING), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "stroke", void 0);
seriesMarker_decorate([Validate(OPT_NUMBER(0)), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "strokeWidth", void 0);
seriesMarker_decorate([Validate(OPT_NUMBER(0, 1)), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "fillOpacity", void 0);
seriesMarker_decorate([Validate(OPT_NUMBER(0, 1)), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], SeriesMarker.prototype, "strokeOpacity", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/selection.mjs


class Selection {
  constructor(parent, classOrFactory) {
    this._nodes = [];
    this._data = [];
    this._parent = parent;
    this._factory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;
  }
  static select(parent, classOrFactory) {
    return new Selection(parent, classOrFactory);
  }
  each(iterate) {
    this._nodes.forEach((node, i) => iterate(node, node.datum, i));
    return this;
  }
  update(data, init) {
    const old = this._data;
    const parent = this._parent;
    const factory = this._factory;
    if (data.length > old.length) {
      data.slice(old.length).forEach(datum => {
        const node = factory(datum);
        node.datum = datum;
        init === null || init === void 0 ? void 0 : init(node);
        parent.appendChild(node);
        this._nodes.push(node);
      });
    } else if (data.length < old.length) {
      this._nodes.splice(data.length).forEach(node => {
        parent.removeChild(node);
      });
    }
    this._data = data.slice(0);
    for (let i = 0; i < data.length; i++) {
      this._nodes[i].datum = this._data[i];
    }
    return this;
  }
  clear() {
    this.update([]);
    return this;
  }
  static selectAll(parent, predicate) {
    const results = [];
    const traverse = node => {
      if (predicate(node)) {
        results.push(node);
      }
      node.children.forEach(traverse);
    };
    traverse(parent);
    return results;
  }
  static selectByClass(node, Class) {
    return Selection.selectAll(node, node => node instanceof Class);
  }
  static selectByTag(node, tag) {
    return Selection.selectAll(node, node => node.tag === tag);
  }
  select(predicate) {
    return Selection.selectAll(this._parent, predicate);
  }
  selectByClass(Class) {
    return this.select(node => node instanceof Class);
  }
  selectByTag(tag) {
    return this.select(node => node.tag === tag);
  }
  nodes() {
    return this._nodes;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scale/bandScale.mjs

function clamp(x, min, max) {
  return Math.max(min, Math.min(max, x));
}
/**
 * Maps a discrete domain to a continuous numeric range.
 */
class BandScale {
  constructor() {
    this.type = 'band';
    this.cache = null;
    this.cacheProps = ['_domain', 'range', '_paddingInner', '_paddingOuter', 'round', 'interval'];
    /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate datums (not allowed).
     */
    this.index = new Map();
    /**
     * The output range values for datum at each index.
     */
    this.ordinalRange = [];
    /**
     * Contains unique datums only. Since `{}` is used in place of `Map`
     * for IE11 compatibility, the datums are converted `toString` before
     * the uniqueness check.
     */
    this._domain = [];
    this.range = [0, 1];
    this._bandwidth = 1;
    this._rawBandwidth = 1;
    /**
     * The ratio of the range that is reserved for space between bands.
     */
    this._paddingInner = 0;
    /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */
    this._paddingOuter = 0;
    this.round = false;
  }
  didChange() {
    const {
      cache
    } = this;
    const didChange = !cache || this.cacheProps.some(p => this[p] !== cache[p]);
    if (didChange) {
      this.cache = {};
      this.cacheProps.forEach(p => this.cache[p] = this[p]);
      return true;
    }
    return false;
  }
  refresh() {
    if (this.didChange()) {
      this.update();
    }
  }
  set domain(values) {
    const domain = [];
    this.index = new Map();
    const index = this.index;
    // In case one wants to have duplicate domain values, for example, two 'Italy' categories,
    // one should use objects rather than strings for domain values like so:
    // { toString: () => 'Italy' }
    // { toString: () => 'Italy' }
    values.forEach(value => {
      if (index.get(value) === undefined) {
        index.set(value, domain.push(value) - 1);
      }
    });
    this._domain = domain;
  }
  get domain() {
    return this._domain;
  }
  ticks() {
    this.refresh();
    const {
      interval = 1
    } = this;
    const step = Math.abs(Math.round(interval));
    return this._domain.filter((_, i) => i % step === 0);
  }
  convert(d) {
    this.refresh();
    const i = this.index.get(d);
    if (i === undefined) {
      return NaN;
    }
    const r = this.ordinalRange[i];
    if (r === undefined) {
      return NaN;
    }
    return r;
  }
  invert(position) {
    this.refresh();
    const index = this.ordinalRange.findIndex(p => p === position);
    return this.domain[index];
  }
  get bandwidth() {
    this.refresh();
    return this._bandwidth;
  }
  get rawBandwidth() {
    this.refresh();
    return this._rawBandwidth;
  }
  set padding(value) {
    value = clamp(value, 0, 1);
    this._paddingInner = value;
    this._paddingOuter = value;
  }
  get padding() {
    return this._paddingInner;
  }
  set paddingInner(value) {
    this._paddingInner = clamp(value, 0, 1);
  }
  get paddingInner() {
    return this._paddingInner;
  }
  set paddingOuter(value) {
    this._paddingOuter = clamp(value, 0, 1);
  }
  get paddingOuter() {
    return this._paddingOuter;
  }
  update() {
    const count = this._domain.length;
    if (count === 0) {
      return;
    }
    const round = this.round;
    const paddingInner = this._paddingInner;
    const paddingOuter = this._paddingOuter;
    const [r0, r1] = this.range;
    const width = r1 - r0;
    const rawStep = width / Math.max(1, count + 2 * paddingOuter - paddingInner);
    const step = round ? Math.floor(rawStep) : rawStep;
    const fullBandWidth = step * (count - paddingInner);
    const x0 = r0 + (width - fullBandWidth) / 2;
    const start = round ? Math.round(x0) : x0;
    const bw = step * (1 - paddingInner);
    const bandwidth = round ? Math.round(bw) : bw;
    const rawBandwidth = rawStep * (1 - paddingInner);
    const values = [];
    for (let i = 0; i < count; i++) {
      values.push(start + step * i);
    }
    this._bandwidth = bandwidth;
    this._rawBandwidth = rawBandwidth;
    this.ordinalRange = values;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/line.mjs
var line_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class Line extends Shape {
  constructor() {
    super();
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.restoreOwnStyles();
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    var _a;
    const {
      ctx,
      forceRender,
      stats
    } = renderCtx;
    if (this.dirty === RedrawType.NONE && !forceRender) {
      if (stats) stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    let x1 = this.x1;
    let y1 = this.y1;
    let x2 = this.x2;
    let y2 = this.y2;
    // Align to the pixel grid if the line is strictly vertical
    // or horizontal (but not both, i.e. a dot).
    if (x1 === x2) {
      const x = Math.round(x1) + Math.floor(this.strokeWidth) % 2 / 2;
      x1 = x;
      x2 = x;
    } else if (y1 === y2) {
      const y = Math.round(y1) + Math.floor(this.strokeWidth) % 2 / 2;
      y1 = y;
      y2 = y;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    this.fillStroke(ctx);
    (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();
    super.render(renderCtx);
  }
}
Line.className = 'Line';
Line.defaultStyles = Object.assign({}, Shape.defaultStyles, {
  fill: undefined,
  strokeWidth: 1
});
line_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Line.prototype, "x1", void 0);
line_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Line.prototype, "y1", void 0);
line_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Line.prototype, "x2", void 0);
line_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Line.prototype, "y2", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/number.mjs
function isEqual(a, b, epsilon = 1e-10) {
  return Math.abs(a - b) < epsilon;
}
/**
 * `Number.toFixed(n)` always formats a number so that it has `n` digits after the decimal point.
 * For example, `Number(0.00003427).toFixed(2)` returns `0.00`.
 * That's not very helpful, because all the meaningful information is lost.
 * In this case we would want the formatted value to have at least two significant digits: `0.000034`,
 * not two fraction digits.
 * @param value
 * @param fractionOrSignificantDigits
 */
function toFixed(value, fractionOrSignificantDigits = 2) {
  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);
  if (power >= 0 || !isFinite(power)) {
    return value.toFixed(fractionOrSignificantDigits); // fraction digits
  }

  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits); // significant digits
}
/**
 * Returns the mathematically correct n modulus of m. For context, the JS % operator is remainder
 * NOT modulus, which is why this is needed.
 */
function mod(n, m) {
  if (n >= 0) {
    return Math.floor(n % m);
  }
  return Math.floor(n % m + m);
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/arc.mjs
var arc_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var ArcType;
(function (ArcType) {
  ArcType[ArcType["Open"] = 0] = "Open";
  ArcType[ArcType["Chord"] = 1] = "Chord";
  ArcType[ArcType["Round"] = 2] = "Round";
})(ArcType || (ArcType = {}));
/**
 * Elliptical arc node.
 */
class Arc extends Path {
  constructor() {
    super();
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 10;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.counterClockwise = false;
    /**
     * The type of arc to render:
     * - {@link ArcType.Open} - end points of the arc segment are not connected (default)
     * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment
     * - {@link ArcType.Round} - each of the end points of the arc segment are connected
     *                           to the center of the arc
     * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their
     * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support
     * would require using two paths - one for rendering, another for hit testing - and there
     * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}
     * to create a closed path.
     */
    this.type = ArcType.Open;
    this.restoreOwnStyles();
  }
  get fullPie() {
    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));
  }
  updatePath() {
    const path = this.path;
    path.clear(); // No need to recreate the Path, can simply clear the existing one.
    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
    if (this.type === ArcType.Chord) {
      path.closePath();
    } else if (this.type === ArcType.Round && !this.fullPie) {
      path.lineTo(this.centerX, this.centerY);
      path.closePath();
    }
  }
  computeBBox() {
    // Only works with full arcs (circles) and untransformed ellipses.
    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return this.type !== ArcType.Open && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);
  }
}
Arc.className = 'Arc';
Arc.defaultStyles = Object.assign({}, Shape.defaultStyles, {
  lineWidth: 1,
  fillStyle: null
});
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "centerX", void 0);
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "centerY", void 0);
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "radius", void 0);
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "startAngle", void 0);
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "endAngle", void 0);
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "counterClockwise", void 0);
arc_decorate([ScenePathChangeDetection()], Arc.prototype, "type", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/proxy.mjs

function ProxyOnWrite(proxyProperty) {
  return addTransformToInstanceProperty((target, _, value) => {
    target[proxyProperty] = value;
    return value;
  });
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return decorator_addTransformToInstanceProperty((target, key, value) => {
    target[childName][childProperty !== null && childProperty !== void 0 ? childProperty : key] = value;
    return value;
  });
}
/**
 * Allows side-effects to be triggered on property write.
 *
 * @param opts.newValue called when a new value is set - never called for undefined values.
 * @param opts.oldValue called with the old value before a new value is set - never called for
 *                      undefined values.
 * @param opts.changeValue called on any change to the value - always called.
 */
function ActionOnSet(opts) {
  const {
    newValue: newValueFn,
    oldValue: oldValueFn,
    changeValue: changeValueFn
  } = opts;
  return decorator_addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== undefined) {
        oldValueFn === null || oldValueFn === void 0 ? void 0 : oldValueFn.call(target, oldValue);
      }
      if (newValue !== undefined) {
        newValueFn === null || newValueFn === void 0 ? void 0 : newValueFn.call(target, newValue);
      }
      changeValueFn === null || changeValueFn === void 0 ? void 0 : changeValueFn.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/caption.mjs
var caption_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Caption {
  constructor() {
    this.node = new Text();
    this.enabled = false;
    this.text = undefined;
    this.fontSize = 10;
    this.fontFamily = 'sans-serif';
    this.spacing = Caption.PADDING;
    this.lineHeight = undefined;
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.wrapping = 'always';
    const node = this.node;
    node.textAlign = 'center';
    node.pointerEvents = PointerEvents.None;
  }
  computeTextWrap(containerWidth, containerHeight) {
    var _a, _b;
    const {
      text,
      wrapping
    } = this;
    const maxWidth = Math.min((_a = this.maxWidth) !== null && _a !== void 0 ? _a : Infinity, containerWidth);
    const maxHeight = (_b = this.maxHeight) !== null && _b !== void 0 ? _b : containerHeight;
    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
      this.node.text = text;
      return;
    }
    const wrapped = Text.wrap(text !== null && text !== void 0 ? text : '', maxWidth, maxHeight, this, wrapping);
    this.node.text = wrapped;
  }
}
Caption.PADDING = 10;
caption_decorate([Validate(BOOLEAN)], Caption.prototype, "enabled", void 0);
caption_decorate([Validate(OPT_STRING), ProxyPropertyOnWrite('node')], Caption.prototype, "text", void 0);
caption_decorate([Validate(OPT_FONT_STYLE), ProxyPropertyOnWrite('node')], Caption.prototype, "fontStyle", void 0);
caption_decorate([Validate(OPT_FONT_WEIGHT), ProxyPropertyOnWrite('node')], Caption.prototype, "fontWeight", void 0);
caption_decorate([Validate(NUMBER(0)), ProxyPropertyOnWrite('node')], Caption.prototype, "fontSize", void 0);
caption_decorate([Validate(STRING), ProxyPropertyOnWrite('node')], Caption.prototype, "fontFamily", void 0);
caption_decorate([Validate(OPT_COLOR_STRING), ProxyPropertyOnWrite('node', 'fill')], Caption.prototype, "color", void 0);
caption_decorate([Validate(OPT_NUMBER(0))], Caption.prototype, "spacing", void 0);
caption_decorate([Validate(OPT_NUMBER(0))], Caption.prototype, "lineHeight", void 0);
caption_decorate([Validate(OPT_NUMBER(0))], Caption.prototype, "maxWidth", void 0);
caption_decorate([Validate(OPT_NUMBER(0))], Caption.prototype, "maxHeight", void 0);
caption_decorate([Validate(TEXT_WRAP)], Caption.prototype, "wrapping", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/equal.mjs
function areArrayItemsStrictlyEqual(arrA, arrB) {
  return arrA.length === arrB.length && arrA.every((a, i) => {
    const b = arrB[i];
    if (Array.isArray(a) && Array.isArray(b)) {
      return areArrayItemsStrictlyEqual(a, b);
    }
    return a === b;
  });
}
function areArrayNumbersEqual(arrA, arrB) {
  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scale/continuousScale.mjs

class ContinuousScale {
  constructor(domain, range) {
    this.domain = domain;
    this.range = range;
    this.nice = false;
    this.tickCount = ContinuousScale.defaultTickCount;
    this.minTickCount = 0;
    this.maxTickCount = Infinity;
    this.niceDomain = null;
    this.strictClampByDefault = false;
    this.cache = null;
    this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'minTickCount', 'maxTickCount'];
  }
  transform(x) {
    return x;
  }
  transformInvert(x) {
    return x;
  }
  fromDomain(d) {
    if (typeof d === 'number') {
      return d;
    } else if (d instanceof Date) {
      return d.getTime();
    }
    return NaN;
  }
  getDomain() {
    if (this.nice) {
      this.refresh();
      if (this.niceDomain) {
        return this.niceDomain;
      }
    }
    return this.domain;
  }
  convert(x, params) {
    var _a;
    if (!this.domain || this.domain.length < 2) {
      return NaN;
    }
    this.refresh();
    const strict = (_a = params === null || params === void 0 ? void 0 : params.strict) !== null && _a !== void 0 ? _a : this.strictClampByDefault;
    const domain = this.getDomain().map(d => this.transform(d));
    const [d0, d1] = domain;
    const {
      range
    } = this;
    const [r0, r1] = range;
    x = this.transform(x);
    if (x < d0) {
      return strict ? NaN : r0;
    } else if (x > d1) {
      return strict ? NaN : r1;
    }
    if (d0 === d1) {
      return (r0 + r1) / 2;
    } else if (x === d0) {
      return r0;
    } else if (x === d1) {
      return r1;
    }
    return r0 + (this.fromDomain(x) - this.fromDomain(d0)) / (this.fromDomain(d1) - this.fromDomain(d0)) * (r1 - r0);
  }
  invert(x) {
    this.refresh();
    const domain = this.getDomain().map(d => this.transform(d));
    const [d0, d1] = domain;
    const {
      range
    } = this;
    const [r0, r1] = range;
    const isReversed = r0 > r1;
    const rMin = isReversed ? r1 : r0;
    const rMax = isReversed ? r0 : r1;
    let d;
    if (x < rMin) {
      return isReversed ? d1 : d0;
    } else if (x > rMax) {
      return isReversed ? d0 : d1;
    } else if (r0 === r1) {
      d = this.toDomain((this.fromDomain(d0) + this.fromDomain(d1)) / 2);
    } else {
      d = this.toDomain(this.fromDomain(d0) + (x - r0) / (r1 - r0) * (this.fromDomain(d1) - this.fromDomain(d0)));
    }
    return this.transformInvert(d);
  }
  didChange() {
    const {
      cache
    } = this;
    const didChange = !cache || this.cacheProps.some(p => this[p] !== cache[p]);
    if (didChange) {
      this.cache = {};
      this.cacheProps.forEach(p => this.cache[p] = this[p]);
      return true;
    }
    return false;
  }
  refresh() {
    if (this.didChange()) {
      this.update();
    }
  }
  isDenseInterval({
    start,
    stop,
    interval,
    count
  }) {
    const {
      range
    } = this;
    const domain = stop - start;
    const min = Math.min(range[0], range[1]);
    const max = Math.max(range[0], range[1]);
    const availableRange = max - min;
    const step = typeof interval === 'number' ? interval : 1;
    count !== null && count !== void 0 ? count : count = domain / step;
    if (count >= availableRange) {
      Logger.warn(`the configured tick interval results in more than 1 tick per pixel, ignoring. Supply a larger tick interval or omit this configuration.`);
      return true;
    }
    return false;
  }
}
ContinuousScale.defaultTickCount = 5;
ContinuousScale.defaultMaxTickCount = 6;
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/ticks.mjs

/* harmony default export */ function util_ticks(start, stop, count, minCount, maxCount) {
  if (count < 2) {
    return ticks_range(start, stop, stop - start);
  }
  const step = tickStep(start, stop, count, minCount, maxCount);
  if (isNaN(step)) {
    return new NumericTicks(0);
  }
  start = Math.ceil(start / step) * step;
  stop = Math.floor(stop / step) * step;
  return ticks_range(start, stop, step);
}
const tickMultipliers = [1, 2, 5, 10];
function tickStep(a, b, count, minCount = 0, maxCount = Infinity) {
  const rawStep = (b - a) / count;
  const power = Math.floor(Math.log10(rawStep));
  const step = Math.pow(10, power);
  const m = tickMultipliers.map(multiplier => {
    const s = multiplier * step;
    const c = Math.ceil((b - a) / s);
    const isWithinBounds = c >= minCount && c <= maxCount;
    const diffCount = Math.abs(c - count);
    return {
      multiplier,
      isWithinBounds,
      diffCount
    };
  }).sort((a, b) => {
    if (a.isWithinBounds !== b.isWithinBounds) {
      return a.isWithinBounds ? -1 : 1;
    }
    return a.diffCount - b.diffCount;
  })[0].multiplier;
  if (!m || isNaN(m)) {
    return NaN;
  }
  return m * step;
}
function singleTickDomain(a, b) {
  const power = Math.floor(Math.log10(b - a));
  const step = Math.pow(10, power);
  return tickMultipliers.map(multiplier => {
    const s = multiplier * step;
    const start = Math.floor(a / s) * s;
    const end = Math.ceil(b / s) * s;
    const error = 1 - (b - a) / (end - start);
    const domain = [start, end];
    return {
      error,
      domain
    };
  }).sort((a, b) => a.error - b.error)[0].domain;
}
class NumericTicks extends Array {
  constructor(fractionDigits, elements) {
    super();
    if (elements) {
      for (let i = 0, n = elements.length; i < n; i++) {
        this[i] = elements[i];
      }
    }
    this.fractionDigits = fractionDigits;
  }
}
function ticks_range(start, stop, step) {
  const countDigits = expNo => {
    var _a, _b;
    const parts = expNo.split('e');
    return Math.max(((_b = (_a = parts[0].split('.')[1]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) - Number(parts[1]), 0);
  };
  const fractionalDigits = countDigits((step % 1).toExponential());
  const f = Math.pow(10, fractionalDigits);
  const n = Math.ceil((stop - start) / step);
  const values = new NumericTicks(fractionalDigits);
  for (let i = 0; i <= n; i++) {
    const value = start + step * i;
    values.push(Math.round(value * f) / f);
  }
  return values;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/timeFormat.mjs

const CONSTANTS = {
  periods: ['AM', 'PM'],
  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
};
function dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {
  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 60000;
  const timeOneDay = 3600000 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date, startDay) {
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  // Days before week 1 are in week 0.
  return 0;
}
const SUNDAY = 0;
const MONDAY = 1;
const THURSDAY = 4;
function isoWeekOfYear(date, year = date.getFullYear()) {
  const firstOfYear = new Date(year, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  // Days before week 1 are in week 52/53 of previous year.
  return isoWeekOfYear(date, year - 1);
}
function timezone(date) {
  const offset = date.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset);
  const sign = offset > 0 ? '-' : '+';
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, '0')}${pad(Math.floor(unsignedOffset % 60), 2, '0')}`;
}
const FORMATTERS = {
  a: d => CONSTANTS.shortDays[d.getDay()],
  A: d => CONSTANTS.days[d.getDay()],
  b: d => CONSTANTS.shortMonths[d.getMonth()],
  B: d => CONSTANTS.months[d.getMonth()],
  c: '%x, %X',
  d: (d, p) => pad(d.getDate(), 2, p !== null && p !== void 0 ? p : '0'),
  e: '%_d',
  f: (d, p) => pad(d.getMilliseconds() * 1000, 6, p !== null && p !== void 0 ? p : '0'),
  H: (d, p) => pad(d.getHours(), 2, p !== null && p !== void 0 ? p : '0'),
  I: (d, p) => {
    const hours = d.getHours() % 12;
    return hours === 0 ? '12' : pad(hours, 2, p !== null && p !== void 0 ? p : '0');
  },
  j: (d, p) => pad(dayOfYear(d) + 1, 3, p !== null && p !== void 0 ? p : '0'),
  m: (d, p) => pad(d.getMonth() + 1, 2, p !== null && p !== void 0 ? p : '0'),
  M: (d, p) => pad(d.getMinutes(), 2, p !== null && p !== void 0 ? p : '0'),
  L: (d, p) => pad(d.getMilliseconds(), 3, p !== null && p !== void 0 ? p : '0'),
  p: d => d.getHours() < 12 ? 'AM' : 'PM',
  Q: d => String(d.getTime()),
  s: d => String(Math.floor(d.getTime() / 1000)),
  S: (d, p) => pad(d.getSeconds(), 2, p !== null && p !== void 0 ? p : '0'),
  u: d => {
    let day = d.getDay();
    if (day < 1) day += 7;
    return String(day % 7);
  },
  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p !== null && p !== void 0 ? p : '0'),
  V: (d, p) => pad(isoWeekOfYear(d), 2, p !== null && p !== void 0 ? p : '0'),
  w: (d, p) => pad(d.getDay(), 2, p !== null && p !== void 0 ? p : '0'),
  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p !== null && p !== void 0 ? p : '0'),
  x: '%-m/%-d/%Y',
  X: '%-I:%M:%S %p',
  y: (d, p) => pad(d.getFullYear() % 100, 2, p !== null && p !== void 0 ? p : '0'),
  Y: (d, p) => pad(d.getFullYear(), 4, p !== null && p !== void 0 ? p : '0'),
  Z: d => timezone(d),
  '%': () => '%'
};
const PADS = {
  _: ' ',
  '0': '0',
  '-': ''
};
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf('%');
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0) break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === 'function') {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === 'string') {
      const formatter = buildFormatter(maybeFormatter);
      formatParts.push([formatter, maybePad]);
    } else {
      formatParts.push(`${maybePad !== null && maybePad !== void 0 ? maybePad : ''}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return dateTime => {
    const dateTimeAsDate = typeof dateTime === 'number' ? new Date(dateTime) : dateTime;
    return formatParts.map(c => typeof c === 'string' ? c : c[0](dateTimeAsDate, c[1])).join('');
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scale/timeScale.mjs














var DefaultTimeFormats;
(function (DefaultTimeFormats) {
  DefaultTimeFormats[DefaultTimeFormats["MILLISECOND"] = 0] = "MILLISECOND";
  DefaultTimeFormats[DefaultTimeFormats["SECOND"] = 1] = "SECOND";
  DefaultTimeFormats[DefaultTimeFormats["MINUTE"] = 2] = "MINUTE";
  DefaultTimeFormats[DefaultTimeFormats["HOUR"] = 3] = "HOUR";
  DefaultTimeFormats[DefaultTimeFormats["WEEK_DAY"] = 4] = "WEEK_DAY";
  DefaultTimeFormats[DefaultTimeFormats["SHORT_MONTH"] = 5] = "SHORT_MONTH";
  DefaultTimeFormats[DefaultTimeFormats["MONTH"] = 6] = "MONTH";
  DefaultTimeFormats[DefaultTimeFormats["SHORT_YEAR"] = 7] = "SHORT_YEAR";
  DefaultTimeFormats[DefaultTimeFormats["YEAR"] = 8] = "YEAR";
})(DefaultTimeFormats || (DefaultTimeFormats = {}));
const formatStrings = {
  [DefaultTimeFormats.MILLISECOND]: '.%L',
  [DefaultTimeFormats.SECOND]: ':%S',
  [DefaultTimeFormats.MINUTE]: '%I:%M',
  [DefaultTimeFormats.HOUR]: '%I %p',
  [DefaultTimeFormats.WEEK_DAY]: '%a',
  [DefaultTimeFormats.SHORT_MONTH]: '%b %d',
  [DefaultTimeFormats.MONTH]: '%B',
  [DefaultTimeFormats.SHORT_YEAR]: '%y',
  [DefaultTimeFormats.YEAR]: '%Y'
};
function toNumber(x) {
  return x instanceof Date ? x.getTime() : x;
}
class TimeScale extends ContinuousScale {
  constructor() {
    super([new Date(2022, 11, 7), new Date(2022, 11, 8)], [0, 1]);
    this.type = 'time';
    this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'interval', 'minTickCount', 'maxTickCount'];
    this.year = time_year;
    this.month = time_month;
    this.week = week;
    this.day = time_day;
    this.hour = time_hour;
    this.minute = time_minute;
    this.second = time_second;
    this.millisecond = time_millisecond;
    /**
     * Array of default tick intervals in the following format:
     *
     *     [
     *         interval (unit of time),
     *         number of units (step),
     *         the length of that number of units in milliseconds
     *     ]
     */
    this.tickIntervals = [[this.second, 1, durationSecond], [this.second, 5, 5 * durationSecond], [this.second, 15, 15 * durationSecond], [this.second, 30, 30 * durationSecond], [this.minute, 1, durationMinute], [this.minute, 5, 5 * durationMinute], [this.minute, 15, 15 * durationMinute], [this.minute, 30, 30 * durationMinute], [this.hour, 1, durationHour], [this.hour, 3, 3 * durationHour], [this.hour, 6, 6 * durationHour], [this.hour, 12, 12 * durationHour], [this.day, 1, durationDay], [this.day, 2, 2 * durationDay], [this.week, 1, durationWeek], [this.week, 2, 2 * durationWeek], [this.week, 3, 3 * durationWeek], [this.month, 1, durationMonth], [this.month, 2, 2 * durationMonth], [this.month, 3, 3 * durationMonth], [this.month, 4, 4 * durationMonth], [this.month, 6, 6 * durationMonth], [this.year, 1, durationYear]];
  }
  toDomain(d) {
    return new Date(d);
  }
  calculateDefaultTickFormat(ticks = []) {
    let defaultTimeFormat = DefaultTimeFormats.YEAR;
    const updateFormat = format => {
      if (format < defaultTimeFormat) {
        defaultTimeFormat = format;
      }
    };
    for (const value of ticks) {
      const format = this.getLowestGranularityFormat(value);
      updateFormat(format);
    }
    const firstTick = toNumber(ticks[0]);
    const lastTick = toNumber(ticks[ticks.length - 1]);
    const startYear = new Date(firstTick).getFullYear();
    const stopYear = new Date(lastTick).getFullYear();
    const yearChange = stopYear - startYear > 0;
    return this.buildFormatString(defaultTimeFormat, yearChange);
  }
  buildFormatString(defaultTimeFormat, yearChange) {
    let formatStringArray = [formatStrings[defaultTimeFormat]];
    let timeEndIndex = 0;
    const domain = this.getDomain();
    const start = Math.min(...domain.map(toNumber));
    const stop = Math.max(...domain.map(toNumber));
    const extent = stop - start;
    switch (defaultTimeFormat) {
      case DefaultTimeFormats.SECOND:
        if (extent / durationMinute > 1) {
          formatStringArray.push(formatStrings[DefaultTimeFormats.MINUTE]);
        }
      // fall through deliberately
      case DefaultTimeFormats.MINUTE:
        if (extent / durationHour > 1) {
          formatStringArray.push(formatStrings[DefaultTimeFormats.HOUR]);
        }
      // fall through deliberately
      case DefaultTimeFormats.HOUR:
        timeEndIndex = formatStringArray.length;
        if (extent / durationDay > 1) {
          formatStringArray.push(formatStrings[DefaultTimeFormats.WEEK_DAY]);
        }
      // fall through deliberately
      case DefaultTimeFormats.WEEK_DAY:
        if (extent / durationWeek > 1 || yearChange) {
          // if it's more than a week or there is a year change, don't show week day
          const weekDayIndex = formatStringArray.indexOf(formatStrings[DefaultTimeFormats.WEEK_DAY]);
          if (weekDayIndex > -1) {
            formatStringArray.splice(weekDayIndex, 1, formatStrings[DefaultTimeFormats.SHORT_MONTH]);
          }
        }
      // fall through deliberately
      case DefaultTimeFormats.SHORT_MONTH:
      case DefaultTimeFormats.MONTH:
        if (extent / durationYear > 1 || yearChange) {
          formatStringArray.push(formatStrings[DefaultTimeFormats.YEAR]);
        }
      // fall through deliberately
      default:
        break;
    }
    if (timeEndIndex < formatStringArray.length) {
      // Insert a gap between all date components.
      formatStringArray = [...formatStringArray.slice(0, timeEndIndex), formatStringArray.slice(timeEndIndex).join(' ')];
    }
    if (timeEndIndex > 0) {
      // Reverse order of time components, since they should be displayed in descending
      // granularity.
      formatStringArray = [...formatStringArray.slice(0, timeEndIndex).reverse(), ...formatStringArray.slice(timeEndIndex)];
      if (timeEndIndex < formatStringArray.length) {
        // Insert a gap between time and date components.
        formatStringArray.splice(timeEndIndex, 0, ' ');
      }
    }
    return formatStringArray.join('');
  }
  getLowestGranularityFormat(value) {
    if (this.second.floor(value) < value) {
      return DefaultTimeFormats.MILLISECOND;
    } else if (this.minute.floor(value) < value) {
      return DefaultTimeFormats.SECOND;
    } else if (this.hour.floor(value) < value) {
      return DefaultTimeFormats.MINUTE;
    } else if (this.day.floor(value) < value) {
      return DefaultTimeFormats.HOUR;
    } else if (this.month.floor(value) < value) {
      if (this.week.floor(value) < value) {
        return DefaultTimeFormats.WEEK_DAY;
      }
      return DefaultTimeFormats.SHORT_MONTH;
    } else if (this.year.floor(value) < value) {
      return DefaultTimeFormats.MONTH;
    }
    return DefaultTimeFormats.YEAR;
  }
  defaultTickFormat(ticks) {
    const formatString = this.calculateDefaultTickFormat(ticks);
    return date => buildFormatter(formatString)(date);
  }
  /**
   * @param options Tick interval options.
   * @param options.start The start time (timestamp).
   * @param options.stop The end time (timestamp).
   * @param options.count Number of intervals between ticks.
   */
  getTickInterval({
    start,
    stop,
    count,
    minCount,
    maxCount
  }) {
    const {
      tickIntervals
    } = this;
    let countableTimeInterval;
    let step;
    const tickCount = count !== null && count !== void 0 ? count : ContinuousScale.defaultTickCount;
    const target = Math.abs(stop - start) / Math.max(tickCount, 1);
    let i = 0;
    while (i < tickIntervals.length && target > tickIntervals[i][2]) {
      i++;
    }
    if (i === 0) {
      step = Math.max(tickStep(start, stop, tickCount, minCount, maxCount), 1);
      countableTimeInterval = this.millisecond;
    } else if (i === tickIntervals.length) {
      const y0 = start / durationYear;
      const y1 = stop / durationYear;
      step = tickStep(y0, y1, tickCount, minCount, maxCount);
      countableTimeInterval = this.year;
    } else {
      const diff0 = target - tickIntervals[i - 1][2];
      const diff1 = tickIntervals[i][2] - target;
      const index = diff0 < diff1 ? i - 1 : i;
      [countableTimeInterval, step] = tickIntervals[index];
    }
    return countableTimeInterval.every(step);
  }
  invert(y) {
    return new Date(super.invert(y));
  }
  /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */
  ticks() {
    if (!this.domain || this.domain.length < 2) {
      return [];
    }
    this.refresh();
    const [t0, t1] = this.getDomain().map(toNumber);
    if (this.interval !== undefined) {
      return this.getTicksForInterval({
        start: t0,
        stop: t1
      });
    }
    if (this.nice) {
      const {
        tickCount
      } = this;
      if (tickCount === 2) {
        return this.niceDomain;
      }
      if (tickCount === 1) {
        return this.niceDomain.slice(0, 1);
      }
    }
    return this.getDefaultTicks({
      start: t0,
      stop: t1
    });
  }
  getDefaultTicks({
    start,
    stop
  }) {
    const t = this.getTickInterval({
      start,
      stop,
      count: this.tickCount,
      minCount: this.minTickCount,
      maxCount: this.maxTickCount
    });
    return t ? t.range(new Date(start), new Date(stop)) : []; // inclusive stop
  }

  getTicksForInterval({
    start,
    stop
  }) {
    const {
      interval,
      tickIntervals
    } = this;
    if (!interval) {
      return [];
    }
    if (interval instanceof TimeInterval) {
      const ticks = interval.range(new Date(start), new Date(stop));
      if (this.isDenseInterval({
        start,
        stop,
        interval,
        count: ticks.length
      })) {
        return this.getDefaultTicks({
          start,
          stop
        });
      }
      return ticks;
    }
    const absInterval = Math.abs(interval);
    if (this.isDenseInterval({
      start,
      stop,
      interval: absInterval
    })) {
      return this.getDefaultTicks({
        start,
        stop
      });
    }
    const reversedInterval = [...tickIntervals];
    reversedInterval.reverse();
    const timeInterval = reversedInterval.find(tickInterval => absInterval % tickInterval[2] === 0);
    if (timeInterval) {
      const i = timeInterval[0].every(absInterval / (timeInterval[2] / timeInterval[1]));
      return i.range(new Date(start), new Date(stop));
    }
    let date = new Date(start);
    const stopDate = new Date(stop);
    const ticks = [];
    while (date <= stopDate) {
      ticks.push(date);
      date = new Date(date);
      date.setMilliseconds(date.getMilliseconds() + absInterval);
    }
    return ticks;
  }
  /**
   * Returns a time format function suitable for displaying tick values.
   * @param specifier If the specifier string is provided, this method is equivalent to
   * the {@link TimeLocaleObject.format} method.
   * If no specifier is provided, this method returns the default time format function.
   */
  tickFormat({
    ticks,
    specifier
  }) {
    return specifier == undefined ? this.defaultTickFormat(ticks) : buildFormatter(specifier);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  /**
   * Extends the domain so that it starts and ends on nice round values.
   * This method typically modifies the scaleâs domain, and may only extend the bounds to the nearest round value.
   */
  updateNiceDomain() {
    const maxAttempts = 4;
    let [d0, d1] = this.domain;
    for (let i = 0; i < maxAttempts; i++) {
      this.updateNiceDomainIteration(d0, d1);
      const [n0, n1] = this.niceDomain;
      if (toNumber(d0) === toNumber(n0) && toNumber(d1) === toNumber(n1)) {
        break;
      }
      d0 = n0;
      d1 = n1;
    }
  }
  updateNiceDomainIteration(d0, d1) {
    const start = toNumber(d0);
    const stop = toNumber(d1);
    const {
      interval
    } = this;
    let i;
    if (interval instanceof TimeInterval) {
      i = interval;
    } else {
      const tickCount = typeof interval === 'number' ? (stop - start) / Math.max(interval, 1) : this.tickCount;
      i = this.getTickInterval({
        start,
        stop,
        count: tickCount,
        minCount: this.minTickCount,
        maxCount: this.maxTickCount
      });
    }
    if (i) {
      const intervalRange = i.range(d0, d1, true);
      const n0 = intervalRange[0];
      const n1 = intervalRange[intervalRange.length - 1];
      this.niceDomain = [n0, n1];
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/numberFormat.mjs
const group = content => `(${content})`;
const optionalGroup = content => `${group(content)}?`;
const nonCapturingGroup = content => optionalGroup(`?:${content}`);
const formatRegEx = (() => {
  const fill = '.';
  const align = '[<>=^]';
  const sign = '[+\\-( ]';
  const symbol = '[$â¬Â£Â¥â£â¹#]';
  const zero = '0';
  const width = '\\d+';
  const comma = ',';
  const precision = '\\d+';
  const tilde = '~';
  const type = '[%a-z]';
  return new RegExp(['^', nonCapturingGroup(`${optionalGroup(fill)}${group(align)}`), optionalGroup(sign), optionalGroup(symbol), optionalGroup(zero), optionalGroup(width), optionalGroup(comma), nonCapturingGroup(`\\.${group(precision)}`), optionalGroup(tilde), optionalGroup(type), '$'].join(''), 'i');
})();
const surroundedRegEx = (() => {
  const prefix = '.*?';
  const content = '.+?';
  const suffix = '.*?';
  return new RegExp(['^', group(prefix), `#\\{${group(content)}\\}`, group(suffix), '$'].join(''));
})();
function parseFormatter(formatter) {
  let prefix;
  let suffix;
  const surrounded = surroundedRegEx.exec(formatter);
  if (surrounded) {
    [, prefix, formatter, suffix] = surrounded;
  }
  const match = formatRegEx.exec(formatter);
  if (!match) {
    throw new Error(`The number formatter is invalid: ${formatter}`);
  }
  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;
  return {
    fill,
    align,
    sign,
    symbol,
    zero,
    width: parseInt(width),
    comma,
    precision: parseInt(precision),
    trim: Boolean(trim),
    type,
    prefix,
    suffix
  };
}
function format(formatter) {
  const options = typeof formatter === 'string' ? parseFormatter(formatter) : formatter;
  const {
    fill,
    align,
    sign = '-',
    symbol,
    zero,
    width,
    comma,
    type,
    prefix = '',
    suffix = ''
  } = options;
  let {
    precision,
    trim
  } = options;
  let formatBody;
  if (!type) {
    formatBody = decimalTypes['g'];
    trim = true;
  } else if (type in decimalTypes && type in integerTypes) {
    formatBody = isNaN(precision) ? integerTypes[type] : decimalTypes[type];
  } else if (type in decimalTypes) {
    formatBody = decimalTypes[type];
  } else if (type in integerTypes) {
    formatBody = integerTypes[type];
  } else {
    throw new Error(`The number formatter type is invalid: ${type}`);
  }
  if (isNaN(precision)) {
    precision = type ? 6 : 12;
  }
  return n => {
    let result = formatBody(n, precision);
    if (trim) {
      result = removeTrailingZeros(result);
    }
    if (comma) {
      result = insertSeparator(result, comma);
    }
    result = addSign(n, result, sign);
    if (symbol && symbol !== '#') {
      result = `${symbol}${result}`;
    }
    if (symbol === '#' && type === 'x') {
      result = `0x${result}`;
    }
    if (type === 's') {
      result = `${result}${getSIPrefix(n)}`;
    }
    if (type === '%' || type === 'p') {
      result = `${result}%`;
    }
    if (!isNaN(width)) {
      result = addPadding(result, width, fill !== null && fill !== void 0 ? fill : zero, align);
    }
    result = `${prefix}${result}${suffix}`;
    return result;
  };
}
const absFloor = n => Math.floor(Math.abs(n));
const integerTypes = {
  b: n => absFloor(n).toString(2),
  c: n => String.fromCharCode(n),
  d: n => Math.round(Math.abs(n)).toFixed(0),
  o: n => absFloor(n).toString(8),
  x: n => absFloor(n).toString(16),
  X: n => integerTypes.x(n).toUpperCase(),
  n: n => integerTypes.d(n),
  '%': n => `${absFloor(n * 100).toFixed(0)}`
};
const decimalTypes = {
  e: (n, f) => Math.abs(n).toExponential(f),
  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),
  f: (n, f) => Math.abs(n).toFixed(f),
  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),
  g: (n, f) => {
    if (n === 0) {
      return '0';
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    if (p >= -4 && p < f) {
      return a.toFixed(f - 1 - p);
    }
    return a.toExponential(f - 1);
  },
  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),
  n: (n, f) => decimalTypes.g(n, f),
  p: (n, f) => decimalTypes.r(n * 100, f),
  r: (n, f) => {
    if (n === 0) {
      return '0';
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    const q = p - (f - 1);
    if (q <= 0) {
      return a.toFixed(-q);
    }
    const x = Math.pow(10, q);
    return (Math.round(a / x) * x).toFixed();
  },
  s: (n, f) => {
    const p = getSIPrefixPower(n);
    return decimalTypes.r(n / Math.pow(10, p), f);
  },
  '%': (n, f) => decimalTypes.f(n * 100, f)
};
function removeTrailingZeros(numString) {
  return numString.replace(/\.0+$/, '').replace(/(\.[1-9])0+$/, '$1');
}
function insertSeparator(numString, separator) {
  let dotIndex = numString.indexOf('.');
  if (dotIndex < 0) {
    dotIndex = numString.length;
  }
  const integerChars = numString.substring(0, dotIndex).split('');
  const fractionalPart = numString.substring(dotIndex);
  for (let i = integerChars.length - 3; i > 0; i -= 3) {
    integerChars.splice(i, 0, separator);
  }
  return `${integerChars.join('')}${fractionalPart}`;
}
function getSIPrefix(n) {
  return siPrefixes[getSIPrefixPower(n)];
}
function getSIPrefixPower(n) {
  const power = Math.log10(Math.abs(n));
  const p = Math.floor(power / 3) * 3;
  return Math.max(minSIPrefix, Math.min(maxSIPrefix, p));
}
const minSIPrefix = -24;
const maxSIPrefix = 24;
const siPrefixes = {
  [minSIPrefix]: 'y',
  [-21]: 'z',
  [-18]: 'a',
  [-15]: 'f',
  [-12]: 'p',
  [-9]: 'n',
  [-6]: 'Âµ',
  [-3]: 'm',
  [0]: '',
  [3]: 'k',
  [6]: 'M',
  [9]: 'G',
  [12]: 'T',
  [15]: 'P',
  [18]: 'E',
  [21]: 'Z',
  [maxSIPrefix]: 'Y'
};
const minusSign = '\u2212';
function addSign(num, numString, signType = '') {
  if (signType === '(') {
    return num >= 0 ? numString : `(${numString})`;
  }
  const plusSign = signType === '+' ? '+' : '';
  return `${num >= 0 ? plusSign : minusSign}${numString}`;
}
function addPadding(numString, width, fill = ' ', align = '>') {
  let result = numString;
  if (align === '>' || !align) {
    result = result.padStart(width, fill);
  } else if (align === '<') {
    result = result.padEnd(width, fill);
  } else if (align === '^') {
    const padWidth = Math.max(0, width - result.length);
    const padLeft = Math.ceil(padWidth / 2);
    const padRight = Math.floor(padWidth / 2);
    result = result.padStart(padLeft + result.length, fill);
    result = result.padEnd(padRight + result.length, fill);
  }
  return result;
}
function tickFormat(ticks, formatter) {
  const options = parseFormatter(formatter !== null && formatter !== void 0 ? formatter : ',f');
  if (isNaN(options.precision)) {
    if (options.type === 'f' || options.type === '%') {
      options.precision = Math.max(...ticks.map(x => {
        if (typeof x !== 'number' || x === 0) {
          return 0;
        }
        const l = Math.floor(Math.log10(Math.abs(x)));
        const digits = options.type ? 6 : 12;
        const exp = x.toExponential(digits - 1).replace(/\.?0+e/, 'e');
        const dotIndex = exp.indexOf('.');
        if (dotIndex < 0) {
          return l >= 0 ? 0 : -l;
        }
        const s = exp.indexOf('e') - dotIndex;
        return Math.max(0, s - l - 1);
      }));
    } else if (!options.type || options.type in decimalTypes) {
      options.precision = Math.max(...ticks.map(x => {
        if (typeof x !== 'number') {
          return 0;
        }
        const exp = x.toExponential((options.type ? 6 : 12) - 1).replace(/\.?0+e/, 'e');
        return exp.substring(0, exp.indexOf('e')).replace('.', '').length;
      }));
    }
  }
  const f = format(options);
  return n => f(Number(n));
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scale/logScale.mjs

var logScale_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




const identity = x => x;
class LogScale extends ContinuousScale {
  constructor() {
    super([1, 10], [0, 1]);
    this.type = 'log';
    this.base = 10;
    this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'base'];
    this.baseLog = identity;
    this.basePow = identity;
    this.log = x => {
      return this.domain[0] >= 0 ? this.baseLog(x) : -this.baseLog(-x);
    };
    this.pow = x => {
      return this.domain[0] >= 0 ? this.basePow(x) : -this.basePow(-x);
    };
  }
  toDomain(d) {
    return d;
  }
  transform(x) {
    return this.domain[0] >= 0 ? Math.log(x) : -Math.log(-x);
  }
  transformInvert(x) {
    return this.domain[0] >= 0 ? Math.exp(x) : -Math.exp(-x);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    this.updateLogFn();
    this.updatePowFn();
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  updateLogFn() {
    const {
      base
    } = this;
    let log;
    if (base === 10) {
      log = Math.log10;
    } else if (base === Math.E) {
      log = Math.log;
    } else if (base === 2) {
      log = Math.log2;
    } else {
      const logBase = Math.log(base);
      log = x => Math.log(x) / logBase;
    }
    this.baseLog = log;
  }
  updatePowFn() {
    const {
      base
    } = this;
    let pow;
    if (base === 10) {
      pow = LogScale.pow10;
    } else if (base === Math.E) {
      pow = Math.exp;
    } else {
      pow = x => Math.pow(base, x);
    }
    this.basePow = pow;
  }
  updateNiceDomain() {
    const [d0, d1] = this.domain;
    const n0 = this.pow(Math.floor(this.log(d0)));
    const n1 = this.pow(Math.ceil(this.log(d1)));
    this.niceDomain = [n0, n1];
  }
  static pow10(x) {
    return x >= 0 ? Math.pow(10, x) : 1 / Math.pow(10, -x);
  }
  ticks() {
    var _a;
    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : 10;
    if (!this.domain || this.domain.length < 2 || count < 1) {
      return [];
    }
    this.refresh();
    const base = this.base;
    const [d0, d1] = this.getDomain();
    let p0 = this.log(d0);
    let p1 = this.log(d1);
    if (this.interval) {
      const step = Math.abs(this.interval);
      const absDiff = Math.abs(p1 - p0);
      const ticks = ticks_range(p0, p1, Math.min(absDiff, step)).map(x => this.pow(x)).filter(t => t >= d0 && t <= d1);
      if (!this.isDenseInterval({
        start: d0,
        stop: d1,
        interval: step,
        count: ticks.length
      })) {
        return ticks;
      }
    }
    const isBaseInteger = base % 1 === 0;
    const isDiffLarge = p1 - p0 >= count;
    if (!isBaseInteger || isDiffLarge) {
      // Returns [10^1, 10^2, 10^3, 10^4, ...]
      return util_ticks(p0, p1, Math.min(p1 - p0, count)).map(x => this.pow(x));
    }
    const ticks = [];
    const isPositive = d0 > 0;
    p0 = Math.floor(p0) - 1;
    p1 = Math.round(p1) + 1;
    const min = Math.min(...this.range);
    const max = Math.max(...this.range);
    const availableSpacing = (max - min) / count;
    let lastTickPosition = Infinity;
    for (let p = p0; p <= p1; p++) {
      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
      for (let k = 1; k < base; k++) {
        const q = isPositive ? k : base - k + 1;
        const t = this.pow(p) * q;
        const tickPosition = this.convert(t);
        const prevSpacing = Math.abs(lastTickPosition - tickPosition);
        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
        if (t >= d0 && t <= d1 && (k === 1 || fits)) {
          ticks.push(t);
          lastTickPosition = tickPosition;
        }
      }
    }
    return ticks;
  }
  tickFormat({
    count,
    ticks,
    specifier
  }) {
    const {
      base
    } = this;
    if (specifier == null) {
      specifier = base === 10 ? '.0e' : ',';
    }
    if (typeof specifier !== 'function') {
      specifier = format(specifier);
    }
    if (count === Infinity) {
      return specifier;
    }
    if (ticks == null) {
      this.ticks();
    }
    return d => {
      return specifier(d);
    };
  }
}
logScale_decorate([Validate(NUMBER(0))], LogScale.prototype, "base", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/default.mjs

function Default(defaultValue, replaces = [undefined]) {
  return decorator_addTransformToInstanceProperty((_, __, v) => {
    if (replaces.includes(v)) {
      return defaultValue;
    }
    return v;
  });
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/array.mjs
function extent(values) {
  const {
    length
  } = values;
  if (length === 0) {
    return undefined;
  }
  let min = Infinity;
  let max = -Infinity;
  for (let i = 0; i < length; i++) {
    let v = values[i];
    if (v instanceof Date) {
      v = v.getTime();
    }
    if (typeof v !== 'number') {
      continue;
    }
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
  }
  const extent = [min, max];
  if (extent.some(v => !isFinite(v))) {
    return undefined;
  }
  return extent;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/label.mjs
var label_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Label {
  constructor() {
    this.enabled = true;
    this.fontSize = 12;
    this.fontFamily = 'Verdana, sans-serif';
    this.fontStyle = undefined;
    this.fontWeight = undefined;
    this.color = 'rgba(70, 70, 70, 1)';
  }
  getFont() {
    return getFont(this);
  }
}
label_decorate([Validate(BOOLEAN)], Label.prototype, "enabled", void 0);
label_decorate([Validate(NUMBER(0))], Label.prototype, "fontSize", void 0);
label_decorate([Validate(STRING)], Label.prototype, "fontFamily", void 0);
label_decorate([Validate(OPT_FONT_STYLE)], Label.prototype, "fontStyle", void 0);
label_decorate([Validate(OPT_FONT_WEIGHT)], Label.prototype, "fontWeight", void 0);
label_decorate([Validate(COLOR_STRING)], Label.prototype, "color", void 0);
function calculateLabelRotation(opts) {
  const {
    parallelFlipRotation = 0,
    regularFlipRotation = 0
  } = opts;
  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  // Flip if the axis rotation angle is in the top hemisphere.
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (opts.parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return {
    configuredRotation,
    defaultRotation,
    parallelFlipFlag,
    regularFlipFlag
  };
}
function getLabelSpacing(minSpacing, rotated) {
  if (!isNaN(minSpacing)) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
  if (parallel && !labelRotation) {
    if (sideFlag * parallelFlipFlag === -1) {
      return 'hanging';
    } else {
      return 'bottom';
    }
  }
  return 'middle';
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return 'end';
      }
    } else {
      return 'center';
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return 'end';
  }
  return 'start';
}
function calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {
  // Text.computeBBox() does not take into account any of the transformations that have been applied to the label nodes, only the width and height are useful.
  // Rather than taking into account all transformations including those of parent nodes which would be the result of `computeTransformedBBox()`, giving the x and y in the entire axis coordinate space,
  // take into account only the rotation and translation applied to individual label nodes to get the x y coordinates of the labels relative to each other
  // this makes label collision detection a lot simpler
  const {
    width,
    height
  } = bbox;
  const translatedBBox = new BBox(labelX, labelY, 0, 0);
  labelMatrix.transformBBox(translatedBBox, bbox);
  const {
    x = 0,
    y = 0
  } = bbox;
  bbox.width = width;
  bbox.height = height;
  return {
    point: {
      x,
      y,
      size: 0
    },
    label: {
      width,
      height,
      text
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/axis.mjs

var axis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var axis_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
























const TICK_COUNT = predicateWithMessage((v, ctx) => NUMBER(0)(v, ctx) || v instanceof TimeInterval, `expecting a tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`);
const OPT_TICK_COUNT = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, TICK_COUNT), `expecting an optional tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`);
const OPT_TICK_INTERVAL = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v, ctx) => v !== 0 && NUMBER(0)(v, ctx) || v instanceof TimeInterval), `expecting an optional non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`);
const GRID_STYLE_KEYS = ['stroke', 'lineDash'];
const GRID_STYLE = predicateWithMessage(ARRAY(undefined, o => {
  for (const key in o) {
    if (!GRID_STYLE_KEYS.includes(key)) {
      return false;
    }
  }
  return true;
}), `expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'`);
var Tags;
(function (Tags) {
  Tags[Tags["TickLine"] = 0] = "TickLine";
  Tags[Tags["TickLabel"] = 1] = "TickLabel";
  Tags[Tags["GridLine"] = 2] = "GridLine";
  Tags[Tags["GridArc"] = 3] = "GridArc";
  Tags[Tags["AxisLine"] = 4] = "AxisLine";
})(Tags || (Tags = {}));
var TickGenerationType;
(function (TickGenerationType) {
  TickGenerationType[TickGenerationType["CREATE"] = 0] = "CREATE";
  TickGenerationType[TickGenerationType["CREATE_SECONDARY"] = 1] = "CREATE_SECONDARY";
  TickGenerationType[TickGenerationType["FILTER"] = 2] = "FILTER";
  TickGenerationType[TickGenerationType["VALUES"] = 3] = "VALUES";
})(TickGenerationType || (TickGenerationType = {}));
class AxisLine {
  constructor() {
    this.width = 1;
    this.color = 'rgba(195, 195, 195, 1)';
  }
}
axis_decorate([Validate(NUMBER(0))], AxisLine.prototype, "width", void 0);
axis_decorate([Validate(OPT_COLOR_STRING)], AxisLine.prototype, "color", void 0);
class BaseAxisTick {
  constructor() {
    this.enabled = true;
    /**
     * The line width to be used by axis ticks.
     */
    this.width = 1;
    /**
     * The line length to be used by axis ticks.
     */
    this.size = 6;
    /**
     * The color of the axis ticks.
     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.
     */
    this.color = 'rgba(195, 195, 195, 1)';
    /**
     * A hint of how many ticks to use (the exact number of ticks might differ),
     * a `TimeInterval` or a `CountableTimeInterval`.
     * For example:
     *
     *     axis.tick.count = 5;
     *     axis.tick.count = year;
     *     axis.tick.count = month.every(6);
     */
    this.count = undefined;
    this.interval = undefined;
    this.values = undefined;
    this.minSpacing = NaN;
  }
}
axis_decorate([Validate(BOOLEAN)], BaseAxisTick.prototype, "enabled", void 0);
axis_decorate([Validate(NUMBER(0))], BaseAxisTick.prototype, "width", void 0);
axis_decorate([Validate(NUMBER(0))], BaseAxisTick.prototype, "size", void 0);
axis_decorate([Validate(OPT_COLOR_STRING)], BaseAxisTick.prototype, "color", void 0);
axis_decorate([Validate(OPT_TICK_COUNT), Deprecated('Use tick.interval or tick.minSpacing and tick.maxSpacing instead')], BaseAxisTick.prototype, "count", void 0);
axis_decorate([Validate(OPT_TICK_INTERVAL)], BaseAxisTick.prototype, "interval", void 0);
axis_decorate([Validate(OPT_ARRAY())], BaseAxisTick.prototype, "values", void 0);
axis_decorate([Validate(AND(NUMBER_OR_NAN(1), LESS_THAN('maxSpacing'))), Default(NaN)], BaseAxisTick.prototype, "minSpacing", void 0);
class AxisLabel {
  constructor() {
    this.enabled = true;
    /** If set to `false`, axis labels will not be wrapped on multiple lines. */
    this.autoWrap = false;
    /** Used to constrain the width of the label when `autoWrap` is `true`, if the label text width exceeds the `maxWidth`, it will be wrapped on multiple lines automatically. If `maxWidth` is omitted, a default width constraint will be applied. */
    this.maxWidth = undefined;
    /** Used to constrain the height of the multiline label, if the label text height exceeds the `maxHeight`, it will be truncated automatically. If `maxHeight` is omitted, a default height constraint will be applied. */
    this.maxHeight = undefined;
    this.fontStyle = undefined;
    this.fontWeight = undefined;
    this.fontSize = 12;
    this.fontFamily = 'Verdana, sans-serif';
    /**
     * The padding between the labels and the ticks.
     */
    this.padding = 5;
    /**
     * Minimum gap in pixels between the axis labels before being removed to avoid collisions.
     */
    this.minSpacing = NaN;
    /**
     * The color of the labels.
     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.
     */
    this.color = 'rgba(87, 87, 87, 1)';
    /**
     * Custom label rotation in degrees.
     * Labels are rendered perpendicular to the axis line by default.
     * Or parallel to the axis line, if the {@link parallel} is set to `true`.
     * The value of this config is used as the angular offset/deflection
     * from the default rotation.
     */
    this.rotation = undefined;
    /**
     * If specified and axis labels may collide, they are rotated to reduce collisions. If the
     * `rotation` property is specified, it takes precedence.
     */
    this.autoRotate = undefined;
    /**
     * Rotation angle to use when autoRotate is applied.
     */
    this.autoRotateAngle = 335;
    /**
     * Avoid axis label collision by automatically reducing the number of ticks displayed. If set to `false`, axis labels may collide.
     */
    this.avoidCollisions = true;
    /**
     * By default labels and ticks are positioned to the left of the axis line.
     * `true` positions the labels to the right of the axis line.
     * However, if the axis is rotated, it's easier to think in terms
     * of this side or the opposite side, rather than left and right.
     * We use the term `mirror` for conciseness, although it's not
     * true mirroring - for example, when a label is rotated, so that
     * it is inclined at the 45 degree angle, text flowing from north-west
     * to south-east, ending at the tick to the left of the axis line,
     * and then we set this config to `true`, the text will still be flowing
     * from north-west to south-east, _starting_ at the tick to the right
     * of the axis line.
     */
    this.mirrored = false;
    /**
     * Labels are rendered perpendicular to the axis line by default.
     * Setting this config to `true` makes labels render parallel to the axis line
     * and center aligns labels' text at the ticks.
     */
    this.parallel = false;
    /**
     * In case {@param value} is a number, the {@param fractionDigits} parameter will
     * be provided as well. The `fractionDigits` corresponds to the number of fraction
     * digits used by the tick step. For example, if the tick step is `0.0005`,
     * the `fractionDigits` is 4.
     */
    this.formatter = undefined;
    this.format = undefined;
  }
  /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */
  getSideFlag() {
    return this.mirrored ? 1 : -1;
  }
  getFont() {
    return getFont(this);
  }
}
axis_decorate([Validate(BOOLEAN)], AxisLabel.prototype, "enabled", void 0);
axis_decorate([Validate(OPT_BOOLEAN)], AxisLabel.prototype, "autoWrap", void 0);
axis_decorate([Validate(OPT_NUMBER(0))], AxisLabel.prototype, "maxWidth", void 0);
axis_decorate([Validate(OPT_NUMBER(0))], AxisLabel.prototype, "maxHeight", void 0);
axis_decorate([Validate(OPT_FONT_STYLE)], AxisLabel.prototype, "fontStyle", void 0);
axis_decorate([Validate(OPT_FONT_WEIGHT)], AxisLabel.prototype, "fontWeight", void 0);
axis_decorate([Validate(NUMBER(1))], AxisLabel.prototype, "fontSize", void 0);
axis_decorate([Validate(STRING)], AxisLabel.prototype, "fontFamily", void 0);
axis_decorate([Validate(NUMBER(0))], AxisLabel.prototype, "padding", void 0);
axis_decorate([Validate(NUMBER_OR_NAN()), Default(NaN)], AxisLabel.prototype, "minSpacing", void 0);
axis_decorate([Validate(OPT_COLOR_STRING)], AxisLabel.prototype, "color", void 0);
axis_decorate([Validate(OPT_NUMBER(-360, 360))], AxisLabel.prototype, "rotation", void 0);
axis_decorate([Validate(OPT_BOOLEAN)], AxisLabel.prototype, "autoRotate", void 0);
axis_decorate([Validate(NUMBER(-360, 360))], AxisLabel.prototype, "autoRotateAngle", void 0);
axis_decorate([Validate(BOOLEAN)], AxisLabel.prototype, "avoidCollisions", void 0);
axis_decorate([Validate(BOOLEAN)], AxisLabel.prototype, "mirrored", void 0);
axis_decorate([Validate(BOOLEAN)], AxisLabel.prototype, "parallel", void 0);
axis_decorate([Validate(OPT_STRING)], AxisLabel.prototype, "format", void 0);
class AxisTitle {
  constructor() {
    this.enabled = false;
    this.text = undefined;
    this.fontStyle = undefined;
    this.fontWeight = undefined;
    this.fontSize = 10;
    this.fontFamily = 'sans-serif';
    this.color = undefined;
    this.wrapping = 'always';
    this.formatter = undefined;
  }
}
axis_decorate([Validate(BOOLEAN)], AxisTitle.prototype, "enabled", void 0);
axis_decorate([Validate(OPT_STRING)], AxisTitle.prototype, "text", void 0);
axis_decorate([Validate(OPT_FONT_STYLE)], AxisTitle.prototype, "fontStyle", void 0);
axis_decorate([Validate(OPT_FONT_WEIGHT)], AxisTitle.prototype, "fontWeight", void 0);
axis_decorate([Validate(NUMBER(0))], AxisTitle.prototype, "fontSize", void 0);
axis_decorate([Validate(STRING)], AxisTitle.prototype, "fontFamily", void 0);
axis_decorate([Validate(OPT_COLOR_STRING)], AxisTitle.prototype, "color", void 0);
axis_decorate([Validate(TEXT_WRAP)], AxisTitle.prototype, "wrapping", void 0);
axis_decorate([Validate(OPT_FUNCTION)], AxisTitle.prototype, "formatter", void 0);
/**
 * A general purpose linear axis with no notion of orientation.
 * The axis is always rendered vertically, with horizontal labels positioned to the left
 * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,
 * so that it can be used as a top, right, bottom, left, radial or any other kind
 * of linear axis.
 * The generic `D` parameter is the type of the domain of the axis' scale.
 * The output range of the axis' scale is always numeric (screen coordinates).
 */
class Axis {
  constructor(moduleCtx, scale) {
    this.moduleCtx = moduleCtx;
    this.id = createId(this);
    this.nice = true;
    this.dataDomain = [];
    this.axisGroup = new Group({
      name: `${this.id}-axis`,
      zIndex: Layers.AXIS_ZINDEX
    });
    this.lineNode = this.axisGroup.appendChild(new Line());
    this.tickLineGroup = this.axisGroup.appendChild(new Group({
      name: `${this.id}-Axis-tick-lines`,
      zIndex: Layers.AXIS_ZINDEX
    }));
    this.tickLabelGroup = this.axisGroup.appendChild(new Group({
      name: `${this.id}-Axis-tick-labels`,
      zIndex: Layers.AXIS_ZINDEX
    }));
    this.crossLineGroup = new Group({
      name: `${this.id}-CrossLines`
    });
    this.gridGroup = new Group({
      name: `${this.id}-Axis-grid`
    });
    this.gridLineGroup = this.gridGroup.appendChild(new Group({
      name: `${this.id}-gridLines`,
      zIndex: Layers.AXIS_GRID_ZINDEX
    }));
    this.gridArcGroup = this.gridGroup.appendChild(new Group({
      name: `${this.id}-gridArcs`,
      zIndex: Layers.AXIS_GRID_ZINDEX
    }));
    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line);
    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text);
    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line);
    this.gridArcGroupSelection = Selection.select(this.gridArcGroup, Arc);
    this._crossLines = [];
    this.line = new AxisLine();
    this.tick = this.createTick();
    this.label = new AxisLabel();
    this.translation = {
      x: 0,
      y: 0
    };
    this.rotation = 0; // axis rotation angle in degrees
    this.layout = {
      label: {
        fractionDigits: 0,
        padding: this.label.padding,
        format: this.label.format
      }
    };
    this.range = [0, 1];
    this.visibleRange = [0, 1];
    this.title = undefined;
    this._titleCaption = new Caption();
    /**
     * The length of the grid. The grid is only visible in case of a non-zero value.
     * In case {@link radialGrid} is `true`, the value is interpreted as an angle
     * (in degrees).
     */
    this._gridLength = 0;
    /**
     * The array of styles to cycle through when rendering grid lines.
     * For example, use two {@link GridStyle} objects for alternating styles.
     * Contains only one {@link GridStyle} object by default, meaning all grid lines
     * have the same style.
     */
    this.gridStyle = [{
      stroke: 'rgba(219, 219, 219, 1)',
      lineDash: [4, 2]
    }];
    /**
     * `false` - render grid as lines of {@link gridLength} that extend the ticks
     *           on the opposite side of the axis
     * `true` - render grid as concentric circles that go through the ticks
     */
    this._radialGrid = false;
    this.fractionDigits = 0;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    this.gridPadding = 0;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    this.seriesAreaPadding = 0;
    this.thickness = 0;
    this.maxThickness = Infinity;
    this._scale = scale;
    this.refreshScale();
    this._titleCaption.node.rotation = -Math.PI / 2;
    this.axisGroup.appendChild(this._titleCaption.node);
  }
  get scale() {
    return this._scale;
  }
  set crossLines(value) {
    var _a, _b;
    (_a = this._crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => this.detachCrossLine(crossLine));
    this._crossLines = value;
    (_b = this._crossLines) === null || _b === void 0 ? void 0 : _b.forEach(crossLine => {
      this.attachCrossLine(crossLine);
      this.initCrossLine(crossLine);
    });
  }
  get crossLines() {
    return this._crossLines;
  }
  attachCrossLine(crossLine) {
    this.crossLineGroup.appendChild(crossLine.group);
  }
  detachCrossLine(crossLine) {
    this.crossLineGroup.removeChild(crossLine.group);
  }
  destroy() {
    // For override by sub-classes.
  }
  refreshScale() {
    var _a;
    this.range = this.scale.range.slice();
    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {
      this.initCrossLine(crossLine);
    });
  }
  updateRange() {
    var _a;
    const {
      range: rr,
      visibleRange: vr,
      scale
    } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start = rr[0] - shift;
    scale.range = [start, start + span];
    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {
      crossLine.clippedRange = [rr[0], rr[1]];
    });
  }
  setCrossLinesVisible(visible) {
    this.crossLineGroup.visible = visible;
  }
  attachAxis(node, nextNode) {
    node.insertBefore(this.gridGroup, nextNode);
    node.insertBefore(this.axisGroup, nextNode);
    node.insertBefore(this.crossLineGroup, nextNode);
  }
  detachAxis(node) {
    node.removeChild(this.gridGroup);
    node.removeChild(this.axisGroup);
    node.removeChild(this.crossLineGroup);
  }
  /**
   * Checks if a point or an object is in range.
   * @param x A point (or object's starting point).
   * @param width Object's width.
   * @param tolerance Expands the range on both ends by this amount.
   */
  inRange(x, width = 0, tolerance = 0) {
    return this.inRangeEx(x, width, tolerance) === 0;
  }
  inRangeEx(x, width = 0, tolerance = 0) {
    const {
      range
    } = this;
    // Account for inverted ranges, for example [500, 100] as well as [100, 500]
    const min = Math.min(range[0], range[1]);
    const max = Math.max(range[0], range[1]);
    if (x + width < min - tolerance) {
      return -1; // left of range
    }

    if (x > max + tolerance) {
      return 1; // right of range
    }

    return 0; // in range
  }

  onLabelFormatChange(ticks, format) {
    const {
      scale,
      fractionDigits
    } = this;
    const logScale = scale instanceof LogScale;
    const defaultLabelFormatter = !logScale && fractionDigits > 0 ? x => typeof x === 'number' ? x.toFixed(fractionDigits) : String(x) : x => String(x);
    if (format && scale && scale.tickFormat) {
      try {
        this.labelFormatter = scale.tickFormat({
          ticks,
          specifier: format
        });
      } catch (e) {
        this.labelFormatter = defaultLabelFormatter;
        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);
      }
    } else {
      this.labelFormatter = defaultLabelFormatter;
    }
  }
  setDomain() {
    var _a;
    const {
      scale,
      dataDomain,
      tick: {
        values: tickValues
      }
    } = this;
    if (tickValues && scale instanceof ContinuousScale) {
      const [tickMin, tickMax] = (_a = extent(tickValues)) !== null && _a !== void 0 ? _a : [Infinity, -Infinity];
      const min = Math.min(scale.fromDomain(dataDomain[0]), tickMin);
      const max = Math.max(scale.fromDomain(dataDomain[1]), tickMax);
      scale.domain = [scale.toDomain(min), scale.toDomain(max)];
    } else {
      scale.domain = dataDomain;
    }
  }
  setTickInterval(interval) {
    var _a;
    this.scale.interval = (_a = this.tick.interval) !== null && _a !== void 0 ? _a : interval;
  }
  setTickCount(count, minTickCount, maxTickCount) {
    const {
      scale
    } = this;
    if (!(count && scale instanceof ContinuousScale)) {
      return;
    }
    if (typeof count === 'number') {
      scale.tickCount = count;
      scale.minTickCount = minTickCount !== null && minTickCount !== void 0 ? minTickCount : 0;
      scale.maxTickCount = maxTickCount !== null && maxTickCount !== void 0 ? maxTickCount : Infinity;
      return;
    }
    if (scale instanceof TimeScale) {
      this.setTickInterval(count);
    }
  }
  set gridLength(value) {
    var _a;
    // Was visible and now invisible, or was invisible and now visible.
    if (this._gridLength && !value || !this._gridLength && value) {
      this.gridLineGroupSelection = this.gridLineGroupSelection.clear();
      this.gridArcGroupSelection = this.gridArcGroupSelection.clear();
    }
    this._gridLength = value;
    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {
      this.initCrossLine(crossLine);
    });
  }
  get gridLength() {
    return this._gridLength;
  }
  set radialGrid(value) {
    if (this._radialGrid !== value) {
      this._radialGrid = value;
      this.gridLineGroupSelection = this.gridLineGroupSelection.clear();
      this.gridArcGroupSelection = this.gridArcGroupSelection.clear();
    }
  }
  get radialGrid() {
    return this._radialGrid;
  }
  createTick() {
    return new BaseAxisTick();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */
  update(primaryTickCount) {
    const {
      rotation,
      parallelFlipRotation,
      regularFlipRotation
    } = this.calculateRotations();
    const sideFlag = this.label.getSideFlag();
    const labelX = sideFlag * (this.tick.size + this.label.padding + this.seriesAreaPadding);
    this.updateScale();
    this.updatePosition({
      rotation,
      sideFlag
    });
    this.updateLine();
    const _a = this.generateTicks({
        primaryTickCount,
        parallelFlipRotation,
        regularFlipRotation,
        labelX,
        sideFlag
      }),
      {
        tickData,
        combinedRotation,
        textBaseline,
        textAlign
      } = _a,
      ticksResult = axis_rest(_a, ["tickData", "combinedRotation", "textBaseline", "textAlign"]);
    this.updateSelections(tickData.ticks);
    this.updateLabels({
      tickLabelGroupSelection: this.tickLabelGroupSelection,
      combinedRotation,
      textBaseline,
      textAlign,
      labelX
    });
    this.updateVisibility();
    this.updateGridLines(sideFlag);
    this.updateTickLines(sideFlag);
    this.updateTitle({
      anyTickVisible: tickData.ticks.length > 0,
      sideFlag
    });
    this.updateCrossLines({
      rotation,
      parallelFlipRotation,
      regularFlipRotation,
      sideFlag
    });
    this.updateLayoutState();
    primaryTickCount = ticksResult.primaryTickCount;
    return primaryTickCount;
  }
  updateLayoutState() {
    this.layout.label = {
      fractionDigits: this.fractionDigits,
      padding: this.label.padding,
      format: this.label.format
    };
  }
  updateScale() {
    this.updateRange();
    this.calculateDomain();
    this.setDomain();
    this.setTickInterval(this.tick.interval);
    const {
      scale,
      nice
    } = this;
    if (!(scale instanceof ContinuousScale)) {
      return;
    }
    this.setTickCount(this.tick.count);
    scale.nice = nice;
    scale.update();
  }
  calculateRotations() {
    const rotation = toRadians(this.rotation);
    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to
    // flip the labels to avoid upside-down text, when the axis is rotated
    // such that it is in the right hemisphere, i.e. the angle of rotation
    // is in the [0, Ï] interval.
    // The rotation angle is normalized, so that we have an easier time checking
    // if it's in the said interval. Since the axis is always rendered vertically
    // and then rotated, zero rotation means 12 (not 3) o-clock.
    // -1 = flip
    //  1 = don't flip (default)
    const parallelFlipRotation = normalizeAngle360(rotation);
    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
    return {
      rotation,
      parallelFlipRotation,
      regularFlipRotation
    };
  }
  generateTicks({
    primaryTickCount,
    parallelFlipRotation,
    regularFlipRotation,
    labelX,
    sideFlag
  }) {
    var _a;
    const {
      scale,
      tick,
      label: {
        parallel,
        rotation,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight
      }
    } = this;
    const secondaryAxis = primaryTickCount !== undefined;
    const {
      defaultRotation,
      configuredRotation,
      parallelFlipFlag,
      regularFlipFlag
    } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    const initialRotation = configuredRotation + defaultRotation;
    const labelMatrix = new Matrix();
    const {
      maxTickCount
    } = this.estimateTickCount({
      minSpacing: tick.minSpacing,
      maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN
    });
    const continuous = scale instanceof ContinuousScale;
    const maxIterations = tick.count || !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
    const textProps = {
      fontFamily,
      fontSize,
      fontStyle,
      fontWeight,
      textBaseline,
      textAlign
    };
    let tickData = {
      rawTicks: [],
      ticks: [],
      labelCount: 0
    };
    let index = 0;
    let autoRotation = 0;
    let labelOverlap = true;
    let terminate = false;
    while (labelOverlap && index <= maxIterations) {
      if (terminate) {
        break;
      }
      autoRotation = 0;
      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
      const tickStrategies = this.getTickStrategies({
        secondaryAxis,
        index
      });
      for (const strategy of tickStrategies) {
        ({
          tickData,
          index,
          autoRotation,
          terminate
        } = strategy({
          index,
          tickData,
          textProps,
          labelOverlap,
          terminate,
          primaryTickCount
        }));
        const ticksResult = tickData.ticks;
        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
        const rotated = configuredRotation !== 0 || autoRotation !== 0;
        const rotation = initialRotation + autoRotation;
        labelOverlap = this.checkLabelOverlap(rotation, rotated, labelMatrix, ticksResult, labelX, Object.assign(Object.assign({}, textProps), {
          textAlign
        }));
      }
    }
    const combinedRotation = defaultRotation + configuredRotation + autoRotation;
    if (!secondaryAxis && tickData.rawTicks.length > 0) {
      primaryTickCount = tickData.rawTicks.length;
    }
    return {
      tickData,
      primaryTickCount,
      combinedRotation,
      textBaseline,
      textAlign
    };
  }
  getTickStrategies({
    index,
    secondaryAxis
  }) {
    const {
      scale,
      label,
      tick
    } = this;
    const continuous = scale instanceof ContinuousScale;
    const avoidLabelCollisions = label.enabled && label.avoidCollisions;
    const filterTicks = !(continuous && this.tick.count === undefined) && index !== 0 && avoidLabelCollisions;
    const autoRotate = label.autoRotate === true && label.rotation === undefined;
    const strategies = [];
    let tickGenerationType;
    if (this.tick.values) {
      tickGenerationType = TickGenerationType.VALUES;
    } else if (secondaryAxis) {
      tickGenerationType = TickGenerationType.CREATE_SECONDARY;
    } else if (filterTicks) {
      tickGenerationType = TickGenerationType.FILTER;
    } else {
      tickGenerationType = TickGenerationType.CREATE;
    }
    const tickGenerationStrategy = ({
      index,
      tickData,
      primaryTickCount,
      terminate
    }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);
    strategies.push(tickGenerationStrategy);
    if (!continuous && !isNaN(tick.minSpacing)) {
      const tickFilterStrategy = ({
        index,
        tickData,
        primaryTickCount,
        terminate
      }) => this.createTickData(TickGenerationType.FILTER, index, tickData, terminate, primaryTickCount);
      strategies.push(tickFilterStrategy);
    }
    if (!avoidLabelCollisions) {
      return strategies;
    }
    if (label.autoWrap) {
      const autoWrapStrategy = ({
        index,
        tickData,
        textProps
      }) => this.wrapLabels(tickData, index, textProps);
      strategies.push(autoWrapStrategy);
    } else if (autoRotate) {
      const autoRotateStrategy = ({
        index,
        tickData,
        labelOverlap,
        terminate
      }) => ({
        index,
        tickData,
        autoRotation: this.getAutoRotation(labelOverlap),
        terminate
      });
      strategies.push(autoRotateStrategy);
    }
    return strategies;
  }
  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {
    var _a, _b, _c;
    const {
      scale,
      tick
    } = this;
    const {
      maxTickCount,
      minTickCount,
      defaultTickCount
    } = this.estimateTickCount({
      minSpacing: tick.minSpacing,
      maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN
    });
    const continuous = scale instanceof ContinuousScale;
    const maxIterations = tick.count || !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let tickCount = (_b = tick.count) !== null && _b !== void 0 ? _b : continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
    const regenerateTicks = tick.interval === undefined && tick.values === undefined && tick.count === undefined && tickCount > minTickCount && (continuous || tickGenerationType === TickGenerationType.FILTER);
    let unchanged = true;
    while (unchanged && index <= maxIterations) {
      const prevTicks = tickData.rawTicks;
      tickCount = (_c = tick.count) !== null && _c !== void 0 ? _c : continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
      const {
        rawTicks,
        ticks,
        labelCount
      } = this.getTicks({
        tickGenerationType,
        previousTicks: prevTicks,
        tickCount,
        minTickCount,
        maxTickCount,
        primaryTickCount
      });
      tickData.rawTicks = rawTicks;
      tickData.ticks = ticks;
      tickData.labelCount = labelCount;
      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;
      index++;
    }
    const shouldTerminate = tick.interval !== undefined || tick.values !== undefined;
    terminate || (terminate = shouldTerminate);
    return {
      tickData,
      index,
      autoRotation: 0,
      terminate
    };
  }
  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {
    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);
    const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);
    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);
    return axisLabelsOverlap(labelData, labelSpacing);
  }
  createLabelData(tickData, labelX, textProps, labelMatrix) {
    const labelData = [];
    for (const tickDatum of tickData) {
      const {
        tickLabel,
        translationY
      } = tickDatum;
      if (tickLabel === '' || tickLabel == undefined) {
        // skip user hidden ticks
        continue;
      }
      const lines = splitText(tickLabel);
      const {
        width,
        height
      } = measureText(lines, labelX, translationY, textProps);
      const bbox = new BBox(labelX, translationY, width, height);
      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);
      labelData.push(labelDatum);
    }
    return labelData;
  }
  getAutoRotation(labelOveralap) {
    return labelOveralap ? normalizeAngle360(toRadians(this.label.autoRotateAngle)) : 0;
  }
  getTicks({
    tickGenerationType,
    previousTicks,
    tickCount,
    minTickCount,
    maxTickCount,
    primaryTickCount
  }) {
    var _a;
    const {
      scale
    } = this;
    let rawTicks = [];
    switch (tickGenerationType) {
      case TickGenerationType.VALUES:
        rawTicks = this.tick.values;
        break;
      case TickGenerationType.CREATE_SECONDARY:
        // `updateSecondaryAxisTicks` mutates `scale.domain` based on `primaryTickCount`
        rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);
        break;
      case TickGenerationType.FILTER:
        rawTicks = this.filterTicks(previousTicks, tickCount);
        break;
      default:
        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);
        break;
    }
    // When the scale domain or the ticks change, the label format may change
    this.onLabelFormatChange(rawTicks, this.label.format);
    // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.
    this.fractionDigits = rawTicks.fractionDigits >= 0 ? rawTicks.fractionDigits : 0;
    const halfBandwidth = ((_a = this.scale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;
    const ticks = [];
    let labelCount = 0;
    for (let i = 0; i < rawTicks.length; i++) {
      const rawTick = rawTicks[i];
      const translationY = scale.convert(rawTick) + halfBandwidth;
      const tickLabel = this.formatTick(rawTick, i);
      ticks.push({
        tick: rawTick,
        tickLabel,
        translationY
      });
      if (tickLabel === '' || tickLabel == undefined) {
        continue;
      }
      labelCount++;
    }
    return {
      rawTicks,
      ticks,
      labelCount
    };
  }
  filterTicks(ticks, tickCount) {
    var _a;
    const tickSpacing = !isNaN(this.tick.minSpacing) || !isNaN((_a = this.tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN);
    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;
    return ticks.filter((_, i) => i % keepEvery === 0);
  }
  createTicks(tickCount, minTickCount, maxTickCount) {
    this.setTickCount(tickCount, minTickCount, maxTickCount);
    return this.scale.ticks();
  }
  estimateTickCount({
    minSpacing,
    maxSpacing
  }) {
    const availableRange = this.calculateAvailableRange();
    const defaultMinSpacing = Math.max(Axis.defaultTickMinSpacing, availableRange / ContinuousScale.defaultMaxTickCount);
    if (isNaN(minSpacing) && isNaN(maxSpacing)) {
      minSpacing = defaultMinSpacing;
      maxSpacing = availableRange;
      if (minSpacing > maxSpacing) {
        // Take automatic minSpacing if there is a conflict.
        maxSpacing = minSpacing;
      }
    } else if (isNaN(minSpacing)) {
      minSpacing = defaultMinSpacing;
      if (minSpacing > maxSpacing) {
        // Take user-suplied maxSpacing if there is a conflict.
        minSpacing = maxSpacing;
      }
    } else if (isNaN(maxSpacing)) {
      maxSpacing = availableRange;
      if (minSpacing > maxSpacing) {
        // Take user-suplied minSpacing if there is a conflict.
        maxSpacing = minSpacing;
      }
    }
    const maxTickCount = Math.max(1, Math.floor(availableRange / minSpacing));
    const minTickCount = Math.min(maxTickCount, Math.ceil(availableRange / maxSpacing));
    let defaultTickCount = ContinuousScale.defaultTickCount;
    if (defaultTickCount > maxTickCount) {
      defaultTickCount = maxTickCount;
    } else if (defaultTickCount < minTickCount) {
      defaultTickCount = minTickCount;
    }
    return {
      minTickCount,
      maxTickCount,
      defaultTickCount
    };
  }
  updateVisibility() {
    const {
      range: requestedRange
    } = this;
    const requestedRangeMin = Math.min(...requestedRange);
    const requestedRangeMax = Math.max(...requestedRange);
    const visibleFn = node => {
      const min = Math.floor(requestedRangeMin);
      const max = Math.ceil(requestedRangeMax);
      if (min === max) {
        node.visible = false;
        return;
      }
      // Fix an effect of rounding error
      if (node.translationY >= min - 1 && node.translationY < min) {
        node.translationY = min;
      }
      if (node.translationY > max && node.translationY <= max + 1) {
        node.translationY = max;
      }
      const visible = node.translationY >= min && node.translationY <= max;
      node.visible = visible;
    };
    const {
      gridLineGroupSelection,
      gridArcGroupSelection,
      tickLineGroupSelection,
      tickLabelGroupSelection
    } = this;
    gridLineGroupSelection.each(visibleFn);
    gridArcGroupSelection.each(visibleFn);
    tickLineGroupSelection.each(visibleFn);
    tickLabelGroupSelection.each(visibleFn);
    this.tickLineGroup.visible = this.tick.enabled;
    this.tickLabelGroup.visible = this.label.enabled;
  }
  updateCrossLines({
    rotation,
    parallelFlipRotation,
    regularFlipRotation,
    sideFlag
  }) {
    var _a;
    const anySeriesActive = this.isAnySeriesActive();
    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {
      var _a;
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;
      crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.update(anySeriesActive);
    });
  }
  updateTickLines(sideFlag) {
    const {
      tick
    } = this;
    this.tickLineGroupSelection.each(line => {
      line.strokeWidth = tick.width;
      line.stroke = tick.color;
      line.x1 = sideFlag * tick.size;
      line.x2 = 0;
      line.y1 = 0;
      line.y2 = 0;
    });
  }
  calculateAvailableRange() {
    const {
      range: requestedRange
    } = this;
    const min = Math.min(...requestedRange);
    const max = Math.max(...requestedRange);
    return max - min;
  }
  calculateDomain() {
    // Placeholder for subclasses to override.
  }
  updatePosition({
    rotation,
    sideFlag
  }) {
    const {
      crossLineGroup,
      axisGroup,
      gridGroup,
      translation,
      gridLineGroupSelection,
      gridPadding,
      gridLength
    } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    crossLineGroup.translationX = translationX;
    crossLineGroup.translationY = translationY;
    crossLineGroup.rotation = rotation;
    axisGroup.translationX = translationX;
    axisGroup.translationY = translationY;
    axisGroup.rotation = rotation;
    gridGroup.translationX = translationX;
    gridGroup.translationY = translationY;
    gridGroup.rotation = rotation;
    gridLineGroupSelection.each(line => {
      line.x1 = gridPadding;
      line.x2 = -sideFlag * gridLength + gridPadding;
      line.y1 = 0;
      line.y2 = 0;
    });
  }
  updateSecondaryAxisTicks(_primaryTickCount) {
    throw new Error('AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.');
  }
  updateSelections(data) {
    const gridData = this.gridLength ? data : [];
    const gridLineGroupSelection = this.radialGrid ? this.gridLineGroupSelection : this.gridLineGroupSelection.update(gridData, group => {
      const node = new Line();
      node.tag = Tags.GridLine;
      group.append(node);
    });
    const gridArcGroupSelection = this.radialGrid ? this.gridArcGroupSelection.update(gridData, group => {
      const node = new Arc();
      node.tag = Tags.GridArc;
      group.append(node);
    }) : this.gridArcGroupSelection;
    const tickLineGroupSelection = this.tickLineGroupSelection.update(data, group => {
      const line = new Line();
      line.tag = Tags.TickLine;
      group.appendChild(line);
    });
    const tickLabelGroupSelection = this.tickLabelGroupSelection.update(data, group => {
      const text = new Text();
      text.tag = Tags.TickLabel;
      group.appendChild(text);
    });
    // We need raw `translationY` values on `datum` for accurate label collision detection in axes.update()
    // But node `translationY` values must be rounded to get pixel grid alignment
    const translationFn = node => node.translationY = Math.round(node.datum.translationY);
    gridLineGroupSelection.each(translationFn);
    gridArcGroupSelection.each(translationFn);
    tickLineGroupSelection.each(translationFn);
    tickLabelGroupSelection.each(translationFn);
    this.tickLineGroupSelection = tickLineGroupSelection;
    this.tickLabelGroupSelection = tickLabelGroupSelection;
    this.gridLineGroupSelection = gridLineGroupSelection;
    this.gridArcGroupSelection = gridArcGroupSelection;
  }
  updateGridLines(sideFlag) {
    var _a;
    const {
      gridStyle,
      scale,
      tick,
      gridPadding,
      gridLength
    } = this;
    if (gridLength && gridStyle.length) {
      const styleCount = gridStyle.length;
      let grid;
      if (this.radialGrid) {
        const angularGridLength = normalizeAngle360Inclusive(toRadians(gridLength));
        const halfBandwidth = ((_a = this.scale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;
        grid = this.gridArcGroupSelection.each((arc, datum) => {
          const radius = Math.round(scale.convert(datum) + halfBandwidth);
          arc.centerX = 0;
          arc.centerY = scale.range[0] - radius;
          arc.endAngle = angularGridLength;
          arc.radius = radius;
        });
      } else {
        grid = this.gridLineGroupSelection.each(line => {
          line.x1 = gridPadding;
          line.x2 = -sideFlag * gridLength + gridPadding;
          line.y1 = 0;
          line.y2 = 0;
        });
      }
      grid.each((node, _, index) => {
        const style = gridStyle[index % styleCount];
        node.stroke = style.stroke;
        node.strokeWidth = tick.width;
        node.lineDash = style.lineDash;
        node.fill = undefined;
      });
    }
  }
  updateLabels({
    tickLabelGroupSelection,
    combinedRotation,
    textBaseline,
    textAlign,
    labelX
  }) {
    const {
      label,
      label: {
        enabled: labelsEnabled
      }
    } = this;
    if (!labelsEnabled) {
      return {
        labelData: [],
        rotated: false
      };
    }
    // Apply label option values
    tickLabelGroupSelection.each((node, datum) => {
      const {
        tickLabel
      } = datum;
      node.fontStyle = label.fontStyle;
      node.fontWeight = label.fontWeight;
      node.fontSize = label.fontSize;
      node.fontFamily = label.fontFamily;
      node.fill = label.color;
      node.text = tickLabel;
      const userHidden = node.text === '' || node.text == undefined;
      if (userHidden) {
        node.visible = false; // hide empty labels
        return;
      }
      // Position labels
      node.textBaseline = textBaseline;
      node.textAlign = textAlign;
      node.x = labelX;
      node.rotationCenterX = labelX;
      node.rotation = combinedRotation;
      node.visible = true;
    });
  }
  wrapLabels(tickData, index, labelProps) {
    const {
      label: {
        parallel,
        maxWidth,
        maxHeight
      }
    } = this;
    const defaultMaxLabelWidth = parallel ? Math.round(this.calculateAvailableRange() / tickData.labelCount) : this.maxThickness;
    const maxLabelWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : defaultMaxLabelWidth;
    const defaultMaxLabelHeight = parallel ? this.maxThickness : Math.round(this.calculateAvailableRange() / tickData.labelCount);
    const maxLabelHeight = maxHeight !== null && maxHeight !== void 0 ? maxHeight : defaultMaxLabelHeight;
    tickData.ticks.forEach(tickDatum => {
      const {
        tickLabel
      } = tickDatum;
      const wrapping = 'hyphenate';
      const wrappedTickLabel = Text.wrap(tickLabel, maxLabelWidth, maxLabelHeight, labelProps, wrapping);
      tickDatum.tickLabel = wrappedTickLabel;
    });
    return {
      tickData,
      index,
      autoRotation: 0,
      terminate: true
    };
  }
  updateLine() {
    // Render axis line.
    const {
      lineNode,
      range: requestedRange
    } = this;
    lineNode.x1 = 0;
    lineNode.x2 = 0;
    lineNode.y1 = requestedRange[0];
    lineNode.y2 = requestedRange[1];
    lineNode.strokeWidth = this.line.width;
    lineNode.stroke = this.line.color;
    lineNode.visible = true;
  }
  updateTitle({
    anyTickVisible,
    sideFlag
  }) {
    var _a;
    const identityFormatter = params => params.defaultValue;
    const {
      rotation,
      title,
      _titleCaption,
      lineNode,
      range: requestedRange,
      tickLineGroup,
      tickLabelGroup,
      moduleCtx: {
        callbackCache
      }
    } = this;
    const {
      formatter = identityFormatter
    } = (_a = this.title) !== null && _a !== void 0 ? _a : {};
    if (!title) {
      _titleCaption.enabled = false;
      return;
    }
    _titleCaption.enabled = title.enabled;
    _titleCaption.fontFamily = title.fontFamily;
    _titleCaption.fontSize = title.fontSize;
    _titleCaption.fontStyle = title.fontStyle;
    _titleCaption.fontWeight = title.fontWeight;
    _titleCaption.color = title.color;
    _titleCaption.wrapping = title.wrapping;
    let titleVisible = false;
    const titleNode = _titleCaption.node;
    if (title.enabled && lineNode.visible) {
      titleVisible = true;
      const parallelFlipRotation = normalizeAngle360(rotation);
      const padding = Caption.PADDING;
      const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;
      titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;
      titleNode.x = Math.floor(titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2);
      let bboxYDimension = 0;
      if (anyTickVisible) {
        const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup]);
        const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;
        if (Math.abs(tickWidth) < Infinity) {
          bboxYDimension += tickWidth;
        }
      }
      if (sideFlag === -1) {
        titleNode.y = Math.floor(titleRotationFlag * (-padding - bboxYDimension));
      } else {
        titleNode.y = Math.floor(-padding - bboxYDimension);
      }
      titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';
      titleNode.text = callbackCache.call(formatter, this.getTitleFormatterParams());
    }
    titleNode.visible = titleVisible;
  }
  // For formatting (nice rounded) tick values.
  formatTick(datum, index) {
    var _a, _b;
    const {
      label,
      labelFormatter,
      fractionDigits,
      moduleCtx: {
        callbackCache
      }
    } = this;
    if (label.formatter) {
      const defaultValue = fractionDigits > 0 ? datum : String(datum);
      return (_a = callbackCache.call(label.formatter, {
        value: defaultValue,
        index,
        fractionDigits,
        formatter: labelFormatter
      })) !== null && _a !== void 0 ? _a : defaultValue;
    } else if (labelFormatter) {
      return (_b = callbackCache.call(labelFormatter, datum)) !== null && _b !== void 0 ? _b : String(datum);
    }
    // The axis is using a logScale or the`datum` is an integer, a string or an object
    return String(datum);
  }
  // For formatting arbitrary values between the ticks.
  formatDatum(datum) {
    return String(datum);
  }
  computeBBox() {
    return this.axisGroup.computeBBox();
  }
  initCrossLine(crossLine) {
    crossLine.scale = this.scale;
    crossLine.gridLength = this.gridLength;
  }
  isAnySeriesActive() {
    return false;
  }
  clipTickLines(x, y, width, height) {
    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));
  }
  clipGrid(x, y, width, height) {
    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));
  }
  calculatePadding(min, _max) {
    return Math.abs(min * 0.01);
  }
}
Axis.defaultTickMinSpacing = 50;
axis_decorate([Validate(BOOLEAN)], Axis.prototype, "nice", void 0);
axis_decorate([Validate(GRID_STYLE)], Axis.prototype, "gridStyle", void 0);
axis_decorate([Validate(NUMBER(0))], Axis.prototype, "thickness", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scale/linearScale.mjs



/**
 * Maps continuous domain to a continuous range.
 */
class LinearScale extends ContinuousScale {
  constructor() {
    super([0, 1], [0, 1]);
    this.type = 'linear';
  }
  toDomain(d) {
    return d;
  }
  ticks() {
    var _a;
    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;
    if (!this.domain || this.domain.length < 2 || count < 1 || this.domain.some(d => !isFinite(d))) {
      return [];
    }
    this.refresh();
    const [d0, d1] = this.getDomain();
    const {
      interval
    } = this;
    if (interval) {
      const step = Math.abs(interval);
      if (!this.isDenseInterval({
        start: d0,
        stop: d1,
        interval: step
      })) {
        return ticks_range(d0, d1, step);
      }
    }
    return util_ticks(d0, d1, count, this.minTickCount, this.maxTickCount);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  /**
   * Extends the domain so that it starts and ends on nice round values.
   * @param count Tick count.
   */
  updateNiceDomain() {
    var _a, _b;
    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;
    let [start, stop] = this.domain;
    if (count < 1) {
      this.niceDomain = [start, stop];
      return;
    }
    if (count === 1) {
      this.niceDomain = singleTickDomain(start, stop);
      return;
    }
    const maxAttempts = 4;
    let prev0 = start;
    let prev1 = stop;
    for (let i = 0; i < maxAttempts; i++) {
      const step = (_b = this.interval) !== null && _b !== void 0 ? _b : tickStep(start, stop, count, this.minTickCount, this.maxTickCount);
      const [d0, d1] = this.domain;
      if (step >= 1) {
        start = Math.floor(d0 / step) * step;
        stop = Math.ceil(d1 / step) * step;
      } else {
        // Prevent floating point error
        const s = 1 / step;
        start = Math.floor(d0 * s) / s;
        stop = Math.ceil(d1 * s) / s;
      }
      if (start === prev0 && stop === prev1) {
        break;
      }
      prev0 = start;
      prev1 = stop;
    }
    this.niceDomain = [start, stop];
  }
  tickFormat({
    ticks,
    specifier
  }) {
    return tickFormat(ticks !== null && ticks !== void 0 ? ticks : this.ticks(), specifier);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chartAxis.mjs

var chartAxis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class ChartAxis extends Axis {
  constructor(moduleCtx, scale) {
    super(moduleCtx, scale);
    this.keys = [];
    this.boundSeries = [];
    this.includeInvisibleDomains = false;
    this.modules = {};
    this.position = 'left';
  }
  get type() {
    var _a;
    return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';
  }
  get direction() {
    return ['top', 'bottom'].includes(this.position) ? ChartAxisDirection.X : ChartAxisDirection.Y;
  }
  useCalculatedTickCount() {
    // We only want to use the new algorithm for number axes. Category axes don't use a
    // calculated or user-supplied tick-count, and time axes need special handling depending on
    // the time-range involved.
    return this.scale instanceof LinearScale;
  }
  update(primaryTickCount) {
    this.updateDirection();
    return super.update(primaryTickCount);
  }
  updateDirection() {
    switch (this.position) {
      case 'top':
        this.rotation = -90;
        this.label.mirrored = true;
        this.label.parallel = true;
        break;
      case 'right':
        this.rotation = 0;
        this.label.mirrored = true;
        this.label.parallel = false;
        break;
      case 'bottom':
        this.rotation = -90;
        this.label.mirrored = false;
        this.label.parallel = true;
        break;
      case 'left':
        this.rotation = 0;
        this.label.mirrored = false;
        this.label.parallel = false;
        break;
    }
    if (this.axisContext) {
      this.axisContext.position = this.position;
      this.axisContext.direction = this.direction;
    }
  }
  calculateDomain() {
    const {
      direction,
      boundSeries,
      includeInvisibleDomains
    } = this;
    if (this.linkedTo) {
      this.dataDomain = this.linkedTo.dataDomain;
    } else {
      const domains = [];
      const visibleSeries = boundSeries.filter(s => includeInvisibleDomains || s.isEnabled());
      for (const series of visibleSeries) {
        domains.push(series.getDomain(direction));
      }
      const domain = new Array().concat(...domains);
      this.dataDomain = this.normaliseDataDomain(domain);
    }
  }
  normaliseDataDomain(d) {
    return d;
  }
  isAnySeriesActive() {
    return this.boundSeries.some(s => this.includeInvisibleDomains || s.isEnabled());
  }
  getLayoutState() {
    return Object.assign({
      rect: this.computeBBox(),
      gridPadding: this.gridPadding,
      seriesAreaPadding: this.seriesAreaPadding,
      tickSize: this.tick.size
    }, this.layout);
  }
  addModule(module) {
    if (this.modules[module.optionsKey] != null) {
      throw new Error('AG Charts - module already initialised: ' + module.optionsKey);
    }
    if (this.axisContext == null) {
      const keys = () => {
        return this.boundSeries.map(s => s.getKeys(this.direction)).reduce((keys, seriesKeys) => {
          keys.push(...seriesKeys);
          return keys;
        }, []);
      };
      this.axisContext = {
        axisId: this.id,
        position: this.position,
        direction: this.direction,
        continuous: this.scale instanceof ContinuousScale,
        keys,
        scaleValueFormatter: specifier => {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.scale).tickFormat) === null || _b === void 0 ? void 0 : _b.call(_a, {
            specifier
          })) !== null && _c !== void 0 ? _c : undefined;
        },
        scaleBandwidth: () => {
          var _a;
          return (_a = this.scale.bandwidth) !== null && _a !== void 0 ? _a : 0;
        },
        scaleConvert: val => this.scale.convert(val),
        scaleInvert: val => {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.scale).invert) === null || _b === void 0 ? void 0 : _b.call(_a, val)) !== null && _c !== void 0 ? _c : undefined;
        }
      };
    }
    const moduleInstance = new module.instanceConstructor(Object.assign(Object.assign({}, this.moduleCtx), {
      parent: this.axisContext
    }));
    this.modules[module.optionsKey] = {
      instance: moduleInstance
    };
    this[module.optionsKey] = moduleInstance;
  }
  removeModule(module) {
    var _a, _b;
    (_b = (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.destroy();
    delete this.modules[module.optionsKey];
    delete this[module.optionsKey];
  }
  isModuleEnabled(module) {
    return this.modules[module.optionsKey] != null;
  }
  destroy() {
    super.destroy();
    for (const [key, module] of Object.entries(this.modules)) {
      module.instance.destroy();
      delete this.modules[key];
      delete this[key];
    }
  }
  getTitleFormatterParams() {
    var _a;
    const boundSeries = this.boundSeries.reduce((acc, next) => {
      const keys = next.getKeys(this.direction);
      const names = next.getNames(this.direction);
      for (let idx = 0; idx < keys.length; idx++) {
        acc.push({
          key: keys[idx],
          name: names[idx]
        });
      }
      return acc;
    }, []);
    return {
      direction: this.direction,
      boundSeries,
      defaultValue: (_a = this.title) === null || _a === void 0 ? void 0 : _a.text
    };
  }
}
chartAxis_decorate([Validate(STRING_ARRAY)], ChartAxis.prototype, "keys", void 0);
chartAxis_decorate([Validate(POSITION)], ChartAxis.prototype, "position", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/axis/categoryAxis.mjs
var categoryAxis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class CategoryAxis extends ChartAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale());
    this._paddingOverrideEnabled = false;
    this.groupPaddingInner = 0.1;
    this.includeInvisibleDomains = true;
  }
  set paddingInner(value) {
    this._paddingOverrideEnabled = true;
    this.scale.paddingInner = value;
  }
  get paddingInner() {
    this._paddingOverrideEnabled = true;
    return this.scale.paddingInner;
  }
  set paddingOuter(value) {
    this.scale.paddingOuter = value;
  }
  get paddingOuter() {
    return this.scale.paddingOuter;
  }
  normaliseDataDomain(d) {
    // Prevent duplicate categories.
    const valuesSet = new Set(d);
    return new Array(...valuesSet.values());
  }
  calculateDomain() {
    if (!this._paddingOverrideEnabled) {
      const {
        boundSeries
      } = this;
      const paddings = boundSeries.map(s => {
        var _a;
        return (_a = s.getBandScalePadding) === null || _a === void 0 ? void 0 : _a.call(s);
      }).filter(p => p != null);
      if (paddings.length > 0) {
        this.scale.paddingInner = Math.min(...paddings.map(p => p.inner));
        this.scale.paddingOuter = Math.max(...paddings.map(p => p.outer));
      }
    }
    return super.calculateDomain();
  }
}
CategoryAxis.className = 'CategoryAxis';
CategoryAxis.type = 'category';
categoryAxis_decorate([Validate(NUMBER(0, 1))], CategoryAxis.prototype, "groupPaddingInner", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/json.mjs

/**
 * Performs a JSON-diff between a source and target JSON structure.
 *
 * On a per property basis, takes the target property value where:
 * - types are different.
 * - type is primitive.
 * - type is array and length or content have changed.
 *
 * Recurses for object types.
 *
 * @param source starting point for diff
 * @param target target for diff vs. source
 *
 * @returns `null` if no differences, or an object with the subset of properties that have changed.
 */
function jsonDiff(source, target) {
  const sourceType = classify(source);
  const targetType = classify(target);
  if (targetType === 'array') {
    const targetArray = target;
    if (sourceType !== 'array' || source.length !== targetArray.length) {
      return [...targetArray];
    }
    if (targetArray.some((targetElement, i) => {
      var _a;
      return jsonDiff((_a = source) === null || _a === void 0 ? void 0 : _a[i], targetElement) != null;
    })) {
      return [...targetArray];
    }
    return null;
  }
  if (targetType === 'primitive') {
    if (sourceType !== 'primitive') {
      return Object.assign({}, target);
    }
    if (source !== target) {
      return target;
    }
    return null;
  }
  const lhs = source || {};
  const rhs = target || {};
  const allProps = new Set([...Object.keys(lhs), ...Object.keys(rhs)]);
  let propsChangedCount = 0;
  const result = {};
  for (const prop of allProps) {
    // Cheap-and-easy equality check.
    if (lhs[prop] === rhs[prop]) {
      continue;
    }
    const take = v => {
      result[prop] = v;
      propsChangedCount++;
    };
    const lhsType = classify(lhs[prop]);
    const rhsType = classify(rhs[prop]);
    if (lhsType !== rhsType) {
      // Types changed, just take RHS.
      take(rhs[prop]);
      continue;
    }
    if (rhsType === 'primitive' || rhsType === null) {
      take(rhs[prop]);
      continue;
    }
    if (rhsType === 'array' && lhs[prop].length !== rhs[prop].length) {
      // Arrays are different sizes, so just take target array.
      take(rhs[prop]);
      continue;
    }
    if (rhsType === 'class-instance') {
      // Don't try to do anything tricky with array diffs!
      take(rhs[prop]);
      continue;
    }
    if (rhsType === 'function' && lhs[prop] !== rhs[prop]) {
      take(rhs[prop]);
      continue;
    }
    const diff = jsonDiff(lhs[prop], rhs[prop]);
    if (diff !== null) {
      take(diff);
    }
  }
  return propsChangedCount === 0 ? null : result;
}
/**
 * Special value used by `jsonMerge` to signal that a property should be removed from the merged
 * output.
 */
const DELETE = Symbol('<delete-property>');
const NOT_SPECIFIED = Symbol('<unspecified-property>');
/**
 * Merge together the provide JSON object structures, with the precedence of application running
 * from higher indexes to lower indexes.
 *
 * Deep-clones all objects to avoid mutation of the inputs changing the output object. For arrays,
 * just performs a deep-clone of the entire array, no merging of elements attempted.
 *
 * @param json all json objects to merge
 * @param opts merge options
 * @param opts.avoidDeepClone contains a list of properties where deep clones should be avoided
 *
 * @returns the combination of all of the json inputs
 */
function jsonMerge(json, opts) {
  var _a;
  const avoidDeepClone = (_a = opts === null || opts === void 0 ? void 0 : opts.avoidDeepClone) !== null && _a !== void 0 ? _a : [];
  const jsonTypes = json.map(v => classify(v));
  if (jsonTypes.some(v => v === 'array')) {
    // Clone final array.
    const finalValue = json[json.length - 1];
    if (finalValue instanceof Array) {
      return finalValue.map(v => {
        const type = classify(v);
        if (type === 'array') return jsonMerge([[], v], opts);
        if (type === 'object') return jsonMerge([{}, v], opts);
        return v;
      });
    }
    return finalValue;
  }
  const result = {};
  const props = new Set(json.map(v => v != null ? Object.keys(v) : []).reduce((r, n) => r.concat(n), []));
  for (const nextProp of props) {
    const values = json.map(j => j != null && nextProp in j ? j[nextProp] : NOT_SPECIFIED).filter(v => v !== NOT_SPECIFIED);
    if (values.length === 0) {
      continue;
    }
    const lastValue = values[values.length - 1];
    if (lastValue === DELETE) {
      continue;
    }
    const types = values.map(v => classify(v));
    const type = types[0];
    if (types.some(t => t !== type)) {
      // Short-circuit if mismatching types.
      result[nextProp] = lastValue;
      continue;
    }
    if ((type === 'array' || type === 'object') && !avoidDeepClone.includes(nextProp)) {
      result[nextProp] = jsonMerge(values, opts);
    } else if (type === 'array') {
      // Arrays need to be shallow copied to avoid external mutation and allow jsonDiff to
      // detect changes.
      result[nextProp] = [...lastValue];
    } else {
      // Just directly assign/overwrite.
      result[nextProp] = lastValue;
    }
  }
  return result;
}
/**
 * Recursively apply a JSON object into a class-hierarchy, optionally instantiating certain classes
 * by property name.
 *
 * @param target to apply source JSON properties into
 * @param source to be applied
 * @param params.path path for logging/error purposes, to aid with pinpointing problems
 * @param params.matcherPath path for pattern matching, to lookup allowedTypes override.
 * @param params.skip property names to skip from the source
 * @param params.constructors dictionary of property name to class constructors for properties that
 *                            require object construction
 * @param params.allowedTypes overrides by path for allowed property types
 */
function jsonApply(target, source, params = {}) {
  var _a, _b;
  const {
    path = undefined,
    matcherPath = path ? path.replace(/(\[[0-9+]+\])/i, '[]') : undefined,
    skip = [],
    constructors = {},
    allowedTypes = {},
    idx
  } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path !== null && path !== void 0 ? path : '<root>'}`);
  }
  if (source == null) {
    return target;
  }
  const targetAny = target;
  if (idx != null && '_declarationOrder' in targetAny) {
    targetAny['_declarationOrder'] = idx;
  }
  const targetType = classify(target);
  for (const property in source) {
    const propertyMatcherPath = `${matcherPath ? matcherPath + '.' : ''}${property}`;
    if (skip.indexOf(propertyMatcherPath) >= 0) {
      continue;
    }
    const newValue = source[property];
    const propertyPath = `${path ? path + '.' : ''}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    let ctr = (_a = constructors[propertyMatcherPath]) !== null && _a !== void 0 ? _a : constructors[property];
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === 'class-instance' && !(property in target || Object.prototype.hasOwnProperty.call(targetAny, property))) {
        Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - property is unknown`);
        continue;
      }
      const allowableTypes = (_b = allowedTypes[propertyMatcherPath]) !== null && _b !== void 0 ? _b : [currentValueType];
      if (currentValueType === 'class-instance' && newValueType === 'object') {
        // Allowed, this is the common case! - do not error.
      } else if (currentValueType != null && newValueType != null && !allowableTypes.includes(newValueType)) {
        Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - can't apply type of [${newValueType}], allowed types are: [${allowableTypes}]`);
        continue;
      }
      if (newValueType === 'array') {
        ctr = ctr !== null && ctr !== void 0 ? ctr : constructors[`${propertyMatcherPath}[]`];
        if (ctr != null) {
          const newValueArray = newValue;
          targetAny[property] = newValueArray.map((v, idx) => jsonApply(new ctr(), v, Object.assign(Object.assign({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath + '[]',
            idx
          })));
        } else {
          targetAny[property] = newValue;
        }
      } else if (newValueType === 'class-instance') {
        targetAny[property] = newValue;
      } else if (newValueType === 'object') {
        if (currentValue != null) {
          jsonApply(currentValue, newValue, Object.assign(Object.assign({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath,
            idx: undefined
          }));
        } else if (ctr != null) {
          targetAny[property] = jsonApply(new ctr(), newValue, Object.assign(Object.assign({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath,
            idx: undefined
          }));
        } else {
          targetAny[property] = newValue;
        }
      } else {
        targetAny[property] = newValue;
      }
    } catch (error) {
      const err = error;
      Logger.warn(`unable to set [${propertyPath}] in [${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name}]; nested error is: ${err.message}`);
      continue;
    }
  }
  return target;
}
/**
 * Walk the given JSON object graphs, invoking the visit() callback for every object encountered.
 * Arrays are descended into without a callback, however their elements will have the visit()
 * callback invoked if they are objects.
 *
 * @param json to traverse
 * @param visit callback for each non-primitive and non-array object found
 * @param opts.skip property names to skip when walking
 * @param jsons to traverse in parallel
 */
function jsonWalk(json, visit, opts, ...jsons) {
  var _a;
  const jsonType = classify(json);
  const skip = (_a = opts.skip) !== null && _a !== void 0 ? _a : [];
  if (jsonType === 'array') {
    json.forEach((element, index) => {
      jsonWalk(element, visit, opts, ...(jsons !== null && jsons !== void 0 ? jsons : []).map(o => o === null || o === void 0 ? void 0 : o[index]));
    });
    return;
  } else if (jsonType !== 'object') {
    return;
  }
  visit(jsonType, json, ...jsons);
  for (const property in json) {
    if (skip.indexOf(property) >= 0) {
      continue;
    }
    const value = json[property];
    const otherValues = jsons === null || jsons === void 0 ? void 0 : jsons.map(o => o === null || o === void 0 ? void 0 : o[property]);
    const valueType = classify(value);
    if (valueType === 'object' || valueType === 'array') {
      jsonWalk(value, visit, opts, ...otherValues);
    }
  }
}
const isBrowser = typeof window !== 'undefined';
/**
 * Classify the type of a value to assist with handling for merge purposes.
 */
function classify(value) {
  if (value == null) {
    return null;
  } else if (isBrowser && value instanceof HTMLElement) {
    return 'primitive';
  } else if (value instanceof Array) {
    return 'array';
  } else if (value instanceof Date) {
    return 'primitive';
  } else if (typeof value === 'object' && value.constructor === Object) {
    return 'object';
  } else if (typeof value === 'function') {
    return 'function';
  } else if (typeof value === 'object' && value.constructor != null) {
    return 'class-instance';
  }
  return 'primitive';
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/square.mjs

class Square extends Marker {
  updatePath() {
    const {
      path,
      x,
      y
    } = this;
    const hs = this.size / 2;
    path.clear();
    path.moveTo(this.align(x - hs), this.align(y - hs));
    path.lineTo(this.align(x + hs), this.align(y - hs));
    path.lineTo(this.align(x + hs), this.align(y + hs));
    path.lineTo(this.align(x - hs), this.align(y + hs));
    path.closePath();
  }
}
Square.className = 'Square';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/cross.mjs

class Cross extends Marker {
  updatePath() {
    const s = this.size / 4.2;
    super.applyPath(s, Cross.moves);
  }
}
Cross.className = 'Cross';
Cross.moves = [{
  x: -1,
  y: 0,
  t: 'move'
}, {
  x: -1,
  y: -1
}, {
  x: +1,
  y: -1
}, {
  x: +1,
  y: +1
}, {
  x: +1,
  y: -1
}, {
  x: +1,
  y: +1
}, {
  x: -1,
  y: +1
}, {
  x: +1,
  y: +1
}, {
  x: -1,
  y: +1
}, {
  x: -1,
  y: -1
}, {
  x: -1,
  y: +1
}, {
  x: -1,
  y: -1
}];
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/diamond.mjs

class Diamond extends Marker {
  updatePath() {
    const s = this.size / 2;
    super.applyPath(s, Diamond.moves);
  }
}
Diamond.className = 'Diamond';
Diamond.moves = [{
  x: 0,
  y: -1,
  t: 'move'
}, {
  x: +1,
  y: +1
}, {
  x: -1,
  y: +1
}, {
  x: -1,
  y: -1
}, {
  x: +1,
  y: -1
}];
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/heart.mjs

class Heart extends Marker {
  rad(degree) {
    return degree / 180 * Math.PI;
  }
  updatePath() {
    const {
      x,
      path,
      size,
      rad
    } = this;
    const r = size / 4;
    const y = this.y + r / 2;
    path.clear();
    path.arc(x - r, y - r, r, rad(130), rad(330));
    path.arc(x + r, y - r, r, rad(220), rad(50));
    path.lineTo(x, y + r);
    path.closePath();
  }
}
Heart.className = 'Heart';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/plus.mjs

class Plus extends Marker {
  updatePath() {
    const s = this.size / 3;
    super.applyPath(s, Plus.moves);
  }
}
Plus.className = 'Plus';
Plus.moves = [{
  x: -0.5,
  y: -0.5,
  t: 'move'
}, {
  x: 0,
  y: -1
}, {
  x: +1,
  y: 0
}, {
  x: 0,
  y: +1
}, {
  x: +1,
  y: 0
}, {
  x: 0,
  y: +1
}, {
  x: -1,
  y: 0
}, {
  x: 0,
  y: +1
}, {
  x: -1,
  y: 0
}, {
  x: 0,
  y: -1
}, {
  x: -1,
  y: 0
}, {
  x: 0,
  y: -1
}];
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/triangle.mjs

class Triangle extends Marker {
  updatePath() {
    const s = this.size * 1.1;
    super.applyPath(s, Triangle.moves);
  }
}
Triangle.className = 'Triangle';
Triangle.moves = [{
  x: 0,
  y: -0.48,
  t: 'move'
}, {
  x: 0.5,
  y: 0.87
}, {
  x: -1,
  y: 0
}];
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/marker/util.mjs







// This function is in its own file because putting it into SeriesMarker makes the Legend
// suddenly aware of the series (it's an agnostic component), and putting it into Marker
// introduces circular dependencies.
function getMarker(shape = Square) {
  if (typeof shape === 'string') {
    switch (shape) {
      case 'circle':
        return Circle;
      case 'cross':
        return Cross;
      case 'diamond':
        return Diamond;
      case 'heart':
        return Heart;
      case 'plus':
        return Plus;
      case 'triangle':
        return Triangle;
      default:
        return Square;
    }
  }
  if (typeof shape === 'function') {
    return shape;
  }
  return Square;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/motion/states.mjs

class StateMachine {
  constructor(initialState, states) {
    this.debug = false;
    this.state = initialState;
    this.states = states;
    if (this.debug) Logger.debug(`%c${this.constructor.name} | init -> ${initialState}`, 'color: green');
  }
  transition(event, data) {
    var _a, _b, _c, _d, _e;
    const currentStateConfig = this.states[this.state];
    const destinationTransition = (_a = currentStateConfig === null || currentStateConfig === void 0 ? void 0 : currentStateConfig.on) === null || _a === void 0 ? void 0 : _a[event];
    if (!destinationTransition) {
      if (this.debug) {
        Logger.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, 'color: grey');
      }
      return;
    }
    const destinationState = destinationTransition.target;
    const destinationStateConfig = this.states[destinationState];
    if (this.debug) {
      Logger.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, 'color: green');
    }
    destinationTransition.action(data);
    (_c = (_b = currentStateConfig === null || currentStateConfig === void 0 ? void 0 : currentStateConfig.actions) === null || _b === void 0 ? void 0 : _b.onExit) === null || _c === void 0 ? void 0 : _c.call(_b);
    (_e = (_d = destinationStateConfig === null || destinationStateConfig === void 0 ? void 0 : destinationStateConfig.actions) === null || _d === void 0 ? void 0 : _d.onEnter) === null || _e === void 0 ? void 0 : _e.call(_d);
    this.state = destinationState;
    return this.state;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/cartesianSeries.mjs

var cartesianSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var cartesianSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};















const DEFAULT_DIRECTION_KEYS = {
  [ChartAxisDirection.X]: ['xKey'],
  [ChartAxisDirection.Y]: ['yKey']
};
const DEFAULT_DIRECTION_NAMES = {
  [ChartAxisDirection.X]: ['xName'],
  [ChartAxisDirection.Y]: ['yName']
};
class CartesianSeriesNodeBaseClickEvent extends SeriesNodeBaseClickEvent {
  constructor(xKey, yKey, nativeEvent, datum, series) {
    super(nativeEvent, datum, series);
    this.xKey = xKey;
    this.yKey = yKey;
  }
}
class CartesianSeriesNodeClickEvent extends CartesianSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeClick';
  }
}
class CartesianSeriesNodeDoubleClickEvent extends CartesianSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeDoubleClick';
  }
}
class CartesianStateMachine extends StateMachine {}
class CartesianSeries extends Series {
  constructor(opts) {
    var _a, _b;
    super(Object.assign(Object.assign({}, opts), {
      useSeriesGroupLayer: true,
      directionKeys: (_a = opts.directionKeys) !== null && _a !== void 0 ? _a : DEFAULT_DIRECTION_KEYS,
      directionNames: (_b = opts.directionNames) !== null && _b !== void 0 ? _b : DEFAULT_DIRECTION_NAMES
    }));
    this._contextNodeData = [];
    this.nodeDataDependencies = {};
    this.highlightSelection = Selection.select(this.highlightNode, () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory());
    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);
    this.subGroups = [];
    this.subGroupId = 0;
    /**
     * The assumption is that the values will be reset (to `true`)
     * in the {@link yKeys} setter.
     */
    this.seriesItemEnabled = new Map();
    const {
      pathsPerSeries = 1,
      hasMarkers = false,
      pathsZIndexSubOrderOffset = []
    } = opts;
    this.opts = {
      pathsPerSeries,
      hasMarkers,
      pathsZIndexSubOrderOffset
    };
    this.animationState = new CartesianStateMachine('empty', {
      empty: {
        on: {
          update: {
            target: 'ready',
            action: data => this.animateEmptyUpdateReady(data)
          }
        }
      },
      ready: {
        on: {
          update: {
            target: 'ready',
            action: data => this.animateReadyUpdate(data)
          },
          highlight: {
            target: 'ready',
            action: data => this.animateReadyHighlight(data)
          },
          highlightMarkers: {
            target: 'ready',
            action: data => this.animateReadyHighlightMarkers(data)
          },
          resize: {
            target: 'ready',
            action: data => this.animateReadyResize(data)
          }
        }
      }
    });
  }
  get contextNodeData() {
    var _a;
    return (_a = this._contextNodeData) === null || _a === void 0 ? void 0 : _a.slice();
  }
  addChartEventListeners() {
    var _a, _b;
    (_a = this.chartEventManager) === null || _a === void 0 ? void 0 : _a.addListener('legend-item-click', event => this.onLegendItemClick(event));
    (_b = this.chartEventManager) === null || _b === void 0 ? void 0 : _b.addListener('legend-item-double-click', event => this.onLegendItemDoubleClick(event));
  }
  destroy() {
    super.destroy();
    this._contextNodeData.splice(0, this._contextNodeData.length);
    this.subGroups.splice(0, this.subGroups.length);
  }
  /**
   * Note: we are passing `isContinuousX` and `isContinuousY` into this method because it will
   *       typically be called inside a loop and this check only needs to happen once.
   * @param x A domain value to be plotted along the x-axis.
   * @param y A domain value to be plotted along the y-axis.
   * @param isContinuousX Typically this will be the value of `xAxis.scale instanceof ContinuousScale`.
   * @param isContinuousY Typically this will be the value of `yAxis.scale instanceof ContinuousScale`.
   * @returns `[x, y]`, if both x and y are valid domain values for their respective axes/scales, or `undefined`.
   */
  checkDomainXY(x, y, isContinuousX, isContinuousY) {
    const isValidDatum = (isContinuousX && isContinuous(x) || !isContinuousX && isDiscrete(x)) && (isContinuousY && isContinuous(y) || !isContinuousY && isDiscrete(y));
    return isValidDatum ? [x, y] : undefined;
  }
  /**
   * Note: we are passing the xAxis and yAxis because the calling code is supposed to make sure
   *       that series has both of them defined, and also to avoid one level of indirection,
   *       e.g. `this.xAxis!.inRange(x)`, both of which are suboptimal in tight loops where this method is used.
   * @param x A range value to be plotted along the x-axis.
   * @param y A range value to be plotted along the y-axis.
   * @param xAxis The series' x-axis.
   * @param yAxis The series' y-axis.
   * @returns
   */
  checkRangeXY(x, y, xAxis, yAxis) {
    return !isNaN(x) && !isNaN(y) && xAxis.inRange(x) && yAxis.inRange(y);
  }
  update({
    seriesRect
  }) {
    var _a, _b;
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        seriesItemEnabled,
        visible
      } = this;
      const {
        series
      } = (_b = (_a = this.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};
      const seriesHighlighted = series ? series === this : undefined;
      const anySeriesItemEnabled = visible && seriesItemEnabled.size === 0 || [...seriesItemEnabled.values()].some(v => v === true);
      const newNodeDataDependencies = {
        seriesRectWidth: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width,
        seriesRectHeight: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.height
      };
      if (jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null) {
        this.nodeDataDependencies = newNodeDataDependencies;
        this.markNodeDataDirty();
        this.animationState.transition('resize', {
          datumSelections: this.subGroups.map(({
            datumSelection
          }) => datumSelection),
          markerSelections: this.subGroups.map(({
            markerSelection
          }) => markerSelection),
          contextData: this._contextNodeData,
          paths: this.subGroups.map(({
            paths
          }) => paths)
        });
      }
      yield this.updateSelections(seriesHighlighted, anySeriesItemEnabled);
      yield this.updateNodes(seriesHighlighted, anySeriesItemEnabled);
      this.animationState.transition('update', {
        datumSelections: this.subGroups.map(({
          datumSelection
        }) => datumSelection),
        markerSelections: this.subGroups.map(({
          markerSelection
        }) => markerSelection),
        labelSelections: this.subGroups.map(({
          labelSelection
        }) => labelSelection),
        contextData: this._contextNodeData,
        paths: this.subGroups.map(({
          paths
        }) => paths),
        seriesRect
      });
    });
  }
  updateSelections(seriesHighlighted, anySeriesItemEnabled) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      yield this.updateHighlightSelection(seriesHighlighted);
      if (!anySeriesItemEnabled) {
        return;
      }
      if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {
        return;
      }
      if (this.nodeDataRefresh) {
        this.nodeDataRefresh = false;
        this._contextNodeData = yield this.createNodeData();
        yield this.updateSeriesGroups();
      }
      yield Promise.all(this.subGroups.map((g, i) => this.updateSeriesGroupSelections(g, i)));
    });
  }
  updateSeriesGroupSelections(subGroup, seriesIdx) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        datumSelection,
        labelSelection,
        markerSelection
      } = subGroup;
      const contextData = this._contextNodeData[seriesIdx];
      const {
        nodeData,
        labelData
      } = contextData;
      subGroup.datumSelection = yield this.updateDatumSelection({
        nodeData,
        datumSelection,
        seriesIdx
      });
      subGroup.labelSelection = yield this.updateLabelSelection({
        labelData,
        labelSelection,
        seriesIdx
      });
      if (markerSelection) {
        subGroup.markerSelection = yield this.updateMarkerSelection({
          nodeData,
          markerSelection,
          seriesIdx
        });
      }
    });
  }
  nodeFactory() {
    return new Group();
  }
  markerFactory() {
    const MarkerShape = getMarker();
    return new MarkerShape();
  }
  updateSeriesGroups() {
    var _a;
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        _contextNodeData: contextNodeData,
        contentGroup,
        subGroups,
        opts: {
          pathsPerSeries,
          hasMarkers,
          pathsZIndexSubOrderOffset
        }
      } = this;
      if (contextNodeData.length === subGroups.length) {
        return;
      }
      if (contextNodeData.length < subGroups.length) {
        subGroups.splice(contextNodeData.length).forEach(({
          dataNodeGroup,
          markerGroup,
          labelGroup,
          paths
        }) => {
          contentGroup.removeChild(dataNodeGroup);
          if (markerGroup) {
            contentGroup.removeChild(markerGroup);
          }
          if (labelGroup) {
            contentGroup.removeChild(labelGroup);
          }
          for (const path of paths) {
            contentGroup.removeChild(path);
          }
        });
      }
      const totalGroups = contextNodeData.length;
      while (totalGroups > subGroups.length) {
        const layer = false;
        const subGroupId = this.subGroupId++;
        const subGroupZOffset = subGroupId;
        const dataNodeGroup = new Group({
          name: `${this.id}-series-sub${subGroupId}-dataNodes`,
          layer,
          zIndex: Layers.SERIES_LAYER_ZINDEX,
          zIndexSubOrder: [() => this._declarationOrder, subGroupZOffset]
        });
        const markerGroup = hasMarkers ? new Group({
          name: `${this.id}-series-sub${this.subGroupId++}-markers`,
          layer,
          zIndex: Layers.SERIES_LAYER_ZINDEX,
          zIndexSubOrder: [() => this._declarationOrder, 10000 + subGroupId]
        }) : undefined;
        const labelGroup = new Group({
          name: `${this.id}-series-sub${this.subGroupId++}-labels`,
          layer,
          zIndex: Layers.SERIES_LABEL_ZINDEX,
          zIndexSubOrder: [() => this._declarationOrder, subGroupId]
        });
        contentGroup.appendChild(dataNodeGroup);
        contentGroup.appendChild(labelGroup);
        if (markerGroup) {
          contentGroup.appendChild(markerGroup);
        }
        const paths = [];
        for (let index = 0; index < pathsPerSeries; index++) {
          paths[index] = new Path();
          paths[index].zIndex = Layers.SERIES_LAYER_ZINDEX;
          paths[index].zIndexSubOrder = [() => this._declarationOrder, ((_a = pathsZIndexSubOrderOffset[index]) !== null && _a !== void 0 ? _a : 0) + subGroupZOffset];
          contentGroup.appendChild(paths[index]);
        }
        subGroups.push({
          paths,
          dataNodeGroup,
          markerGroup,
          labelGroup,
          labelSelection: Selection.select(labelGroup, Text),
          datumSelection: Selection.select(dataNodeGroup, () => this.nodeFactory()),
          markerSelection: markerGroup ? Selection.select(markerGroup, () => this.markerFactory()) : undefined
        });
      }
    });
  }
  updateNodes(seriesHighlighted, anySeriesItemEnabled) {
    var _a;
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        highlightSelection,
        highlightLabelSelection,
        _contextNodeData: contextNodeData,
        seriesItemEnabled,
        opts: {
          hasMarkers
        }
      } = this;
      const visible = this.visible && ((_a = this._contextNodeData) === null || _a === void 0 ? void 0 : _a.length) > 0 && anySeriesItemEnabled;
      this.rootGroup.visible = visible;
      this.contentGroup.visible = visible;
      this.highlightGroup.visible = visible && !!seriesHighlighted;
      const seriesOpacity = this.getOpacity();
      const subGroupOpacities = this.subGroups.map((_, index) => {
        const {
          itemId
        } = contextNodeData[index];
        return this.getOpacity({
          itemId
        });
      });
      const isSubGroupOpacityDifferent = subGroupOpacities.some(subOp => subOp !== seriesOpacity);
      this.contentGroup.opacity = isSubGroupOpacityDifferent ? 1 : seriesOpacity;
      if (hasMarkers) {
        yield this.updateMarkerNodes({
          markerSelection: highlightSelection,
          isHighlight: true,
          seriesIdx: -1
        });
        this.animationState.transition('highlightMarkers', highlightSelection);
      } else {
        yield this.updateDatumNodes({
          datumSelection: highlightSelection,
          isHighlight: true,
          seriesIdx: -1
        });
        this.animationState.transition('highlight', highlightSelection);
      }
      yield this.updateLabelNodes({
        labelSelection: highlightLabelSelection,
        seriesIdx: -1
      });
      yield Promise.all(this.subGroups.map((subGroup, seriesIdx) => cartesianSeries_awaiter(this, void 0, void 0, function* () {
        var _b;
        const {
          dataNodeGroup,
          markerGroup,
          datumSelection,
          labelSelection,
          markerSelection,
          paths,
          labelGroup
        } = subGroup;
        const {
          itemId
        } = contextNodeData[seriesIdx];
        const subGroupVisible = visible && ((_b = seriesItemEnabled.get(itemId)) !== null && _b !== void 0 ? _b : true);
        const subGroupOpacity = isSubGroupOpacityDifferent ? subGroupOpacities[seriesIdx] : 1;
        dataNodeGroup.opacity = subGroupOpacity;
        dataNodeGroup.visible = subGroupVisible;
        labelGroup.visible = subGroupVisible;
        if (markerGroup) {
          markerGroup.opacity = subGroupOpacity;
          markerGroup.zIndex = dataNodeGroup.zIndex >= Layers.SERIES_LAYER_ZINDEX ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;
          markerGroup.visible = subGroupVisible;
        }
        if (labelGroup) {
          labelGroup.opacity = subGroupOpacity;
        }
        for (const path of paths) {
          path.opacity = subGroupOpacity;
          path.visible = subGroupVisible;
        }
        if (!dataNodeGroup.visible) {
          return;
        }
        yield this.updateDatumNodes({
          datumSelection,
          isHighlight: false,
          seriesIdx
        });
        yield this.updateLabelNodes({
          labelSelection,
          seriesIdx
        });
        if (hasMarkers && markerSelection) {
          yield this.updateMarkerNodes({
            markerSelection,
            isHighlight: false,
            seriesIdx
          });
        }
      })));
    });
  }
  updateHighlightSelection(seriesHighlighted) {
    var _a;
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        highlightSelection,
        highlightLabelSelection,
        _contextNodeData: contextNodeData
      } = this;
      const highlightedDatum = (_a = this.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();
      const item = seriesHighlighted && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.datum) ? highlightedDatum : undefined;
      this.highlightSelection = yield this.updateHighlightSelectionItem({
        item,
        highlightSelection
      });
      let labelItem;
      if (this.isLabelEnabled() && item != null) {
        const {
          itemId = undefined
        } = item;
        for (const {
          labelData
        } of contextNodeData) {
          labelItem = labelData.find(ld => ld.datum === item.datum && ld.itemId === itemId);
          if (labelItem != null) {
            break;
          }
        }
      }
      this.highlightLabelSelection = yield this.updateHighlightSelectionLabel({
        item: labelItem,
        highlightLabelSelection
      });
    });
  }
  pickNodeExactShape(point) {
    const result = super.pickNodeExactShape(point);
    if (result) {
      return result;
    }
    const {
      x,
      y
    } = point;
    const {
      opts: {
        hasMarkers
      }
    } = this;
    for (const {
      dataNodeGroup,
      markerGroup
    } of this.subGroups) {
      let match = dataNodeGroup.pickNode(x, y);
      if (!match && hasMarkers) {
        match = markerGroup === null || markerGroup === void 0 ? void 0 : markerGroup.pickNode(x, y);
      }
      if (match) {
        return {
          datum: match.datum,
          distance: 0
        };
      }
    }
  }
  pickNodeClosestDatum(point) {
    var _a, _b;
    const {
      x,
      y
    } = point;
    const {
      xAxis,
      yAxis,
      rootGroup,
      _contextNodeData: contextNodeData
    } = this;
    const hitPoint = rootGroup.transformPoint(x, y);
    let minDistance = Infinity;
    let closestDatum;
    for (const context of contextNodeData) {
      for (const datum of context.nodeData) {
        const {
          point: {
            x: datumX = NaN,
            y: datumY = NaN
          } = {}
        } = datum;
        if (isNaN(datumX) || isNaN(datumY)) {
          continue;
        }
        const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));
        if (!isInRange) {
          continue;
        }
        // No need to use Math.sqrt() since x < y implies Math.sqrt(x) < Math.sqrt(y) for
        // values > 1
        const distance = Math.max(Math.pow(hitPoint.x - datumX, 2) + Math.pow(hitPoint.y - datumY, 2), 0);
        if (distance < minDistance) {
          minDistance = distance;
          closestDatum = datum;
        }
      }
    }
    if (closestDatum) {
      const distance = Math.max(Math.sqrt(minDistance) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);
      return {
        datum: closestDatum,
        distance
      };
    }
  }
  pickNodeMainAxisFirst(point, requireCategoryAxis) {
    var _a, _b;
    const {
      x,
      y
    } = point;
    const {
      xAxis,
      yAxis,
      rootGroup,
      _contextNodeData: contextNodeData
    } = this;
    // Prefer to start search with any available category axis.
    const directions = [xAxis, yAxis].filter(a => a instanceof CategoryAxis).map(a => a.direction);
    if (requireCategoryAxis && directions.length === 0) {
      return;
    }
    // Default to X-axis unless we found a suitable category axis.
    const [primaryDirection = ChartAxisDirection.X] = directions;
    const hitPoint = rootGroup.transformPoint(x, y);
    const hitPointCoords = primaryDirection === ChartAxisDirection.X ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];
    const minDistance = [Infinity, Infinity];
    let closestDatum = undefined;
    for (const context of contextNodeData) {
      for (const datum of context.nodeData) {
        const {
          point: {
            x: datumX = NaN,
            y: datumY = NaN
          } = {}
        } = datum;
        if (isNaN(datumX) || isNaN(datumY)) {
          continue;
        }
        const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));
        if (!isInRange) {
          continue;
        }
        const point = primaryDirection === ChartAxisDirection.X ? [datumX, datumY] : [datumY, datumX];
        // Compare distances from most significant dimension to least.
        let newMinDistance = true;
        for (let i = 0; i < point.length; i++) {
          const dist = Math.abs(point[i] - hitPointCoords[i]);
          if (dist > minDistance[i]) {
            newMinDistance = false;
            break;
          }
          if (dist < minDistance[i]) {
            minDistance[i] = dist;
            minDistance.fill(Infinity, i + 1, minDistance.length);
          }
        }
        if (newMinDistance) {
          closestDatum = datum;
        }
      }
    }
    if (closestDatum) {
      const distance = Math.max(Math.sqrt(Math.pow(minDistance[0], 2) + Math.pow(minDistance[1], 2)) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);
      return {
        datum: closestDatum,
        distance
      };
    }
  }
  onLegendItemClick(event) {
    const {
      enabled,
      itemId,
      series
    } = event;
    if (series.id !== this.id) return;
    this.toggleSeriesItem(itemId, enabled);
  }
  onLegendItemDoubleClick(event) {
    const {
      enabled,
      itemId,
      series,
      numVisibleItems
    } = event;
    const totalVisibleItems = Object.values(numVisibleItems).reduce((p, v) => p + v, 0);
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && totalVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  toggleSeriesItem(itemId, enabled) {
    if (this.seriesItemEnabled.size > 0) {
      this.seriesItemEnabled.set(itemId, enabled);
      this.nodeDataRefresh = true;
    } else {
      super.toggleSeriesItem(itemId, enabled);
    }
  }
  isEnabled() {
    if (this.seriesItemEnabled.size > 0) {
      for (const [, enabled] of this.seriesItemEnabled) {
        if (enabled) {
          return true;
        }
      }
      return false;
    }
    return super.isEnabled();
  }
  isPathOrSelectionDirty() {
    // Override point to allow more sophisticated dirty selection detection.
    return false;
  }
  getLabelData() {
    return [];
  }
  isAnySeriesVisible() {
    for (const visible of this.seriesItemEnabled.values()) {
      if (visible) {
        return true;
      }
    }
    return false;
  }
  updateHighlightSelectionItem(opts) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        opts: {
          hasMarkers
        }
      } = this;
      const {
        item,
        highlightSelection
      } = opts;
      const nodeData = item ? [item] : [];
      if (hasMarkers) {
        const markerSelection = highlightSelection;
        return this.updateMarkerSelection({
          nodeData,
          markerSelection,
          seriesIdx: -1
        });
      } else {
        return this.updateDatumSelection({
          nodeData,
          datumSelection: highlightSelection,
          seriesIdx: -1
        });
      }
    });
  }
  updateHighlightSelectionLabel(opts) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      const {
        item,
        highlightLabelSelection
      } = opts;
      const labelData = item ? [item] : [];
      return this.updateLabelSelection({
        labelData,
        labelSelection: highlightLabelSelection,
        seriesIdx: -1
      });
    });
  }
  updateDatumSelection(opts) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      // Override point for sub-classes.
      return opts.datumSelection;
    });
  }
  updateDatumNodes(_opts) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      // Override point for sub-classes.
    });
  }
  updateMarkerSelection(opts) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      // Override point for sub-classes.
      return opts.markerSelection;
    });
  }
  updateMarkerNodes(_opts) {
    return cartesianSeries_awaiter(this, void 0, void 0, function* () {
      // Override point for sub-classes.
    });
  }
  animateEmptyUpdateReady(_data) {
    // Override point for sub-classes.
  }
  animateReadyUpdate(_data) {
    // Override point for sub-classes.
  }
  animateReadyHighlight(_data) {
    // Override point for sub-classes.
  }
  animateReadyHighlightMarkers(_data) {
    // Override point for sub-classes.
  }
  animateReadyResize(_data) {
    // Override point for sub-classes.
  }
}
class CartesianSeriesMarker extends SeriesMarker {
  constructor() {
    super(...arguments);
    this.formatter = undefined;
  }
}
cartesianSeries_decorate([Validate(OPT_FUNCTION), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], CartesianSeriesMarker.prototype, "formatter", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/async.mjs
function sleep(sleepTimeoutMs) {
  return new Promise(resolve => {
    setTimeout(() => resolve(undefined), sleepTimeoutMs);
  });
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/overlay/overlay.mjs
var overlay_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class Overlay {
  constructor(className, parent) {
    this.renderer = undefined;
    this.text = undefined;
    this.className = className;
    this.parentElement = parent;
  }
  show(rect) {
    var _a, _b;
    let element = this.element;
    if (!this.element) {
      element = document.createElement('div');
      element.className = this.className;
      this.element = element;
    }
    element.style.position = 'absolute';
    element.style.left = `${rect.x}px`;
    element.style.top = `${rect.y}px`;
    element.style.width = `${rect.width}px`;
    element.style.height = `${rect.height}px`;
    if (this.renderer) {
      this.element.innerHTML = this.renderer();
    } else {
      const content = document.createElement('div');
      content.style.alignItems = 'center';
      content.style.boxSizing = 'border-box';
      content.style.display = 'flex';
      content.style.justifyContent = 'center';
      content.style.margin = '8px';
      content.style.height = '100%';
      content.style.font = '12px Verdana, sans-serif';
      content.innerText = (_a = this.text) !== null && _a !== void 0 ? _a : 'No data to display';
      element.append(content);
    }
    (_b = this.parentElement) === null || _b === void 0 ? void 0 : _b.append(element);
  }
  hide() {
    var _a;
    (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
    this.element = undefined;
  }
}
overlay_decorate([Validate(OPT_FUNCTION)], Overlay.prototype, "renderer", void 0);
overlay_decorate([Validate(OPT_STRING)], Overlay.prototype, "text", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/overlay/chartOverlays.mjs

class ChartOverlays {
  constructor(parent) {
    this.noData = new Overlay('ag-chart-no-data-overlay', parent);
  }
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-exception.stack.js
var web_dom_exception_stack = __webpack_require__(2801);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/listeners.mjs


class Listeners {
  constructor() {
    this.registeredListeners = {};
  }
  addListener(type, cb) {
    var _a;
    const symbol = Symbol(type);
    if (!this.registeredListeners[type]) {
      this.registeredListeners[type] = [];
    }
    (_a = this.registeredListeners[type]) === null || _a === void 0 ? void 0 : _a.push({
      symbol,
      handler: cb
    });
    return symbol;
  }
  dispatch(type, ...params) {
    var _a;
    const listeners = (_a = this.registeredListeners[type]) !== null && _a !== void 0 ? _a : [];
    const results = [];
    for (const listener of listeners) {
      try {
        results.push(listener.handler(...params));
      } catch (e) {
        Logger.errorOnce(e);
        results.push(undefined);
      }
    }
    return results;
  }
  cancellableDispatch(type, cancelled, ...params) {
    var _a;
    const listeners = (_a = this.registeredListeners[type]) !== null && _a !== void 0 ? _a : [];
    const results = [];
    for (const listener of listeners) {
      if (cancelled()) break;
      results.push(listener.handler(...params));
    }
    return results;
  }
  reduceDispatch(type, reduceFn, ...params) {
    var _a;
    const listeners = (_a = this.registeredListeners[type]) !== null && _a !== void 0 ? _a : [];
    let listenerResult = undefined;
    for (const listener of listeners) {
      listenerResult = listener.handler(...params);
      params = reduceFn(listenerResult, ...params);
    }
    return listenerResult;
  }
  removeListener(listenerSymbol) {
    for (const type in this.registeredListeners) {
      const listeners = this.registeredListeners[type];
      const match = listeners === null || listeners === void 0 ? void 0 : listeners.findIndex(entry => entry.symbol === listenerSymbol);
      if (match != null && match >= 0) {
        listeners === null || listeners === void 0 ? void 0 : listeners.splice(match, 1);
      }
      if (match != null && (listeners === null || listeners === void 0 ? void 0 : listeners.length) === 0) {
        delete this.registeredListeners[type];
      }
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/baseManager.mjs

class BaseManager {
  constructor() {
    this.listeners = new Listeners();
  }
  addListener(type, cb) {
    return this.listeners.addListener(type, cb);
  }
  removeListener(listenerSymbol) {
    this.listeners.removeListener(listenerSymbol);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/interpolate/number.mjs
/* harmony default export */ function number(a, b) {
  a = +a;
  b = +b;
  return t => a * (1 - t) + b * t;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/interpolate/color.mjs


/* harmony default export */ function color(a, b) {
  if (typeof a === 'string') {
    try {
      a = Color.fromString(a);
    } catch (e) {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === 'string') {
    try {
      b = Color.fromString(b);
    } catch (e) {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  const red = number(a.r, b.r);
  const green = number(a.g, b.g);
  const blue = number(a.b, b.b);
  const alpha = number(a.a, b.a);
  return function (t) {
    return Color.fromArray([red(t), green(t), blue(t), alpha(t)]).toRgbaString();
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/interpolate/value.mjs



/* harmony default export */ function value(a, b) {
  const t = typeof b;
  let c;
  if (t === 'number') {
    return number(a, b);
  }
  if (t === 'string') {
    try {
      c = Color.fromString(b);
      b = c;
      return color(a, b);
    } catch (e) {
      // Error-case handled below.
    }
  }
  throw new Error('Unable to interpolate values');
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/motion/easing.mjs

function createEase(fn) {
  return ({
    from,
    to
  }) => {
    const interp = value(from, to);
    return time => interp(fn(time));
  };
}
function linear({
  from,
  to
}) {
  return value(from, to);
}
// https://easings.net/
const easeIn = createEase(x => 1 - Math.cos(x * Math.PI / 2));
const easeOut = createEase(x => Math.sin(x * Math.PI / 2));
const easeInOut = createEase(x => -(Math.cos(x * Math.PI) - 1) / 2);
const easeOutElastic = createEase(x => {
  if (x === 0 || x === 1) return x;
  const scale = Math.pow(2, -10 * x);
  const position = x * 10 - 0.75;
  const arc = 2 * Math.PI / 3;
  return scale * Math.sin(position * arc) + 1;
});
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/motion/animate.mjs

var RepeatType;
(function (RepeatType) {
  RepeatType["Loop"] = "loop";
  RepeatType["Reverse"] = "reverse";
})(RepeatType || (RepeatType = {}));
function animate({
  driver,
  duration,
  from,
  to,
  autoplay = true,
  delay = 0,
  ease = linear,
  repeat: repeatMax = Infinity,
  repeatType = RepeatType.Loop,
  onComplete,
  onPlay,
  onRepeat,
  onStop,
  onUpdate
}) {
  let state;
  let delayElapsed = 0;
  let elapsed = 0;
  let iteration = 0;
  let isForward = true;
  let isComplete = false;
  const easing = ease({
    from,
    to
  });
  const controls = {
    isPlaying: false,
    play,
    pause,
    stop,
    reset
  };
  const driverControls = driver(update);
  function play() {
    controls.isPlaying = true;
    driverControls.start();
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    return controls;
  }
  function pause() {
    controls.isPlaying = false;
    return controls;
  }
  function stop() {
    controls.isPlaying = false;
    driverControls.stop();
    onStop === null || onStop === void 0 ? void 0 : onStop();
    return controls;
  }
  function reset() {
    isComplete = false;
    elapsed = 0;
    iteration = 0;
    driverControls.reset();
    return controls;
  }
  function repeat() {
    iteration++;
    if (repeatType === RepeatType.Reverse) {
      isForward = iteration % 2 === 0;
      elapsed = isForward ? elapsed % duration : duration - elapsed % duration;
    } else {
      elapsed = elapsed % duration;
    }
    isComplete = false;
    onRepeat === null || onRepeat === void 0 ? void 0 : onRepeat();
  }
  function complete() {
    stop();
    onComplete === null || onComplete === void 0 ? void 0 : onComplete();
  }
  function update(delta) {
    if (!isForward) delta = -delta;
    if (delayElapsed >= delay) {
      elapsed += delta;
    } else {
      delayElapsed += delta;
      return;
    }
    if (!isComplete) {
      state = easing(Math.min(1, Math.max(0, elapsed / duration)));
      isComplete = isForward ? elapsed >= duration : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(state);
    if (isComplete) {
      if (iteration < repeatMax) {
        repeat();
      } else {
        complete();
      }
    }
  }
  if (autoplay) play();
  return controls;
}
function tween(opts) {
  let handleUpdate;
  const animateOpts = Object.assign(Object.assign({}, opts), {
    repeat: 0,
    autoplay: false,
    onUpdate: value => {
      handleUpdate === null || handleUpdate === void 0 ? void 0 : handleUpdate(value);
    }
  });
  const animationControls = animate(animateOpts);
  const controls = {
    start: onUpdate => {
      animationControls.stop();
      animationControls.reset();
      animationControls.play();
      handleUpdate = onUpdate;
      return controls;
    },
    stop: () => {
      animationControls.stop();
      return controls;
    }
  };
  return controls;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/animationManager.mjs




const DEBOUNCE_DELAY = 300;
class AnimationManager extends BaseManager {
  constructor(interactionManager) {
    super();
    this.controllers = {};
    this.debouncers = {};
    this.updaters = [];
    this.isPlaying = false;
    this.readyToPlay = false;
    this.skipAnimations = false;
    this.interactionManager = interactionManager;
    window.addEventListener('DOMContentLoaded', () => {
      this.readyToPlay = true;
    });
    // Fallback if `DOMContentLoaded` event is not fired, e.g. in an iframe
    setTimeout(() => {
      this.readyToPlay = true;
    }, 10);
  }
  play() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    for (const id in this.controllers) {
      this.controllers[id].play();
    }
    this.startAnimationCycle();
  }
  pause() {
    if (!this.isPlaying) return;
    this.isPlaying = false;
    this.cancelAnimationFrame();
    for (const id in this.controllers) {
      this.controllers[id].pause();
    }
  }
  stop() {
    this.isPlaying = false;
    this.cancelAnimationFrame();
    for (const id in this.controllers) {
      this.controllers[id].stop();
    }
  }
  animate(id, opts) {
    var _a, _b;
    const optsExtra = Object.assign(Object.assign({}, opts), {
      autoplay: this.isPlaying ? opts.autoplay : false,
      driver: this.createDriver(id, opts.disableInteractions)
    });
    const controller = animate(optsExtra);
    if (this.controllers[id]) {
      this.controllers[id].stop();
      delete this.controllers[id];
    }
    this.controllers[id] = controller;
    if (this.skipAnimations) {
      // Initialise the animation with the final values immediately and then stop the animation
      (_a = opts.onUpdate) === null || _a === void 0 ? void 0 : _a.call(opts, opts.to);
      controller.stop();
    } else {
      // Initialise the animation immediately without requesting a frame to prevent flashes
      (_b = opts.onUpdate) === null || _b === void 0 ? void 0 : _b.call(opts, opts.from);
    }
    return controller;
  }
  animateMany(id, props, opts) {
    const state = props.map(prop => prop.from);
    let updateBatch = 0;
    let completeBatch = 0;
    const onUpdate = index => v => {
      var _a;
      state[index] = v;
      if (++updateBatch >= props.length) {
        (_a = opts.onUpdate) === null || _a === void 0 ? void 0 : _a.call(opts, state);
        updateBatch = 0;
      }
    };
    const onComplete = () => {
      var _a;
      if (++completeBatch >= props.length) {
        (_a = opts.onComplete) === null || _a === void 0 ? void 0 : _a.call(opts);
      }
    };
    const drivers = props.map((prop, index) => {
      const inner_id = `${id}-${index}`;
      return this.animate(inner_id, Object.assign(Object.assign(Object.assign({}, opts), prop), {
        onUpdate: onUpdate(index),
        onComplete: onComplete
      }));
    });
    const controls = {
      get isPlaying() {
        return drivers.some(driver => driver.isPlaying);
      },
      play() {
        drivers.forEach(driver => driver.play());
        return controls;
      },
      pause() {
        drivers.forEach(driver => driver.pause());
        return controls;
      },
      stop() {
        drivers.forEach(driver => driver.stop());
        return controls;
      },
      reset() {
        drivers.forEach(driver => driver.reset());
        return controls;
      }
    };
    return controls;
  }
  debouncedAnimate(id, opts) {
    var _a;
    if (this.debouncers[id] && Date.now() - this.debouncers[id] < ((_a = opts.duration) !== null && _a !== void 0 ? _a : DEBOUNCE_DELAY)) {
      return this.controllers[id];
    }
    this.debouncers[id] = Date.now();
    return this.animate(id, opts);
  }
  tween(opts) {
    const id = `tween-${btoa(JSON.stringify(opts))}`;
    const optsExtra = Object.assign(Object.assign({}, opts), {
      driver: this.createDriver(id)
    });
    return tween(optsExtra);
  }
  createDriver(id, disableInteractions) {
    return update => {
      return {
        start: () => {
          this.updaters.push([id, update]);
          if (this.requestId == null) {
            this.startAnimationCycle();
          }
          if (disableInteractions) {
            this.interactionManager.pause(`animation_${id}`);
          }
        },
        stop: () => {
          this.updaters = this.updaters.filter(([uid]) => uid !== id);
          if (this.updaters.length <= 0) {
            this.cancelAnimationFrame();
          }
          if (disableInteractions) {
            this.interactionManager.resume(`animation_${id}`);
          }
        },
        reset: () => {}
      };
    };
  }
  startAnimationCycle() {
    const frame = time => {
      this.requestId = requestAnimationFrame(frame);
      if (!this.readyToPlay) {
        return;
      }
      if (this.lastTime === undefined) this.lastTime = time;
      const deltaMs = time - this.lastTime;
      this.lastTime = time;
      this.updaters.forEach(([_, update]) => {
        update(deltaMs);
      });
      this.listeners.dispatch('animation-frame', {
        type: 'animation-frame',
        deltaMs
      });
    };
    this.requestId = requestAnimationFrame(frame);
  }
  cancelAnimationFrame() {
    if (!this.requestId) return;
    cancelAnimationFrame(this.requestId);
    this.requestId = undefined;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/cursorManager.mjs
/**
 * Manages the cursor styling for an element. Tracks the requested styling from distinct
 * dependents and handles conflicting styling requests.
 */
class CursorManager {
  constructor(element) {
    this.states = {};
    this.element = element;
  }
  updateCursor(callerId, style) {
    delete this.states[callerId];
    if (style != null) {
      this.states[callerId] = {
        style
      };
    }
    this.applyStates();
  }
  applyStates() {
    let styleToApply = 'default';
    // Last added entry wins.
    Object.entries(this.states).reverse().slice(0, 1).forEach(([_, {
      style
    }]) => styleToApply = style);
    this.element.style.cursor = styleToApply;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/chartEventManager.mjs

class ChartEventManager extends BaseManager {
  legendItemClick(series, itemId, enabled) {
    const event = {
      type: 'legend-item-click',
      series,
      itemId,
      enabled
    };
    this.listeners.dispatch('legend-item-click', event);
  }
  legendItemDoubleClick(series, itemId, enabled, numVisibleItems) {
    const event = {
      type: 'legend-item-double-click',
      series,
      itemId,
      enabled,
      numVisibleItems
    };
    this.listeners.dispatch('legend-item-double-click', event);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/highlightManager.mjs

function highlightManager_isEqual(a, b) {
  if (a === b) return true;
  if ((a === null || a === void 0 ? void 0 : a.series) !== (b === null || b === void 0 ? void 0 : b.series)) return false;
  if ((a === null || a === void 0 ? void 0 : a.itemId) !== (b === null || b === void 0 ? void 0 : b.itemId)) return false;
  if ((a === null || a === void 0 ? void 0 : a.datum) !== (b === null || b === void 0 ? void 0 : b.datum)) return false;
  return true;
}
/**
 * Manages the actively highlighted series/datum for a chart. Tracks the requested highlights from
 * distinct dependents and handles conflicting highlight requests.
 */
class HighlightManager extends BaseManager {
  constructor() {
    super();
    this.states = {};
    this.activeHighlight = undefined;
  }
  updateHighlight(callerId, highlightedDatum) {
    delete this.states[callerId];
    if (highlightedDatum != null) {
      this.states[callerId] = {
        highlightedDatum
      };
    }
    this.applyStates();
  }
  getActiveHighlight() {
    return this.activeHighlight;
  }
  applyStates() {
    const previousHighlight = this.activeHighlight;
    let highlightToApply = undefined;
    // Last added entry wins.
    Object.entries(this.states).reverse().slice(0, 1).forEach(([_, {
      highlightedDatum
    }]) => highlightToApply = highlightedDatum);
    this.activeHighlight = highlightToApply;
    const changed = !highlightManager_isEqual(previousHighlight, this.activeHighlight);
    if (changed) {
      const event = {
        type: 'highlight-change',
        previousHighlight,
        currentHighlight: this.activeHighlight
      };
      this.listeners.dispatch('highlight-change', event);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/interactionManager.mjs

var interactionManager_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};



const WINDOW_EVENT_HANDLERS = ['pagehide', 'mousemove', 'mouseup', 'wheel'];
const EVENT_HANDLERS = ['click', 'dblclick', 'contextmenu', 'mousedown', 'mouseout', 'mouseenter', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];
const CSS = `
.ag-chart-wrapper {
    touch-action: none;
}
`;
/**
 * Manages user interactions with a specific HTMLElement (or interactions that bubble from it's
 * children)
 */
class InteractionManager extends BaseManager {
  constructor(element, doc = document) {
    super();
    this.eventHandler = event => this.processEvent(event);
    this.mouseDown = false;
    this.touchDown = false;
    this.enabled = true;
    this.pausers = [];
    this.rootElement = doc.body;
    this.element = element;
    for (const type of EVENT_HANDLERS) {
      if (type.startsWith('touch')) {
        element.addEventListener(type, this.eventHandler, {
          passive: true
        });
      } else {
        element.addEventListener(type, this.eventHandler);
      }
    }
    for (const type of WINDOW_EVENT_HANDLERS) {
      if (type === 'wheel') {
        window.addEventListener(type, this.eventHandler, {
          passive: false
        });
      } else {
        window.addEventListener(type, this.eventHandler);
      }
    }
    if (InteractionManager.interactionDocuments.indexOf(doc) < 0) {
      const styleElement = document.createElement('style');
      styleElement.innerHTML = CSS;
      document.head.insertBefore(styleElement, document.head.querySelector('style'));
      InteractionManager.interactionDocuments.push(doc);
    }
  }
  destroy() {
    for (const type of WINDOW_EVENT_HANDLERS) {
      window.removeEventListener(type, this.eventHandler);
    }
    for (const type of EVENT_HANDLERS) {
      this.element.removeEventListener(type, this.eventHandler);
    }
  }
  resume(callerId) {
    this.pausers = this.pausers.filter(id => id !== callerId);
    this.enabled = this.pausers.length <= 0;
    return this.enabled;
  }
  pause(callerId) {
    this.enabled = false;
    this.pausers.push(callerId);
  }
  processEvent(event) {
    const types = this.decideInteractionEventTypes(event);
    if (types.length > 0 && this.enabled) {
      // Async dispatch to avoid blocking the event-processing thread.
      this.dispatchEvent(event, types).catch(e => Logger.errorOnce(e));
    }
  }
  dispatchEvent(event, types) {
    return interactionManager_awaiter(this, void 0, void 0, function* () {
      const coords = this.calculateCoordinates(event);
      if (coords == null) {
        return;
      }
      for (const type of types) {
        const interactionEvent = this.buildEvent(Object.assign(Object.assign({
          event
        }, coords), {
          type
        }));
        this.listeners.cancellableDispatch(type, () => interactionEvent.consumed, interactionEvent);
      }
    });
  }
  decideInteractionEventTypes(event) {
    switch (event.type) {
      case 'click':
        return ['click'];
      case 'dblclick':
        return ['dblclick'];
      case 'contextmenu':
        return ['contextmenu'];
      case 'mousedown':
        this.mouseDown = true;
        this.dragStartElement = event.target;
        return ['drag-start'];
      case 'touchstart':
        this.touchDown = true;
        this.dragStartElement = event.target;
        return ['drag-start'];
      case 'touchmove':
      case 'mousemove':
        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {
          // We only care about these events if the target is the canvas, unless
          // we're in the middle of a drag/slide.
          return [];
        }
        return this.mouseDown || this.touchDown ? ['drag'] : ['hover'];
      case 'mouseup':
        if (!this.mouseDown && !this.isEventOverElement(event)) {
          // We only care about these events if the target is the canvas, unless
          // we're in the middle of a drag.
          return [];
        }
        this.mouseDown = false;
        this.dragStartElement = undefined;
        return ['drag-end'];
      case 'touchend':
        if (!this.touchDown && !this.isEventOverElement(event)) {
          // We only care about these events if the target is the canvas, unless
          // we're in the middle of a slide.
          return [];
        }
        this.touchDown = false;
        this.dragStartElement = undefined;
        return ['drag-end'];
      case 'mouseout':
      case 'touchcancel':
        return ['leave'];
      case 'mouseenter':
        const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;
        if (this.mouseDown !== mouseButtonDown) {
          this.mouseDown = mouseButtonDown;
          return [mouseButtonDown ? 'drag-start' : 'drag-end'];
        }
        return [];
      case 'pagehide':
        return ['page-left'];
      case 'wheel':
        return ['wheel'];
    }
    return [];
  }
  isEventOverElement(event) {
    var _a;
    return event.target === this.element || ((_a = event.target) === null || _a === void 0 ? void 0 : _a.parentElement) === this.element;
  }
  calculateCoordinates(event) {
    var _a;
    if (event instanceof MouseEvent) {
      const {
        clientX,
        clientY,
        pageX,
        pageY,
        offsetX,
        offsetY
      } = event;
      return this.fixOffsets(event, {
        clientX,
        clientY,
        pageX,
        pageY,
        offsetX,
        offsetY
      });
    } else if (typeof TouchEvent !== 'undefined' && event instanceof TouchEvent) {
      const lastTouch = (_a = event.touches[0]) !== null && _a !== void 0 ? _a : event.changedTouches[0];
      const {
        clientX,
        clientY,
        pageX,
        pageY
      } = lastTouch;
      return Object.assign(Object.assign({}, InteractionManager.NULL_COORDS), {
        clientX,
        clientY,
        pageX,
        pageY
      });
    } else if (event instanceof PageTransitionEvent) {
      if (event.persisted) {
        // Don't fire the page-left event since the page maybe revisited.
        return;
      }
      return InteractionManager.NULL_COORDS;
    }
    // Unsupported event - abort.
  }

  fixOffsets(event, coords) {
    const offsets = el => {
      let x = 0;
      let y = 0;
      while (el) {
        x += el.offsetLeft;
        y += el.offsetTop;
        el = el.offsetParent;
      }
      return {
        x,
        y
      };
    };
    if (this.dragStartElement != null && event.target !== this.dragStartElement) {
      // Offsets need to be relative to the drag-start element to avoid jumps when
      // the pointer moves between element boundaries.
      const offsetDragStart = offsets(this.dragStartElement);
      const offsetEvent = offsets(event.target);
      coords.offsetX -= offsetDragStart.x - offsetEvent.x;
      coords.offsetY -= offsetDragStart.y - offsetEvent.y;
    }
    return coords;
  }
  buildEvent(opts) {
    const {
      type,
      event,
      clientX,
      clientY
    } = opts;
    let {
      offsetX,
      offsetY,
      pageX,
      pageY
    } = opts;
    if (!isNumber(offsetX) || !isNumber(offsetY)) {
      const rect = this.element.getBoundingClientRect();
      offsetX = clientX - rect.left;
      offsetY = clientY - rect.top;
    }
    if (!isNumber(pageX) || !isNumber(pageY)) {
      const pageRect = this.rootElement.getBoundingClientRect();
      pageX = clientX - pageRect.left;
      pageY = clientY - pageRect.top;
    }
    const builtEvent = {
      type,
      offsetX: offsetX,
      offsetY: offsetY,
      pageX: pageX,
      pageY: pageY,
      sourceEvent: event,
      consumed: false,
      consume: () => builtEvent.consumed = true
    };
    return builtEvent;
  }
}
InteractionManager.interactionDocuments = [];
InteractionManager.NULL_COORDS = {
  clientX: -Infinity,
  clientY: -Infinity,
  pageX: -Infinity,
  pageY: -Infinity,
  offsetX: -Infinity,
  offsetY: -Infinity
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/tooltipManager.mjs

/**
 * Manages the tooltip HTML an element. Tracks the requested HTML from distinct dependents and
 * handles conflicting tooltip requests.
 */
class TooltipManager {
  constructor(tooltip, interactionManager) {
    this.states = {};
    this.exclusiveAreas = {};
    this.destroyFns = [];
    this.tooltip = tooltip;
    const hoverRef = interactionManager.addListener('hover', e => this.checkExclusiveRects(e));
    this.destroyFns.push(() => interactionManager.removeListener(hoverRef));
  }
  updateTooltip(callerId, meta, content) {
    var _a;
    if (content == null) {
      content = (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.content;
    }
    if (!content) {
      delete this.states[callerId];
    } else {
      this.states[callerId] = {
        content,
        meta
      };
    }
    this.applyStates();
  }
  updateExclusiveRect(callerId, area) {
    if (area) {
      this.exclusiveAreas[callerId] = area;
    } else {
      delete this.exclusiveAreas[callerId];
    }
  }
  removeTooltip(callerId) {
    delete this.states[callerId];
    this.applyStates();
  }
  getTooltipMeta(callerId) {
    var _a;
    return (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.meta;
  }
  destroy() {
    for (const destroyFn of this.destroyFns) {
      destroyFn();
    }
  }
  checkExclusiveRects(e) {
    let newAppliedExclusiveArea;
    for (const [entryId, area] of Object.entries(this.exclusiveAreas)) {
      if (!area.containsPoint(e.offsetX, e.offsetY)) {
        continue;
      }
      newAppliedExclusiveArea = entryId;
      break;
    }
    if (newAppliedExclusiveArea === this.appliedExclusiveArea) {
      return;
    }
    this.appliedExclusiveArea = newAppliedExclusiveArea;
    this.applyStates();
  }
  applyStates() {
    var _a;
    const ids = this.appliedExclusiveArea ? [this.appliedExclusiveArea] : Object.keys(this.states);
    let contentToApply = undefined;
    let metaToApply = undefined;
    // Last added entry wins.
    ids.reverse();
    ids.slice(0, 1).forEach(id => {
      var _a;
      const {
        content,
        meta
      } = (_a = this.states[id]) !== null && _a !== void 0 ? _a : {};
      contentToApply = content;
      metaToApply = meta;
    });
    if (metaToApply === undefined || contentToApply === undefined) {
      this.appliedState = undefined;
      this.tooltip.toggle(false);
      return;
    }
    if (((_a = this.appliedState) === null || _a === void 0 ? void 0 : _a.content) === contentToApply) {
      const renderInstantly = this.tooltip.isVisible();
      this.tooltip.show(metaToApply, undefined, renderInstantly);
    } else {
      this.tooltip.show(metaToApply, contentToApply);
    }
    this.appliedState = {
      content: contentToApply,
      meta: metaToApply
    };
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/interaction/zoomManager.mjs

function zoomManager_isEqual(a, b) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (a === b) return true;
  if (((_a = a === null || a === void 0 ? void 0 : a.x) === null || _a === void 0 ? void 0 : _a.min) !== ((_b = b === null || b === void 0 ? void 0 : b.x) === null || _b === void 0 ? void 0 : _b.min)) return false;
  if (((_c = a === null || a === void 0 ? void 0 : a.x) === null || _c === void 0 ? void 0 : _c.max) !== ((_d = b === null || b === void 0 ? void 0 : b.x) === null || _d === void 0 ? void 0 : _d.max)) return false;
  if (((_e = a === null || a === void 0 ? void 0 : a.y) === null || _e === void 0 ? void 0 : _e.max) !== ((_f = b === null || b === void 0 ? void 0 : b.y) === null || _f === void 0 ? void 0 : _f.max)) return false;
  if (((_g = a === null || a === void 0 ? void 0 : a.y) === null || _g === void 0 ? void 0 : _g.min) !== ((_h = b === null || b === void 0 ? void 0 : b.y) === null || _h === void 0 ? void 0 : _h.min)) return false;
  return true;
}
/**
 * Manages the current zoom state for a chart. Tracks the requested zoom from distinct dependents
 * and handles conflicting zoom requests.
 */
class ZoomManager extends BaseManager {
  constructor() {
    super();
    this.states = {};
    this.currentZoom = undefined;
  }
  updateZoom(callerId, newZoom) {
    delete this.states[callerId];
    if (newZoom != null) {
      this.states[callerId] = Object.assign({}, newZoom);
    }
    this.applyStates();
  }
  getZoom() {
    return this.currentZoom;
  }
  applyStates() {
    const currentZoom = this.currentZoom;
    const zoomToApply = {};
    // Last added entry wins.
    for (const [_, {
      x,
      y
    }] of Object.entries(this.states)) {
      zoomToApply.x = x !== null && x !== void 0 ? x : zoomToApply.x;
      zoomToApply.y = y !== null && y !== void 0 ? y : zoomToApply.y;
    }
    this.currentZoom = zoomToApply.x != null || zoomToApply.y != null ? zoomToApply : undefined;
    const changed = !zoomManager_isEqual(currentZoom, this.currentZoom);
    if (!changed) {
      return;
    }
    const event = Object.assign({
      type: 'zoom-change'
    }, currentZoom !== null && currentZoom !== void 0 ? currentZoom : {});
    this.listeners.dispatch('zoom-change', event);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/layout/layoutService.mjs

function isLayoutStage(t) {
  return t !== 'layout-complete';
}
function isLayoutComplete(t) {
  return t === 'layout-complete';
}
class LayoutService {
  constructor() {
    this.layoutProcessors = new Listeners();
    this.listeners = new Listeners();
  }
  addListener(type, cb) {
    if (isLayoutStage(type)) {
      return this.layoutProcessors.addListener(type, cb);
    } else if (isLayoutComplete(type)) {
      return this.listeners.addListener(type, cb);
    }
    throw new Error('AG Charts - unsupported listener type: ' + type);
  }
  removeListener(listenerSymbol) {
    this.listeners.removeListener(listenerSymbol);
    this.layoutProcessors.removeListener(listenerSymbol);
  }
  dispatchPerformLayout(stage, ctx) {
    const result = this.layoutProcessors.reduceDispatch(stage, ({
      shrinkRect
    }, ctx) => [Object.assign(Object.assign({}, ctx), {
      shrinkRect
    })], ctx);
    return result !== null && result !== void 0 ? result : ctx;
  }
  dispatchLayoutComplete(event) {
    this.listeners.dispatch('layout-complete', event);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/dataService.mjs
class DataService {
  constructor(getSeries) {
    this.getSeries = getSeries;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chartUpdateType.mjs
/** Types of chart-update, in pipeline execution order. */
var ChartUpdateType;
(function (ChartUpdateType) {
  ChartUpdateType[ChartUpdateType["FULL"] = 0] = "FULL";
  ChartUpdateType[ChartUpdateType["PROCESS_DATA"] = 1] = "PROCESS_DATA";
  ChartUpdateType[ChartUpdateType["PERFORM_LAYOUT"] = 2] = "PERFORM_LAYOUT";
  ChartUpdateType[ChartUpdateType["SERIES_UPDATE"] = 3] = "SERIES_UPDATE";
  ChartUpdateType[ChartUpdateType["TOOLTIP_RECALCULATION"] = 4] = "TOOLTIP_RECALCULATION";
  ChartUpdateType[ChartUpdateType["SCENE_RENDER"] = 5] = "SCENE_RENDER";
  ChartUpdateType[ChartUpdateType["NONE"] = 6] = "NONE";
})(ChartUpdateType || (ChartUpdateType = {}));
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/updateService.mjs

class UpdateService {
  constructor(updateCallback) {
    this.updateCallback = updateCallback;
  }
  update(type = ChartUpdateType.FULL, {
    forceNodeDataRefresh = false
  } = {}) {
    this.updateCallback(type, {
      forceNodeDataRefresh
    });
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chartHighlight.mjs
var chartHighlight_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class ChartHighlight {
  constructor() {
    this.range = 'tooltip';
  }
}
chartHighlight_decorate([Validate(STRING_UNION('tooltip', 'node'))], ChartHighlight.prototype, "range", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/markerLabel.mjs
var markerLabel_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class MarkerLabel extends Group {
  constructor() {
    super({
      name: 'markerLabelGroup'
    });
    this.label = new Text();
    this._marker = new Square();
    this._markerSize = 15;
    this._spacing = 8;
    const label = this.label;
    label.textBaseline = 'middle';
    label.fontSize = 12;
    label.fontFamily = 'Verdana, sans-serif';
    label.fill = 'black';
    // For better looking vertical alignment of labels to markers.
    label.y = HdpiCanvas.has.textMetrics ? 1 : 0;
    this.append([this.marker, label]);
    this.update();
  }
  set marker(value) {
    if (this._marker !== value) {
      this.removeChild(this._marker);
      this._marker = value;
      this.appendChild(value);
      this.update();
    }
  }
  get marker() {
    return this._marker;
  }
  set markerSize(value) {
    if (this._markerSize !== value) {
      this._markerSize = value;
      this.update();
    }
  }
  get markerSize() {
    return this._markerSize;
  }
  set spacing(value) {
    if (this._spacing !== value) {
      this._spacing = value;
      this.update();
    }
  }
  get spacing() {
    return this._spacing;
  }
  update() {
    const marker = this.marker;
    const markerSize = this.markerSize;
    marker.size = markerSize;
    this.label.x = markerSize / 2 + this.spacing;
  }
  render(renderCtx) {
    // Cannot override field Group.opacity with get/set pair, so
    // propagate opacity changes here.
    this.marker.opacity = this.opacity;
    this.label.opacity = this.opacity;
    super.render(renderCtx);
  }
}
MarkerLabel.className = 'MarkerLabel';
markerLabel_decorate([ProxyPropertyOnWrite('label')], MarkerLabel.prototype, "text", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('label')], MarkerLabel.prototype, "fontStyle", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('label')], MarkerLabel.prototype, "fontWeight", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('label')], MarkerLabel.prototype, "fontSize", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('label')], MarkerLabel.prototype, "fontFamily", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('label', 'fill')], MarkerLabel.prototype, "color", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('marker', 'fill')], MarkerLabel.prototype, "markerFill", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('marker', 'stroke')], MarkerLabel.prototype, "markerStroke", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('marker', 'strokeWidth')], MarkerLabel.prototype, "markerStrokeWidth", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('marker', 'fillOpacity')], MarkerLabel.prototype, "markerFillOpacity", void 0);
markerLabel_decorate([ProxyPropertyOnWrite('marker', 'strokeOpacity')], MarkerLabel.prototype, "markerStrokeOpacity", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/gridLayout.mjs

function gridLayout({
  orientation,
  bboxes,
  maxHeight,
  maxWidth,
  itemPaddingY = 0,
  itemPaddingX = 0,
  forceResult = false
}) {
  const horizontal = orientation === 'horizontal';
  const primary = {
    max: horizontal ? maxWidth : maxHeight,
    fn: horizontal ? b => b.width : b => b.height,
    padding: horizontal ? itemPaddingX : itemPaddingY
  };
  const secondary = {
    max: !horizontal ? maxWidth : maxHeight,
    fn: !horizontal ? b => b.width : b => b.height,
    padding: !horizontal ? itemPaddingX : itemPaddingY
  };
  let processedBBoxCount = 0;
  const rawPages = [];
  while (processedBBoxCount < bboxes.length) {
    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);
    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);
    if (!result) {
      return;
    }
    processedBBoxCount += result.processedBBoxCount;
    rawPages.push(result.pageIndices);
  }
  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);
}
function processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {
  // If calculatePage() fails on the first guess, we could use the number of items that fit
  // as a good guess for the next iteration.
  const minGuess = 1;
  let startingGuess = estimateStartingGuess(bboxes, primary);
  if (startingGuess < minGuess) {
    if (!forceResult) {
      return undefined;
    }
    // Legend constraints too small! Display at least one row/column if forceResult is true
    startingGuess = minGuess;
  }
  for (let guess = startingGuess; guess >= minGuess; guess--) {
    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);
    if (pageIndices == null && guess <= minGuess) {
      // Can't layout!
      return undefined;
    }
    if (pageIndices == null) {
      // Guess again!
      continue;
    }
    if (typeof pageIndices === 'number') {
      // calculatePage() suggested a better guess, use that if it's more than minGuess.
      if (pageIndices <= minGuess) {
        // Can't layout!
        return undefined;
      }
      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;
      continue;
    }
    const processedBBoxCount = pageIndices.length * pageIndices[0].length; // this is an estimate, not all rows/columns will have the same length
    return {
      processedBBoxCount,
      pageIndices
    };
  }
}
function calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {
  var _a;
  const result = [];
  let sumSecondary = 0;
  let currentMaxSecondary = 0;
  let currentPrimaryIndices = [];
  const maxPrimaryValues = [];
  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {
    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;
    if (primaryValueIdx === 0) {
      sumSecondary += currentMaxSecondary;
      currentMaxSecondary = 0;
      if (currentPrimaryIndices.length > 0) {
        result.push(currentPrimaryIndices);
      }
      currentPrimaryIndices = [];
    }
    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;
    maxPrimaryValues[primaryValueIdx] = Math.max((_a = maxPrimaryValues[primaryValueIdx]) !== null && _a !== void 0 ? _a : 0, primaryValue);
    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);
    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;
    const returnResult = !forceResult || result.length > 0;
    if (currentSecondaryDimension > secondary.max && returnResult) {
      // Breached max secondary dimension size, return indices accumlated so far (but not in-progress row/column).
      currentPrimaryIndices = [];
      break;
    }
    const sumPrimary = maxPrimaryValues.reduce((sum, next) => sum + next, 0);
    if (sumPrimary > primary.max && !forceResult) {
      // Breached max main dimension size.
      if (maxPrimaryValues.length < primaryCount) {
        // Feedback as guess for next iteration if we're on the first round still.
        return maxPrimaryValues.length;
      }
      return undefined;
    }
    currentPrimaryIndices.push(bboxIndex + indexOffset);
  }
  if (currentPrimaryIndices.length > 0) {
    result.push(currentPrimaryIndices);
  }
  return result.length > 0 ? result : undefined;
}
function buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {
  let maxPageWidth = 0;
  let maxPageHeight = 0;
  const pages = rawPages.map(indices => {
    if (orientation === 'horizontal') {
      indices = transpose(indices);
    }
    let endIndex = 0;
    const columns = indices.map(colIndices => {
      const colBBoxes = colIndices.map(bboxIndex => {
        endIndex = Math.max(bboxIndex, endIndex);
        return bboxes[bboxIndex];
      });
      let columnHeight = 0;
      let columnWidth = 0;
      colBBoxes.forEach(bbox => {
        columnHeight += bbox.height + itemPaddingY;
        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);
      });
      return {
        indices: colIndices,
        bboxes: colBBoxes,
        columnHeight,
        columnWidth
      };
    });
    let pageWidth = 0;
    let pageHeight = 0;
    columns.forEach(column => {
      pageWidth += column.columnWidth;
      pageHeight = Math.max(pageHeight, column.columnHeight);
    });
    maxPageWidth = Math.max(pageWidth, maxPageWidth);
    maxPageHeight = Math.max(pageHeight, maxPageHeight);
    return {
      columns,
      startIndex: indices[0][0],
      endIndex,
      pageWidth,
      pageHeight
    };
  });
  return {
    pages,
    maxPageWidth,
    maxPageHeight
  };
}
function transpose(data) {
  const result = [];
  for (const _ of data[0]) {
    result.push([]);
  }
  data.forEach((innerData, dataIdx) => {
    innerData.forEach((item, itemIdx) => {
      result[itemIdx][dataIdx] = item;
    });
  });
  return result;
}
function estimateStartingGuess(bboxes, primary) {
  const n = bboxes.length;
  let primarySum = 0;
  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {
    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;
    if (primarySum > primary.max) {
      const ratio = n / bboxIndex;
      if (ratio < 2) {
        return Math.ceil(n / 2);
      }
      return bboxIndex;
    }
  }
  return n;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/pagination/pagination.mjs
var pagination_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};








class PaginationLabel {
  constructor() {
    this.color = 'black';
    this.fontStyle = undefined;
    this.fontWeight = undefined;
    this.fontSize = 12;
    this.fontFamily = 'Verdana, sans-serif';
  }
}
pagination_decorate([Validate(COLOR_STRING)], PaginationLabel.prototype, "color", void 0);
pagination_decorate([Validate(OPT_FONT_STYLE)], PaginationLabel.prototype, "fontStyle", void 0);
pagination_decorate([Validate(OPT_FONT_WEIGHT)], PaginationLabel.prototype, "fontWeight", void 0);
pagination_decorate([Validate(NUMBER(0))], PaginationLabel.prototype, "fontSize", void 0);
pagination_decorate([Validate(STRING)], PaginationLabel.prototype, "fontFamily", void 0);
class PaginationMarkerStyle {
  constructor() {
    this.size = 15;
    this.fill = undefined;
    this.fillOpacity = undefined;
    this.stroke = undefined;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
  }
}
pagination_decorate([Validate(NUMBER(0))], PaginationMarkerStyle.prototype, "size", void 0);
pagination_decorate([Validate(OPT_COLOR_STRING)], PaginationMarkerStyle.prototype, "fill", void 0);
pagination_decorate([Validate(OPT_NUMBER(0, 1))], PaginationMarkerStyle.prototype, "fillOpacity", void 0);
pagination_decorate([Validate(OPT_COLOR_STRING)], PaginationMarkerStyle.prototype, "stroke", void 0);
pagination_decorate([Validate(NUMBER(0))], PaginationMarkerStyle.prototype, "strokeWidth", void 0);
pagination_decorate([Validate(NUMBER(0, 1))], PaginationMarkerStyle.prototype, "strokeOpacity", void 0);
class PaginationMarker {
  constructor() {
    this.size = 15;
    this._shape = Triangle;
    /**
     * Inner padding between a pagination button and the label.
     */
    this.padding = 8;
  }
  set shape(value) {
    var _a;
    this._shape = value;
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();
  }
  get shape() {
    return this._shape;
  }
}
pagination_decorate([Validate(NUMBER(0))], PaginationMarker.prototype, "size", void 0);
pagination_decorate([Validate(NUMBER(0))], PaginationMarker.prototype, "padding", void 0);
class Pagination {
  constructor(chartUpdateCallback, pageUpdateCallback, interactionManager, cursorManager) {
    this.chartUpdateCallback = chartUpdateCallback;
    this.pageUpdateCallback = pageUpdateCallback;
    this.interactionManager = interactionManager;
    this.cursorManager = cursorManager;
    this.id = createId(this);
    this.group = new Group({
      name: 'pagination'
    });
    this.labelNode = new Text();
    this.marker = new PaginationMarker();
    this.activeStyle = new PaginationMarkerStyle();
    this.inactiveStyle = new PaginationMarkerStyle();
    this.highlightStyle = new PaginationMarkerStyle();
    this.label = new PaginationLabel();
    this.totalPages = 0;
    this.currentPage = 0;
    this.translationX = 0;
    this.translationY = 0;
    this.nextButtonDisabled = false;
    this.previousButtonDisabled = false;
    this._visible = true;
    this._enabled = true;
    this._orientation = 'vertical';
    this._nextButton = new Triangle();
    this._previousButton = new Triangle();
    const {
      labelNode
    } = this;
    labelNode.textBaseline = 'middle';
    labelNode.fontSize = 12;
    labelNode.fontFamily = 'Verdana, sans-serif';
    labelNode.fill = 'black';
    labelNode.y = HdpiCanvas.has.textMetrics ? 1 : 0;
    this.group.append([this.nextButton, this.previousButton, labelNode]);
    this.interactionManager.addListener('click', event => this.onPaginationClick(event));
    this.interactionManager.addListener('hover', event => this.onPaginationMouseMove(event));
    this.marker.parent = this;
    this.update();
    this.updateMarkers();
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  set enabled(value) {
    this._enabled = value;
    this.updateGroupVisibility();
  }
  get enabled() {
    return this._enabled;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible;
  }
  set orientation(value) {
    this._orientation = value;
    switch (value) {
      case 'horizontal':
        {
          this.previousButton.rotation = -Math.PI / 2;
          this.nextButton.rotation = Math.PI / 2;
          break;
        }
      case 'vertical':
      default:
        {
          this.previousButton.rotation = 0;
          this.nextButton.rotation = Math.PI;
        }
    }
  }
  get orientation() {
    return this._orientation;
  }
  set nextButton(value) {
    if (this._nextButton !== value) {
      this.group.removeChild(this._nextButton);
      this._nextButton = value;
      this.group.appendChild(value);
    }
  }
  get nextButton() {
    return this._nextButton;
  }
  set previousButton(value) {
    if (this._previousButton !== value) {
      this.group.removeChild(this._previousButton);
      this._previousButton = value;
      this.group.appendChild(value);
    }
  }
  get previousButton() {
    return this._previousButton;
  }
  update() {
    this.updateLabel();
    this.updatePositions();
    this.enableOrDisableButtons();
  }
  updatePositions() {
    this.group.translationX = this.translationX;
    this.group.translationY = this.translationY;
    this.updateLabelPosition();
    this.updateNextButtonPosition();
  }
  updateLabelPosition() {
    const {
      size: markerSize,
      padding: markerPadding
    } = this.marker;
    this.nextButton.size = markerSize;
    this.previousButton.size = markerSize;
    this.labelNode.x = markerSize / 2 + markerPadding;
  }
  updateNextButtonPosition() {
    const labelBBox = this.labelNode.computeBBox();
    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;
  }
  updateLabel() {
    const {
      currentPage,
      totalPages: pages,
      labelNode,
      label: {
        color,
        fontStyle,
        fontWeight,
        fontSize,
        fontFamily
      }
    } = this;
    labelNode.text = `${currentPage + 1} / ${pages}`;
    labelNode.fill = color;
    labelNode.fontStyle = fontStyle;
    labelNode.fontWeight = fontWeight;
    labelNode.fontSize = fontSize;
    labelNode.fontFamily = fontFamily;
  }
  updateMarkers() {
    const {
      nextButton,
      previousButton,
      nextButtonDisabled,
      previousButtonDisabled,
      activeStyle,
      inactiveStyle,
      highlightStyle,
      highlightActive
    } = this;
    const buttonStyle = (button, disabled) => {
      if (disabled) {
        return inactiveStyle;
      } else if (button === highlightActive) {
        return highlightStyle;
      }
      return activeStyle;
    };
    this.updateMarker(nextButton, buttonStyle('next', nextButtonDisabled));
    this.updateMarker(previousButton, buttonStyle('previous', previousButtonDisabled));
  }
  updateMarker(marker, style) {
    var _a;
    const {
      size
    } = this.marker;
    marker.size = size;
    marker.fill = style.fill;
    marker.fillOpacity = (_a = style.fillOpacity) !== null && _a !== void 0 ? _a : 1;
    marker.stroke = style.stroke;
    marker.strokeWidth = style.strokeWidth;
    marker.strokeOpacity = style.strokeOpacity;
  }
  enableOrDisableButtons() {
    const {
      currentPage,
      totalPages
    } = this;
    const zeroPagesToDisplay = totalPages === 0;
    const onLastPage = currentPage === totalPages - 1;
    const onFirstPage = currentPage === 0;
    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;
  }
  nextButtonContainsPoint(offsetX, offsetY) {
    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);
  }
  previousButtonContainsPoint(offsetX, offsetY) {
    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);
  }
  onPaginationClick(event) {
    const {
      offsetX,
      offsetY
    } = event;
    if (this.nextButtonContainsPoint(offsetX, offsetY)) {
      this.incrementPage();
      this.onPaginationChanged();
      event.consume();
    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {
      this.decrementPage();
      this.onPaginationChanged();
      event.consume();
    }
  }
  onPaginationMouseMove(event) {
    const {
      offsetX,
      offsetY
    } = event;
    if (this.nextButtonContainsPoint(offsetX, offsetY)) {
      this.cursorManager.updateCursor(this.id, 'pointer');
      this.highlightActive = 'next';
    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {
      this.cursorManager.updateCursor(this.id, 'pointer');
      this.highlightActive = 'previous';
    } else {
      this.cursorManager.updateCursor(this.id);
      this.highlightActive = undefined;
    }
    this.updateMarkers();
    this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);
  }
  onPaginationChanged() {
    this.pageUpdateCallback(this.currentPage);
  }
  incrementPage() {
    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
  }
  decrementPage() {
    this.currentPage = Math.max(this.currentPage - 1, 0);
  }
  onMarkerShapeChange() {
    const Marker = getMarker(this.marker.shape || Triangle);
    this.previousButton = new Marker();
    this.nextButton = new Marker();
    this.updatePositions();
    this.updateMarkers();
    this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);
  }
  attachPagination(node) {
    node.append(this.group);
  }
  computeBBox() {
    return this.group.computeBBox();
  }
}
Pagination.className = 'Pagination';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/legend.mjs

var legend_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
















const ORIENTATIONS = ['horizontal', 'vertical'];
const OPT_ORIENTATION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, v => ORIENTATIONS.includes(v)), `expecting an orientation keyword such as 'horizontal' or 'vertical'`);
class LegendLabel {
  constructor() {
    this.maxLength = undefined;
    this.color = 'black';
    this.fontStyle = undefined;
    this.fontWeight = undefined;
    this.fontSize = 12;
    this.fontFamily = 'Verdana, sans-serif';
    this.formatter = undefined;
  }
}
legend_decorate([Validate(OPT_NUMBER(0))], LegendLabel.prototype, "maxLength", void 0);
legend_decorate([Validate(COLOR_STRING)], LegendLabel.prototype, "color", void 0);
legend_decorate([Validate(OPT_FONT_STYLE)], LegendLabel.prototype, "fontStyle", void 0);
legend_decorate([Validate(OPT_FONT_WEIGHT)], LegendLabel.prototype, "fontWeight", void 0);
legend_decorate([Validate(NUMBER(0))], LegendLabel.prototype, "fontSize", void 0);
legend_decorate([Validate(STRING)], LegendLabel.prototype, "fontFamily", void 0);
legend_decorate([Validate(OPT_FUNCTION)], LegendLabel.prototype, "formatter", void 0);
class LegendMarker {
  constructor() {
    this.size = 15;
    /**
     * If the marker type is set, the legend will always use that marker type for all its items,
     * regardless of the type that comes from the `data`.
     */
    this._shape = undefined;
    /**
     * Padding between the marker and the label within each legend item.
     */
    this.padding = 8;
    this.strokeWidth = 1;
  }
  set shape(value) {
    var _a;
    this._shape = value;
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();
  }
  get shape() {
    return this._shape;
  }
}
legend_decorate([Validate(NUMBER(0))], LegendMarker.prototype, "size", void 0);
legend_decorate([Validate(NUMBER(0))], LegendMarker.prototype, "padding", void 0);
legend_decorate([Validate(NUMBER(0))], LegendMarker.prototype, "strokeWidth", void 0);
class LegendItem {
  constructor() {
    this.marker = new LegendMarker();
    this.label = new LegendLabel();
    /** Used to constrain the width of legend items. */
    this.maxWidth = undefined;
    /**
     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,
     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal
     * padding between legend items.
     */
    this.paddingX = 16;
    /**
     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,
     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical
     * padding between legend items.
     */
    this.paddingY = 8;
    this.toggleSeriesVisible = true;
  }
}
legend_decorate([Validate(OPT_NUMBER(0))], LegendItem.prototype, "maxWidth", void 0);
legend_decorate([Validate(NUMBER(0))], LegendItem.prototype, "paddingX", void 0);
legend_decorate([Validate(NUMBER(0))], LegendItem.prototype, "paddingY", void 0);
legend_decorate([Validate(BOOLEAN)], LegendItem.prototype, "toggleSeriesVisible", void 0);
class LegendListeners {
  constructor() {
    this.legendItemClick = undefined;
    this.legendItemDoubleClick = undefined;
  }
}
legend_decorate([Validate(OPT_FUNCTION)], LegendListeners.prototype, "legendItemClick", void 0);
class Legend {
  constructor(ctx) {
    this.ctx = ctx;
    this.id = createId(this);
    this.group = new Group({
      name: 'legend',
      layer: true,
      zIndex: Layers.LEGEND_ZINDEX
    });
    this.itemSelection = Selection.select(this.group, MarkerLabel);
    this.oldSize = [0, 0];
    this.pages = [];
    this.maxPageSize = [0, 0];
    /** Item index to track on re-pagination, so current page updates appropriately. */
    this.paginationTrackingIndex = 0;
    this.item = new LegendItem();
    this.listeners = new LegendListeners();
    this.truncatedItems = new Set();
    this._data = [];
    this._enabled = true;
    this.position = 'bottom';
    /** Used to constrain the width of the legend. */
    this.maxWidth = undefined;
    /** Used to constrain the height of the legend. */
    this.maxHeight = undefined;
    /** Reverse the display order of legend items if `true`. */
    this.reverseOrder = undefined;
    this.destroyFns = [];
    /**
     * Spacing between the legend and the edge of the chart's element.
     */
    this.spacing = 20;
    this.characterWidths = new Map();
    this.size = [0, 0];
    this._visible = true;
    this.item.marker.parent = this;
    this.pagination = new Pagination(type => ctx.updateService.update(type), page => this.updatePageNumber(page), ctx.interactionManager, ctx.cursorManager);
    this.pagination.attachPagination(this.group);
    this.item.marker.parent = this;
    const interactionListeners = [ctx.interactionManager.addListener('click', e => this.checkLegendClick(e)), ctx.interactionManager.addListener('dblclick', e => this.checkLegendDoubleClick(e)), ctx.interactionManager.addListener('hover', e => this.handleLegendMouseMove(e))];
    const layoutListeners = [ctx.layoutService.addListener('start-layout', e => this.positionLegend(e.shrinkRect))];
    this.destroyFns.push(...interactionListeners.map(s => () => ctx.interactionManager.removeListener(s)), ...layoutListeners.map(s => () => ctx.layoutService.removeListener(s)), () => this.detachLegend());
  }
  set data(value) {
    this._data = value;
    this.updateGroupVisibility();
  }
  get data() {
    return this._data;
  }
  set enabled(value) {
    this._enabled = value;
    this.updateGroupVisibility();
  }
  get enabled() {
    return this._enabled;
  }
  getOrientation() {
    if (this.orientation !== undefined) {
      return this.orientation;
    }
    switch (this.position) {
      case 'right':
      case 'left':
        return 'vertical';
      case 'bottom':
      case 'top':
        return 'horizontal';
    }
  }
  destroy() {
    this.destroyFns.forEach(f => f());
  }
  onMarkerShapeChange() {
    this.itemSelection.clear();
    this.group.markDirty(this.group, RedrawType.MINOR);
  }
  getCharacterWidths(font) {
    const {
      characterWidths
    } = this;
    if (characterWidths.has(font)) {
      return characterWidths.get(font);
    }
    const cw = {
      '...': HdpiCanvas.getTextSize('...', font).width
    };
    characterWidths.set(font, cw);
    return cw;
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible && this.data.length > 0;
  }
  attachLegend(node) {
    node.append(this.group);
  }
  detachLegend() {
    var _a;
    (_a = this.group.parent) === null || _a === void 0 ? void 0 : _a.removeChild(this.group);
  }
  getItemLabel(datum) {
    const {
      ctx: {
        callbackCache
      }
    } = this;
    const {
      formatter
    } = this.item.label;
    if (formatter) {
      return callbackCache.call(formatter, {
        itemId: datum.itemId,
        value: datum.label.text,
        seriesId: datum.seriesId
      });
    }
    return datum.label.text;
  }
  /**
   * The method is given the desired size of the legend, which only serves as a hint.
   * The vertically oriented legend will take as much horizontal space as needed, but will
   * respect the height constraints, and the horizontal legend will take as much vertical
   * space as needed in an attempt not to exceed the given width.
   * After the layout is done, the {@link size} will contain the actual size of the legend.
   * If the actual size is not the same as the previous actual size, the legend will fire
   * the 'layoutChange' event to communicate that another layout is needed, and the above
   * process should be repeated.
   * @param width
   * @param height
   */
  performLayout(width, height) {
    const {
      paddingX,
      paddingY,
      label,
      maxWidth,
      marker: {
        size: markerSize,
        padding: markerPadding,
        shape: markerShape
      },
      label: {
        maxLength = Infinity,
        fontStyle,
        fontWeight,
        fontSize,
        fontFamily
      }
    } = this.item;
    const data = [...this.data];
    if (this.reverseOrder) {
      data.reverse();
    }
    this.itemSelection.update(data);
    // Update properties that affect the size of the legend items and measure them.
    const bboxes = [];
    const font = getFont(label);
    const itemMaxWidthPercentage = 0.8;
    const maxItemWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : width * itemMaxWidthPercentage;
    const paddedMarkerWidth = markerSize + markerPadding + paddingX;
    this.itemSelection.each((markerLabel, datum) => {
      var _a;
      const Marker = getMarker(markerShape !== null && markerShape !== void 0 ? markerShape : datum.marker.shape);
      if (!(markerLabel.marker && markerLabel.marker instanceof Marker)) {
        markerLabel.marker = new Marker();
      }
      markerLabel.markerSize = markerSize;
      markerLabel.spacing = markerPadding;
      markerLabel.fontStyle = fontStyle;
      markerLabel.fontWeight = fontWeight;
      markerLabel.fontSize = fontSize;
      markerLabel.fontFamily = fontFamily;
      const id = (_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id;
      const labelText = this.getItemLabel(datum);
      const text = (labelText !== null && labelText !== void 0 ? labelText : '<unknown>').replace(/\r?\n/g, ' ');
      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedMarkerWidth, font, id);
      bboxes.push(markerLabel.computeBBox());
    });
    width = Math.max(1, width);
    height = Math.max(1, height);
    if (!isFinite(width)) {
      return false;
    }
    const size = this.size;
    const oldSize = this.oldSize;
    size[0] = width;
    size[1] = height;
    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      oldSize[0] = size[0];
      oldSize[1] = size[1];
    }
    const {
      pages,
      maxPageHeight,
      maxPageWidth
    } = this.updatePagination(bboxes, width, height);
    this.pages = pages;
    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];
    const pageNumber = this.pagination.currentPage;
    const page = this.pages[pageNumber];
    if (this.pages.length < 1 || !page) {
      this.visible = false;
      return;
    }
    this.visible = true;
    // Position legend items
    this.updatePositions(pageNumber);
    // Update legend item properties that don't affect the layout.
    this.update();
  }
  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {
    const ellipsis = `...`;
    const textChars = text.split('');
    let addEllipsis = false;
    if (text.length > maxCharLength) {
      text = `${text.substring(0, maxCharLength)}`;
      addEllipsis = true;
    }
    const labelWidth = Math.floor(paddedMarkerWidth + HdpiCanvas.getTextSize(text, font).width);
    if (labelWidth > maxItemWidth) {
      let truncatedText = '';
      const characterWidths = this.getCharacterWidths(font);
      let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis];
      for (const char of textChars) {
        if (!characterWidths[char]) {
          characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;
        }
        cumulativeWidth += characterWidths[char];
        if (cumulativeWidth > maxItemWidth) {
          break;
        }
        truncatedText += char;
      }
      text = truncatedText;
      addEllipsis = true;
    }
    if (addEllipsis) {
      text += ellipsis;
      this.truncatedItems.add(id);
    } else {
      this.truncatedItems.delete(id);
    }
    return text;
  }
  updatePagination(bboxes, width, height) {
    const orientation = this.getOrientation();
    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);
    this.pagination.orientation = orientation;
    this.pagination.translationX = 0;
    this.pagination.translationY = 0;
    const {
      pages,
      maxPageHeight,
      maxPageWidth,
      paginationBBox,
      paginationVertical
    } = this.calculatePagination(bboxes, width, height);
    const newCurrentPage = pages.findIndex(p => p.endIndex >= trackingIndex);
    this.pagination.currentPage = Math.min(Math.max(newCurrentPage, 0), pages.length - 1);
    const {
      paddingX: itemPaddingX,
      paddingY: itemPaddingY
    } = this.item;
    const paginationComponentPadding = 8;
    const legendItemsWidth = maxPageWidth - itemPaddingX;
    const legendItemsHeight = maxPageHeight - itemPaddingY;
    let paginationX = 0;
    let paginationY = -paginationBBox.y - this.item.marker.size / 2;
    if (paginationVertical) {
      paginationY += legendItemsHeight + paginationComponentPadding;
    } else {
      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;
      paginationY += (legendItemsHeight - paginationBBox.height) / 2;
    }
    this.pagination.translationX = paginationX;
    this.pagination.translationY = paginationY;
    this.pagination.update();
    this.pagination.updateMarkers();
    return {
      maxPageHeight,
      maxPageWidth,
      pages
    };
  }
  calculatePagination(bboxes, width, height) {
    var _a, _b, _c;
    const {
      paddingX: itemPaddingX,
      paddingY: itemPaddingY
    } = this.item;
    const orientation = this.getOrientation();
    const paginationVertical = ['left', 'right'].includes(this.position);
    let paginationBBox = this.pagination.computeBBox();
    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);
    let pages = [];
    let maxPageWidth = 0;
    let maxPageHeight = 0;
    let count = 0;
    const stableOutput = lastPassPaginationBBox => {
      const {
        width,
        height
      } = lastPassPaginationBBox;
      return width === paginationBBox.width && height === paginationBBox.height;
    };
    const forceResult = this.maxWidth !== undefined || this.maxHeight !== undefined;
    do {
      if (count++ > 10) {
        Logger.warn('unable to find stable legend layout.');
        break;
      }
      paginationBBox = lastPassPaginationBBox;
      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);
      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);
      const layout = gridLayout({
        orientation,
        bboxes,
        maxHeight,
        maxWidth,
        itemPaddingY,
        itemPaddingX,
        forceResult
      });
      pages = (_a = layout === null || layout === void 0 ? void 0 : layout.pages) !== null && _a !== void 0 ? _a : [];
      maxPageWidth = (_b = layout === null || layout === void 0 ? void 0 : layout.maxPageWidth) !== null && _b !== void 0 ? _b : 0;
      maxPageHeight = (_c = layout === null || layout === void 0 ? void 0 : layout.maxPageHeight) !== null && _c !== void 0 ? _c : 0;
      const totalPages = pages.length;
      this.pagination.visible = totalPages > 1;
      this.pagination.totalPages = totalPages;
      this.pagination.update();
      lastPassPaginationBBox = this.pagination.computeBBox();
      if (!this.pagination.visible) {
        break;
      }
    } while (!stableOutput(lastPassPaginationBBox));
    return {
      maxPageWidth,
      maxPageHeight,
      pages,
      paginationBBox,
      paginationVertical
    };
  }
  updatePositions(pageNumber = 0) {
    const {
      item: {
        paddingY
      },
      itemSelection,
      pages
    } = this;
    if (pages.length < 1 || !pages[pageNumber]) {
      return;
    }
    const {
      columns,
      startIndex: visibleStart,
      endIndex: visibleEnd
    } = pages[pageNumber];
    // Position legend items using the layout computed above.
    let x = 0;
    let y = 0;
    const columnCount = columns.length;
    const rowCount = columns[0].indices.length;
    const horizontal = this.getOrientation() === 'horizontal';
    const itemHeight = columns[0].bboxes[0].height + paddingY;
    const rowSumColumnWidths = [];
    itemSelection.each((markerLabel, _, i) => {
      var _a, _b;
      if (i < visibleStart || i > visibleEnd) {
        markerLabel.visible = false;
        return;
      }
      const pageIndex = i - visibleStart;
      let columnIndex = 0;
      let rowIndex = 0;
      if (horizontal) {
        columnIndex = pageIndex % columnCount;
        rowIndex = Math.floor(pageIndex / columnCount);
      } else {
        columnIndex = Math.floor(pageIndex / rowCount);
        rowIndex = pageIndex % rowCount;
      }
      markerLabel.visible = true;
      const column = columns[columnIndex];
      if (!column) {
        return;
      }
      y = itemHeight * rowIndex;
      x = (_a = rowSumColumnWidths[rowIndex]) !== null && _a !== void 0 ? _a : 0;
      rowSumColumnWidths[rowIndex] = ((_b = rowSumColumnWidths[rowIndex]) !== null && _b !== void 0 ? _b : 0) + column.columnWidth;
      // Round off for pixel grid alignment to work properly.
      markerLabel.translationX = Math.floor(x);
      markerLabel.translationY = Math.floor(y);
    });
  }
  updatePageNumber(pageNumber) {
    const {
      pages
    } = this;
    // Track an item on the page in re-pagination cases (e.g. resize).
    const {
      startIndex,
      endIndex
    } = pages[pageNumber];
    if (startIndex === 0) {
      // Stay on first page on pagination update.
      this.paginationTrackingIndex = 0;
    } else if (pageNumber === pages.length - 1) {
      // Stay on last page on pagination update.
      this.paginationTrackingIndex = endIndex;
    } else {
      // Track the middle item on the page).
      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);
    }
    this.pagination.update();
    this.pagination.updateMarkers();
    this.updatePositions(pageNumber);
    this.ctx.updateService.update(ChartUpdateType.SCENE_RENDER);
  }
  update() {
    const {
      marker: {
        strokeWidth
      },
      label: {
        color
      }
    } = this.item;
    this.itemSelection.each((markerLabel, datum) => {
      const marker = datum.marker;
      markerLabel.markerFill = marker.fill;
      markerLabel.markerStroke = marker.stroke;
      markerLabel.markerStrokeWidth = strokeWidth;
      markerLabel.markerFillOpacity = marker.fillOpacity;
      markerLabel.markerStrokeOpacity = marker.strokeOpacity;
      markerLabel.opacity = datum.enabled ? 1 : 0.5;
      markerLabel.color = color;
    });
  }
  getDatumForPoint(x, y) {
    const visibleChildBBoxes = [];
    const closestLeftTop = {
      dist: Infinity,
      datum: undefined
    };
    for (const child of this.group.children) {
      if (!child.visible) continue;
      if (!(child instanceof MarkerLabel)) continue;
      const childBBox = child.computeBBox();
      childBBox.grow(this.item.paddingX / 2, 'horizontal');
      childBBox.grow(this.item.paddingY / 2, 'vertical');
      if (childBBox.containsPoint(x, y)) {
        return child.datum;
      }
      const distX = x - childBBox.x - this.item.paddingX / 2;
      const distY = y - childBBox.y - this.item.paddingY / 2;
      const dist = Math.pow(distX, 2) + Math.pow(distY, 2);
      const toTheLeftTop = distX >= 0 && distY >= 0;
      if (toTheLeftTop && dist < closestLeftTop.dist) {
        closestLeftTop.dist = dist;
        closestLeftTop.datum = child.datum;
      }
      visibleChildBBoxes.push(childBBox);
    }
    const pageBBox = BBox.merge(visibleChildBBoxes);
    if (!pageBBox.containsPoint(x, y)) {
      // We're not in-between legend items.
      return undefined;
    }
    // Fallback to returning closest match to the left/up.
    return closestLeftTop.datum;
  }
  computeBBox() {
    return this.group.computeBBox();
  }
  computePagedBBox() {
    const actualBBox = this.group.computeBBox();
    if (this.pages.length <= 1) {
      return actualBBox;
    }
    const [maxPageWidth, maxPageHeight] = this.maxPageSize;
    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);
    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);
    return actualBBox;
  }
  checkLegendClick(event) {
    const {
      listeners: {
        legendItemClick
      },
      ctx: {
        dataService,
        highlightManager
      },
      item: {
        toggleSeriesVisible
      }
    } = this;
    const {
      offsetX,
      offsetY
    } = event;
    const legendBBox = this.computeBBox();
    const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);
    const datum = this.getDatumForPoint(offsetX, offsetY);
    if (!pointerInsideLegend || !datum) {
      return;
    }
    const {
      id,
      itemId,
      enabled
    } = datum;
    const chartSeries = dataService.getSeries();
    const series = chartSeries.find(s => s.id === id);
    if (!series) {
      return;
    }
    event.consume();
    let newEnabled = enabled;
    if (toggleSeriesVisible) {
      newEnabled = !enabled;
      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled);
    }
    if (!newEnabled) {
      highlightManager.updateHighlight(this.id);
    } else {
      highlightManager.updateHighlight(this.id, {
        series,
        itemId,
        datum: undefined
      });
    }
    this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, {
      forceNodeDataRefresh: true
    });
    legendItemClick === null || legendItemClick === void 0 ? void 0 : legendItemClick({
      type: 'click',
      enabled: newEnabled,
      itemId,
      seriesId: series.id
    });
  }
  checkLegendDoubleClick(event) {
    var _a;
    const {
      listeners: {
        legendItemDoubleClick
      },
      ctx: {
        dataService
      },
      item: {
        toggleSeriesVisible
      }
    } = this;
    const {
      offsetX,
      offsetY
    } = event;
    // Integrated charts do not handle double click behaviour correctly due to multiple instances of the
    // chart being created. See https://ag-grid.atlassian.net/browse/RTI-1381
    if (this.ctx.mode === 'integrated') {
      return;
    }
    const legendBBox = this.computeBBox();
    const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);
    const datum = this.getDatumForPoint(offsetX, offsetY);
    if (!pointerInsideLegend || !datum) {
      return;
    }
    const {
      id,
      itemId,
      seriesId
    } = datum;
    const chartSeries = dataService.getSeries();
    const series = chartSeries.find(s => s.id === id);
    if (!series) {
      return;
    }
    event.consume();
    if (toggleSeriesVisible) {
      const legendData = chartSeries.reduce((ls, s) => [...ls, ...s.getLegendData().filter(d => d.legendType === 'category')], []);
      const numVisibleItems = {};
      legendData.forEach(d => {
        var _a;
        var _b;
        (_a = numVisibleItems[_b = d.seriesId]) !== null && _a !== void 0 ? _a : numVisibleItems[_b] = 0;
        if (d.enabled) numVisibleItems[d.seriesId]++;
      });
      const clickedItem = legendData.find(d => d.itemId === itemId && d.seriesId === seriesId);
      this.ctx.chartEventManager.legendItemDoubleClick(series, itemId, (_a = clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.enabled) !== null && _a !== void 0 ? _a : false, numVisibleItems);
    }
    this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, {
      forceNodeDataRefresh: true
    });
    legendItemDoubleClick === null || legendItemDoubleClick === void 0 ? void 0 : legendItemDoubleClick({
      type: 'dblclick',
      enabled: true,
      itemId,
      seriesId: series.id
    });
  }
  handleLegendMouseMove(event) {
    var _a;
    const {
      enabled,
      item: {
        toggleSeriesVisible
      },
      listeners
    } = this;
    if (!enabled) {
      return;
    }
    const legendBBox = this.computeBBox();
    const {
      pageX,
      pageY,
      offsetX,
      offsetY
    } = event;
    const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);
    if (!pointerInsideLegend) {
      this.ctx.cursorManager.updateCursor(this.id);
      this.ctx.highlightManager.updateHighlight(this.id);
      this.ctx.tooltipManager.removeTooltip(this.id);
      return;
    }
    // Prevent other handlers from consuming this event if it's generated inside the legend
    // boundaries.
    event.consume();
    const datum = this.getDatumForPoint(offsetX, offsetY);
    const pointerOverLegendDatum = pointerInsideLegend && datum !== undefined;
    if (!pointerOverLegendDatum) {
      this.ctx.cursorManager.updateCursor(this.id);
      this.ctx.highlightManager.updateHighlight(this.id);
      return;
    }
    const series = datum ? this.ctx.dataService.getSeries().find(series => series.id === (datum === null || datum === void 0 ? void 0 : datum.id)) : undefined;
    if (datum && this.truncatedItems.has((_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id)) {
      const labelText = this.getItemLabel(datum);
      this.ctx.tooltipManager.updateTooltip(this.id, {
        pageX,
        pageY,
        offsetX,
        offsetY,
        event,
        showArrow: false
      }, toTooltipHtml({
        content: labelText
      }));
    } else {
      this.ctx.tooltipManager.removeTooltip(this.id);
    }
    if (toggleSeriesVisible || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {
      this.ctx.cursorManager.updateCursor(this.id, 'pointer');
    }
    if ((datum === null || datum === void 0 ? void 0 : datum.enabled) && series) {
      this.ctx.highlightManager.updateHighlight(this.id, {
        series,
        itemId: datum === null || datum === void 0 ? void 0 : datum.itemId,
        datum: undefined
      });
    } else {
      this.ctx.highlightManager.updateHighlight(this.id);
    }
  }
  positionLegend(shrinkRect) {
    const newShrinkRect = shrinkRect.clone();
    if (!this.enabled || !this.data.length) {
      return {
        shrinkRect: newShrinkRect
      };
    }
    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);
    this.group.translationX = 0;
    this.group.translationY = 0;
    this.performLayout(legendWidth, legendHeight);
    const legendBBox = this.computePagedBBox();
    const calculateTranslationPerpendicularDimension = () => {
      switch (this.position) {
        case 'top':
          return 0;
        case 'bottom':
          return shrinkRect.height - legendBBox.height;
        case 'left':
          return 0;
        case 'right':
        default:
          return shrinkRect.width - legendBBox.width;
      }
    };
    if (this.visible) {
      let translationX;
      let translationY;
      switch (this.position) {
        case 'top':
        case 'bottom':
          translationX = (shrinkRect.width - legendBBox.width) / 2;
          translationY = calculateTranslationPerpendicularDimension();
          newShrinkRect.shrink(legendBBox.height, this.position);
          break;
        case 'left':
        case 'right':
        default:
          translationX = calculateTranslationPerpendicularDimension();
          translationY = (shrinkRect.height - legendBBox.height) / 2;
          newShrinkRect.shrink(legendBBox.width, this.position);
      }
      // Round off for pixel grid alignment to work properly.
      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);
      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);
    }
    if (this.visible && this.enabled && this.data.length) {
      const legendPadding = this.spacing;
      newShrinkRect.shrink(legendPadding, this.position);
      const legendPositionedBBox = legendBBox.clone();
      legendPositionedBBox.x += this.group.translationX;
      legendPositionedBBox.y += this.group.translationY;
      this.ctx.tooltipManager.updateExclusiveRect(this.id, legendPositionedBBox);
    } else {
      this.ctx.tooltipManager.updateExclusiveRect(this.id);
    }
    return {
      shrinkRect: newShrinkRect
    };
  }
  calculateLegendDimensions(shrinkRect) {
    const {
      width,
      height
    } = shrinkRect;
    const aspectRatio = width / height;
    const maxCoefficient = 0.5;
    const minHeightCoefficient = 0.2;
    const minWidthCoefficient = 0.25;
    let legendWidth = 0;
    let legendHeight = 0;
    switch (this.position) {
      case 'top':
      case 'bottom':
        // A horizontal legend should take maximum between 20 to 50 percent of the chart height if height is larger than width
        // and maximum 20 percent of the chart height if height is smaller than width.
        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);
        break;
      case 'left':
      case 'right':
      default:
        // A vertical legend should take maximum between 25 to 50 percent of the chart width if width is larger than height
        // and maximum 25 percent of the chart width if width is smaller than height.
        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;
    }
    return [legendWidth, legendHeight];
  }
}
Legend.className = 'Legend';
legend_decorate([Validate(BOOLEAN)], Legend.prototype, "_enabled", void 0);
legend_decorate([Validate(POSITION)], Legend.prototype, "position", void 0);
legend_decorate([Validate(OPT_NUMBER(0))], Legend.prototype, "maxWidth", void 0);
legend_decorate([Validate(OPT_NUMBER(0))], Legend.prototype, "maxHeight", void 0);
legend_decorate([Validate(OPT_BOOLEAN)], Legend.prototype, "reverseOrder", void 0);
legend_decorate([Validate(OPT_ORIENTATION)], Legend.prototype, "orientation", void 0);
legend_decorate([Validate(NUMBER(0))], Legend.prototype, "spacing", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/factory/legendTypes.mjs

const LEGEND_FACTORIES = {
  category: Legend
};
function registerLegend(type, ctr) {
  if (LEGEND_FACTORIES[type]) {
    throw new Error(`AG Charts - already registered legend type: ${type}`);
  }
  LEGEND_FACTORIES[type] = ctr;
}
function getLegend(type, ctx) {
  if (LEGEND_FACTORIES[type]) {
    return new LEGEND_FACTORIES[type](ctx);
  }
  throw new Error(`AG Charts - unknown legend type: ${type}`);
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/callbackCache.mjs

class CallbackCache {
  constructor() {
    this.cache = new Map();
  }
  call(f, ...params) {
    let serialisedParams;
    let paramCache = this.cache.get(f);
    const invoke = () => {
      try {
        const result = f(...params);
        if (paramCache && serialisedParams != null) {
          paramCache.set(serialisedParams, result);
        }
        return result;
      } catch (e) {
        Logger.warnOnce(`User callback errored, ignoring`, e);
        return undefined;
      }
    };
    try {
      serialisedParams = JSON.stringify(params);
    } catch (e) {
      // Unable to serialise params!
      // No caching possible.
      return invoke();
    }
    if (paramCache == null) {
      paramCache = new Map();
      this.cache.set(f, paramCache);
    }
    if (!paramCache.has(serialisedParams)) {
      return invoke();
    }
    return paramCache.get(serialisedParams);
  }
  invalidateCache() {
    this.cache = new Map();
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chart.mjs

var chart_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var chart_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};



































class Chart extends Observable {
  constructor(document = window.document, overrideDevicePixelRatio, resources) {
    var _a;
    super();
    this.id = createId(this);
    this.processedOptions = {};
    this.userOptions = {};
    this.queuedUserOptions = [];
    this.seriesRoot = new Group({
      name: `${this.id}-Series-root`
    });
    this.extraDebugStats = {};
    this._container = undefined;
    this.data = [];
    this.padding = new Padding(20);
    this.seriesAreaPadding = new Padding(0);
    this.title = undefined;
    this.subtitle = undefined;
    this.footnote = undefined;
    this.mode = 'standalone';
    this._destroyed = false;
    this.modules = {};
    this.legendModules = {};
    this._pendingFactoryUpdates = [];
    this._performUpdateNoRenderCount = 0;
    this._performUpdateType = ChartUpdateType.NONE;
    this.seriesToUpdate = new Set();
    this.performUpdateTrigger = debouncedCallback(({
      count
    }) => chart_awaiter(this, void 0, void 0, function* () {
      if (this._destroyed) return;
      try {
        yield this.performUpdate(count);
      } catch (error) {
        this._lastPerformUpdateError = error;
        Logger.error('update error', error);
      }
    }));
    this._axes = [];
    this._series = [];
    this.applyLegendOptions = undefined;
    this.lastInteractionEvent = undefined;
    this.pointerScheduler = debouncedAnimationFrame(() => {
      if (this.lastInteractionEvent) {
        this.handlePointer(this.lastInteractionEvent);
      }
      this.lastInteractionEvent = undefined;
    });
    this.onSeriesNodeClick = event => {
      const seriesNodeClickEvent = Object.assign(Object.assign({}, event), {
        type: 'seriesNodeClick'
      });
      Object.defineProperty(seriesNodeClickEvent, 'series', {
        enumerable: false,
        // Should display the deprecation warning
        get: () => event.series
      });
      this.fireEvent(seriesNodeClickEvent);
    };
    this.onSeriesNodeDoubleClick = event => {
      const seriesNodeDoubleClick = Object.assign(Object.assign({}, event), {
        type: 'seriesNodeDoubleClick'
      });
      this.fireEvent(seriesNodeDoubleClick);
    };
    const scene = resources === null || resources === void 0 ? void 0 : resources.scene;
    const element = (_a = resources === null || resources === void 0 ? void 0 : resources.element) !== null && _a !== void 0 ? _a : document.createElement('div');
    const container = resources === null || resources === void 0 ? void 0 : resources.container;
    const root = new Group({
      name: 'root'
    });
    // Prevent the scene from rendering chart components in an invalid state
    // (before first layout is performed).
    root.visible = false;
    root.append(this.seriesRoot);
    this.axisGroup = new Group({
      name: 'Axes',
      layer: true,
      zIndex: Layers.AXIS_ZINDEX
    });
    root.appendChild(this.axisGroup);
    this.element = element;
    element.classList.add('ag-chart-wrapper');
    element.style.position = 'relative';
    this.scene = scene !== null && scene !== void 0 ? scene : new Scene({
      document,
      overrideDevicePixelRatio
    });
    this.debug = false;
    this.scene.debug.consoleLog = false;
    this.scene.root = root;
    this.scene.container = element;
    this.autoSize = true;
    this.chartEventManager = new ChartEventManager();
    this.cursorManager = new CursorManager(element);
    this.highlightManager = new HighlightManager();
    this.interactionManager = new InteractionManager(element);
    this.zoomManager = new ZoomManager();
    this.dataService = new DataService(() => this.series);
    this.layoutService = new LayoutService();
    this.updateService = new UpdateService((type = ChartUpdateType.FULL, {
      forceNodeDataRefresh
    }) => this.update(type, {
      forceNodeDataRefresh
    }));
    this.callbackCache = new CallbackCache();
    this.animationManager = new AnimationManager(this.interactionManager);
    this.animationManager.skipAnimations = true;
    this.animationManager.play();
    this.tooltip = new Tooltip(this.scene.canvas.element, document, document.body);
    this.tooltipManager = new TooltipManager(this.tooltip, this.interactionManager);
    this.overlays = new ChartOverlays(this.element);
    this.highlight = new ChartHighlight();
    this.container = container;
    SizeMonitor.observe(this.element, size => {
      var _a;
      const {
        width,
        height
      } = size;
      if (!this.autoSize) {
        return;
      }
      if (width === 0 && height === 0) {
        return;
      }
      const [autoWidth = 0, authHeight = 0] = (_a = this._lastAutoSize) !== null && _a !== void 0 ? _a : [];
      if (autoWidth === width && authHeight === height) {
        return;
      }
      this._lastAutoSize = [width, height];
      this.resize();
    });
    this.layoutService.addListener('start-layout', e => this.positionPadding(e.shrinkRect));
    this.layoutService.addListener('start-layout', e => this.positionCaptions(e.shrinkRect));
    // Add interaction listeners last so child components are registered first.
    this.interactionManager.addListener('click', event => this.onClick(event));
    this.interactionManager.addListener('dblclick', event => this.onDoubleClick(event));
    this.interactionManager.addListener('hover', event => this.onMouseMove(event));
    this.interactionManager.addListener('leave', event => this.onLeave(event));
    this.interactionManager.addListener('page-left', () => this.destroy());
    this.interactionManager.addListener('wheel', () => this.disablePointer());
    this.animationManager.addListener('animation-frame', _ => {
      this.update(ChartUpdateType.SCENE_RENDER);
    });
    this.highlightManager.addListener('highlight-change', event => this.changeHighlightDatum(event));
    this.zoomManager.addListener('zoom-change', _ => this.update(ChartUpdateType.PROCESS_DATA, {
      forceNodeDataRefresh: true
    }));
    this.attachLegend('category');
  }
  getOptions() {
    var _a;
    const {
      queuedUserOptions
    } = this;
    const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : this.userOptions;
    return jsonMerge([lastUpdateOptions]);
  }
  set container(value) {
    if (this._container !== value) {
      const {
        parentNode
      } = this.element;
      if (parentNode != null) {
        parentNode.removeChild(this.element);
      }
      if (value && !this.destroyed) {
        value.appendChild(this.element);
      }
      this._container = value;
    }
  }
  get container() {
    return this._container;
  }
  autoSizeChanged(value) {
    const {
      style
    } = this.element;
    if (value) {
      style.display = 'block';
      style.width = '100%';
      style.height = '100%';
      if (!this._lastAutoSize) {
        return;
      }
      this.resize();
    } else {
      style.display = 'inline-block';
      style.width = 'auto';
      style.height = 'auto';
    }
  }
  download(fileName, fileFormat) {
    this.scene.download(fileName, fileFormat);
  }
  get destroyed() {
    return this._destroyed;
  }
  addModule(module) {
    if (this.modules[module.optionsKey] != null) {
      throw new Error('AG Charts - module already initialised: ' + module.optionsKey);
    }
    const moduleInstance = new module.instanceConstructor(this.getModuleContext());
    this.modules[module.optionsKey] = {
      instance: moduleInstance
    };
    this[module.optionsKey] = moduleInstance;
  }
  removeModule(module) {
    var _a, _b;
    (_b = (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.destroy();
    delete this.modules[module.optionsKey];
    delete this[module.optionsKey];
  }
  isModuleEnabled(module) {
    return this.modules[module.optionsKey] != null;
  }
  getModuleContext() {
    const {
      scene,
      animationManager,
      chartEventManager,
      cursorManager,
      highlightManager,
      interactionManager,
      tooltipManager,
      zoomManager,
      dataService,
      layoutService,
      updateService,
      mode,
      callbackCache
    } = this;
    return {
      scene,
      animationManager,
      chartEventManager,
      cursorManager,
      highlightManager,
      interactionManager,
      tooltipManager,
      zoomManager,
      dataService,
      layoutService,
      updateService,
      mode,
      callbackCache
    };
  }
  destroy(opts) {
    var _a;
    if (this._destroyed) {
      return;
    }
    const keepTransferableResources = opts === null || opts === void 0 ? void 0 : opts.keepTransferableResources;
    let result = undefined;
    this._performUpdateType = ChartUpdateType.NONE;
    this._pendingFactoryUpdates.splice(0);
    this.tooltipManager.destroy();
    this.tooltip.destroy();
    (_a = this.legend) === null || _a === void 0 ? void 0 : _a.destroy();
    this.overlays.noData.hide();
    SizeMonitor.unobserve(this.element);
    for (const [key, module] of Object.entries(this.modules)) {
      module.instance.destroy();
      delete this.modules[key];
      delete this[key];
    }
    this.interactionManager.destroy();
    if (keepTransferableResources) {
      this.scene.strip();
      result = {
        container: this.container,
        scene: this.scene,
        element: this.element
      };
    } else {
      this.scene.destroy();
      this.container = undefined;
    }
    this.series.forEach(s => s.destroy());
    this.series = [];
    this.axes.forEach(a => a.destroy());
    this.axes = [];
    this.callbackCache.invalidateCache();
    this._destroyed = true;
    return result;
  }
  log(opts) {
    if (this.debug) {
      Logger.debug(opts);
    }
  }
  disablePointer(highlightOnly = false) {
    if (!highlightOnly) {
      this.tooltipManager.removeTooltip(this.id);
    }
    this.highlightManager.updateHighlight(this.id);
    if (this.lastInteractionEvent) {
      this.lastInteractionEvent = undefined;
    }
  }
  requestFactoryUpdate(cb) {
    const callbacks = this._pendingFactoryUpdates;
    const count = callbacks.length;
    if (count === 0) {
      callbacks.push(cb);
      this._processCallbacks().catch(e => Logger.errorOnce(e));
    } else {
      // Factory callback process already running, the callback will be invoked asynchronously.
      // Clear the queue after the first callback to prevent unnecessary re-renderings.
      callbacks.splice(1, count - 1, cb);
    }
  }
  _processCallbacks() {
    return chart_awaiter(this, void 0, void 0, function* () {
      const callbacks = this._pendingFactoryUpdates;
      while (callbacks.length > 0) {
        if (this.updatePending) {
          yield sleep(1);
          continue; // Make sure to check queue has an item before continuing.
        }

        try {
          yield callbacks[0]();
          this.callbackCache.invalidateCache();
        } catch (e) {
          Logger.error('update error', e);
        }
        callbacks.shift();
      }
    });
  }
  get performUpdateType() {
    return this._performUpdateType;
  }
  get updatePending() {
    return this._performUpdateType !== ChartUpdateType.NONE || this.lastInteractionEvent != null;
  }
  get lastPerformUpdateError() {
    return this._lastPerformUpdateError;
  }
  awaitUpdateCompletion() {
    return chart_awaiter(this, void 0, void 0, function* () {
      yield this.performUpdateTrigger.await();
    });
  }
  update(type = ChartUpdateType.FULL, opts) {
    const {
      forceNodeDataRefresh = false,
      seriesToUpdate = this.series
    } = opts !== null && opts !== void 0 ? opts : {};
    if (forceNodeDataRefresh) {
      this.series.forEach(series => series.markNodeDataDirty());
    }
    for (const series of seriesToUpdate) {
      this.seriesToUpdate.add(series);
    }
    if (type < this._performUpdateType) {
      this._performUpdateType = type;
      this.performUpdateTrigger.schedule();
    }
  }
  performUpdate(count) {
    var _a;
    return chart_awaiter(this, void 0, void 0, function* () {
      const {
        _performUpdateType: performUpdateType,
        extraDebugStats
      } = this;
      const splits = [performance.now()];
      switch (performUpdateType) {
        case ChartUpdateType.FULL:
        case ChartUpdateType.PROCESS_DATA:
          yield this.processData();
          this.disablePointer(true);
          splits.push(performance.now());
        // eslint-disable-next-line no-fallthrough
        case ChartUpdateType.PERFORM_LAYOUT:
          if (this.autoSize && !this._lastAutoSize) {
            const count = this._performUpdateNoRenderCount++;
            if (count < 5) {
              // Reschedule if canvas size hasn't been set yet to avoid a race.
              this._performUpdateType = ChartUpdateType.PERFORM_LAYOUT;
              this.performUpdateTrigger.schedule();
              break;
            }
            // After several failed passes, continue and accept there maybe a redundant
            // render. Sometimes this case happens when we already have the correct
            // width/height, and we end up never rendering the chart in that scenario.
          }

          this._performUpdateNoRenderCount = 0;
          yield this.performLayout();
          this.handleOverlays();
          splits.push(performance.now());
        // eslint-disable-next-line no-fallthrough
        case ChartUpdateType.SERIES_UPDATE:
          const {
            seriesRect
          } = this;
          const seriesUpdates = [...this.seriesToUpdate].map(series => series.update({
            seriesRect
          }));
          this.seriesToUpdate.clear();
          yield Promise.all(seriesUpdates);
          splits.push(performance.now());
        // eslint-disable-next-line no-fallthrough
        case ChartUpdateType.TOOLTIP_RECALCULATION:
          const tooltipMeta = this.tooltipManager.getTooltipMeta(this.id);
          if (performUpdateType < ChartUpdateType.SERIES_UPDATE && ((_a = tooltipMeta === null || tooltipMeta === void 0 ? void 0 : tooltipMeta.event) === null || _a === void 0 ? void 0 : _a.type) === 'hover') {
            this.handlePointer(tooltipMeta.event);
          }
        // eslint-disable-next-line no-fallthrough
        case ChartUpdateType.SCENE_RENDER:
          yield this.scene.render({
            debugSplitTimes: splits,
            extraDebugStats
          });
          this.extraDebugStats = {};
        // eslint-disable-next-line no-fallthrough
        case ChartUpdateType.NONE:
          // Do nothing.
          this._performUpdateType = ChartUpdateType.NONE;
      }
      const end = performance.now();
      this.log({
        chart: this,
        durationMs: Math.round((end - splits[0]) * 100) / 100,
        count,
        performUpdateType: ChartUpdateType[performUpdateType]
      });
    });
  }
  set axes(values) {
    const removedAxes = new Set();
    this._axes.forEach(axis => {
      axis.detachAxis(this.axisGroup);
      removedAxes.add(axis);
    });
    // make linked axes go after the regular ones (simulates stable sort by `linkedTo` property)
    this._axes = values.filter(a => !a.linkedTo).concat(values.filter(a => a.linkedTo));
    this._axes.forEach(axis => {
      axis.attachAxis(this.axisGroup);
      removedAxes.delete(axis);
    });
    removedAxes.forEach(axis => axis.destroy());
  }
  get axes() {
    return this._axes;
  }
  set series(values) {
    this.removeAllSeries();
    values.forEach(series => this.addSeries(series));
  }
  get series() {
    return this._series;
  }
  addSeries(series, before) {
    const {
      series: allSeries,
      seriesRoot
    } = this;
    const canAdd = allSeries.indexOf(series) < 0;
    if (canAdd) {
      const beforeIndex = before ? allSeries.indexOf(before) : -1;
      if (beforeIndex >= 0) {
        allSeries.splice(beforeIndex, 0, series);
        seriesRoot.insertBefore(series.rootGroup, before.rootGroup);
      } else {
        allSeries.push(series);
        seriesRoot.append(series.rootGroup);
      }
      this.initSeries(series);
      return true;
    }
    return false;
  }
  initSeries(series) {
    series.chart = this;
    series.highlightManager = this.highlightManager;
    series.animationManager = this.animationManager;
    if (!series.data) {
      series.data = this.data;
    }
    this.addSeriesListeners(series);
    series.chartEventManager = this.chartEventManager;
    series.addChartEventListeners();
  }
  freeSeries(series) {
    series.chart = undefined;
    series.removeEventListener('nodeClick', this.onSeriesNodeClick);
    series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);
  }
  removeAllSeries() {
    this.series.forEach(series => {
      this.freeSeries(series);
      this.seriesRoot.removeChild(series.rootGroup);
    });
    this._series = []; // using `_series` instead of `series` to prevent infinite recursion
  }

  addSeriesListeners(series) {
    if (this.hasEventListener('seriesNodeClick')) {
      series.addEventListener('nodeClick', this.onSeriesNodeClick);
    }
    if (this.hasEventListener('seriesNodeDoubleClick')) {
      series.addEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);
    }
  }
  updateAllSeriesListeners() {
    this.series.forEach(series => {
      series.removeEventListener('nodeClick', this.onSeriesNodeClick);
      series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);
      this.addSeriesListeners(series);
    });
  }
  assignSeriesToAxes() {
    this.axes.forEach(axis => {
      axis.boundSeries = this.series.filter(s => {
        const seriesAxis = axis.direction === ChartAxisDirection.X ? s.xAxis : s.yAxis;
        return seriesAxis === axis;
      });
    });
  }
  assignAxesToSeries(force = false) {
    // This method has to run before `assignSeriesToAxes`.
    const directionToAxesMap = {};
    this.axes.forEach(axis => {
      var _a;
      const direction = axis.direction;
      const directionAxes = (_a = directionToAxesMap[direction]) !== null && _a !== void 0 ? _a : directionToAxesMap[direction] = [];
      directionAxes.push(axis);
    });
    this.series.forEach(series => {
      series.directions.forEach(direction => {
        const currentAxis = direction === ChartAxisDirection.X ? series.xAxis : series.yAxis;
        if (currentAxis && !force) {
          return;
        }
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger.warn(`no available axis for direction [${direction}]; check series and axes configuration.`);
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = this.findMatchingAxis(directionAxes, series.getKeys(direction));
        if (!newAxis) {
          Logger.warn(`no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`);
          return;
        }
        if (direction === ChartAxisDirection.X) {
          series.xAxis = newAxis;
        } else {
          series.yAxis = newAxis;
        }
      });
    });
  }
  findMatchingAxis(directionAxes, directionKeys) {
    for (const axis of directionAxes) {
      const axisKeys = axis.keys;
      if (!axisKeys.length) {
        return axis;
      }
      if (!directionKeys) {
        continue;
      }
      for (const directionKey of directionKeys) {
        if (axisKeys.indexOf(directionKey) >= 0) {
          return axis;
        }
      }
    }
  }
  resize(width, height) {
    var _a, _b, _c, _d;
    width !== null && width !== void 0 ? width : width = (_a = this.width) !== null && _a !== void 0 ? _a : this.autoSize ? (_b = this._lastAutoSize) === null || _b === void 0 ? void 0 : _b[0] : this.scene.canvas.width;
    height !== null && height !== void 0 ? height : height = (_c = this.height) !== null && _c !== void 0 ? _c : this.autoSize ? (_d = this._lastAutoSize) === null || _d === void 0 ? void 0 : _d[1] : this.scene.canvas.height;
    if (!width || !height || !Number.isFinite(width) || !Number.isFinite(height)) return;
    if (this.scene.resize(width, height)) {
      this.disablePointer();
      this.update(ChartUpdateType.PERFORM_LAYOUT, {
        forceNodeDataRefresh: true
      });
    }
  }
  processData() {
    return chart_awaiter(this, void 0, void 0, function* () {
      if (this.axes.length > 0 || this.series.some(s => s instanceof CartesianSeries)) {
        this.assignAxesToSeries(true);
        this.assignSeriesToAxes();
      }
      yield Promise.all(this.series.map(s => s.processData()));
      yield this.updateLegend();
    });
  }
  placeLabels() {
    const visibleSeries = [];
    const data = [];
    for (const series of this.series) {
      if (!series.visible) {
        continue;
      }
      const labelData = series.getLabelData();
      if (!(labelData && isPointLabelDatum(labelData[0]))) {
        continue;
      }
      data.push(labelData);
      visibleSeries.push(series);
    }
    const {
      seriesRect
    } = this;
    const labels = seriesRect && data.length > 0 ? placeLabels(data, {
      x: 0,
      y: 0,
      width: seriesRect.width,
      height: seriesRect.height
    }) : [];
    return new Map(labels.map((l, i) => [visibleSeries[i], l]));
  }
  attachLegend(legendType) {
    var _a;
    if (this.legendType === legendType) {
      return;
    }
    (_a = this.legend) === null || _a === void 0 ? void 0 : _a.destroy();
    this.legend = undefined;
    const ctx = this.getModuleContext();
    this.legend = getLegend(legendType, ctx);
    this.legend.attachLegend(this.scene.root);
    this.legendType = legendType;
  }
  setLegendInit(initLegend) {
    this.applyLegendOptions = initLegend;
  }
  updateLegend() {
    var _a;
    return chart_awaiter(this, void 0, void 0, function* () {
      const legendData = [];
      this.series.filter(s => s.showInLegend).forEach(series => {
        const data = series.getLegendData();
        legendData.push(...data);
      });
      const legendType = legendData.length > 0 ? legendData[0].legendType : 'category';
      this.attachLegend(legendType);
      (_a = this.applyLegendOptions) === null || _a === void 0 ? void 0 : _a.call(this, this.legend);
      if (legendType === 'category') {
        this.validateLegendData(legendData);
      }
      this.legend.data = legendData;
    });
  }
  validateLegendData(legendData) {
    // Validate each series that shares a legend item label uses the same fill colour
    const labelMarkerFills = {};
    legendData.forEach(d => {
      var _a, _b, _c;
      var _d, _e;
      const seriesType = (_a = this.series.find(s => s.id === d.seriesId)) === null || _a === void 0 ? void 0 : _a.type;
      if (!seriesType) return;
      const dc = d;
      (_b = labelMarkerFills[seriesType]) !== null && _b !== void 0 ? _b : labelMarkerFills[seriesType] = {
        [dc.label.text]: new Set()
      };
      (_c = (_d = labelMarkerFills[seriesType])[_e = dc.label.text]) !== null && _c !== void 0 ? _c : _d[_e] = new Set();
      if (dc.marker.fill != null) {
        labelMarkerFills[seriesType][dc.label.text].add(dc.marker.fill);
      }
    });
    Object.keys(labelMarkerFills).forEach(seriesType => {
      Object.keys(labelMarkerFills[seriesType]).forEach(name => {
        const fills = labelMarkerFills[seriesType][name];
        if (fills.size > 1) {
          Logger.warnOnce(`legend item '${name}' has multiple fill colors, this may cause unexpected behaviour.`);
        }
      });
    });
  }
  performLayout() {
    return chart_awaiter(this, void 0, void 0, function* () {
      this.scene.root.visible = true;
      const {
        scene: {
          width,
          height
        }
      } = this;
      let shrinkRect = new BBox(0, 0, width, height);
      ({
        shrinkRect
      } = this.layoutService.dispatchPerformLayout('start-layout', {
        shrinkRect
      }));
      ({
        shrinkRect
      } = this.layoutService.dispatchPerformLayout('before-series', {
        shrinkRect
      }));
      return shrinkRect;
    });
  }
  positionPadding(shrinkRect) {
    const {
      padding
    } = this;
    shrinkRect.shrink(padding.left, 'left');
    shrinkRect.shrink(padding.top, 'top');
    shrinkRect.shrink(padding.right, 'right');
    shrinkRect.shrink(padding.bottom, 'bottom');
    return {
      shrinkRect
    };
  }
  positionCaptions(shrinkRect) {
    var _a;
    const {
      title,
      subtitle,
      footnote
    } = this;
    const newShrinkRect = shrinkRect.clone();
    const updateCaption = caption => {
      var _a;
      const defaultCaptionHeight = shrinkRect.height / 10;
      const captionLineHeight = (_a = caption.lineHeight) !== null && _a !== void 0 ? _a : caption.fontSize * Text.defaultLineHeightRatio;
      const maxWidth = shrinkRect.width;
      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);
      caption.computeTextWrap(maxWidth, maxHeight);
    };
    const positionTopAndShrinkBBox = caption => {
      var _a;
      const baseY = newShrinkRect.y;
      caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;
      caption.node.y = baseY;
      caption.node.textBaseline = 'top';
      updateCaption(caption);
      const bbox = caption.node.computeBBox();
      // As the bbox (x,y) ends up at a different location than specified above, we need to
      // take it into consideration when calculating how much space needs to be reserved to
      // accommodate the caption.
      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + ((_a = caption.spacing) !== null && _a !== void 0 ? _a : 0));
      newShrinkRect.shrink(bboxHeight, 'top');
    };
    const positionBottomAndShrinkBBox = caption => {
      var _a;
      const baseY = newShrinkRect.y + newShrinkRect.height;
      caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;
      caption.node.y = baseY;
      caption.node.textBaseline = 'bottom';
      updateCaption(caption);
      const bbox = caption.node.computeBBox();
      const bboxHeight = Math.ceil(baseY - bbox.y + ((_a = caption.spacing) !== null && _a !== void 0 ? _a : 0));
      newShrinkRect.shrink(bboxHeight, 'bottom');
    };
    if (title) {
      title.node.visible = title.enabled;
      if (title.node.visible) {
        positionTopAndShrinkBBox(title);
      }
    }
    if (subtitle) {
      subtitle.node.visible = (_a = (title === null || title === void 0 ? void 0 : title.enabled) && subtitle.enabled) !== null && _a !== void 0 ? _a : false;
      if (subtitle.node.visible) {
        positionTopAndShrinkBBox(subtitle);
      }
    }
    if (footnote) {
      footnote.node.visible = footnote.enabled;
      if (footnote.node.visible) {
        positionBottomAndShrinkBBox(footnote);
      }
    }
    return {
      shrinkRect: newShrinkRect
    };
  }
  getSeriesRect() {
    return this.seriesRect;
  }
  // x/y are local canvas coordinates in CSS pixels, not actual pixels
  pickSeriesNode(point, exactMatchOnly, maxDistance) {
    var _a, _b;
    const start = performance.now();
    // Disable 'nearest match' options if looking for exact matches only
    const pickModes = exactMatchOnly ? [SeriesNodePickMode.EXACT_SHAPE_MATCH] : undefined;
    // Iterate through series in reverse, as later declared series appears on top of earlier
    // declared series.
    const reverseSeries = [...this.series].reverse();
    let result = undefined;
    for (const series of reverseSeries) {
      if (!series.visible || !series.rootGroup.visible) {
        continue;
      }
      const {
        match,
        distance
      } = (_a = series.pickNode(point, pickModes)) !== null && _a !== void 0 ? _a : {};
      if (!match || distance == null) {
        continue;
      }
      if ((!result || result.distance > distance) && distance <= (maxDistance !== null && maxDistance !== void 0 ? maxDistance : Infinity)) {
        result = {
          series,
          distance,
          datum: match
        };
      }
      if (distance === 0) {
        break;
      }
    }
    this.extraDebugStats['pickSeriesNode'] = Math.round(((_b = this.extraDebugStats['pickSeriesNode']) !== null && _b !== void 0 ? _b : 0) + (performance.now() - start));
    return result;
  }
  onMouseMove(event) {
    this.lastInteractionEvent = event;
    this.pointerScheduler.schedule();
    this.extraDebugStats['mouseX'] = event.offsetX;
    this.extraDebugStats['mouseY'] = event.offsetY;
    this.update(ChartUpdateType.SCENE_RENDER);
  }
  onLeave(event) {
    if (this.tooltip.pointerLeftOntoTooltip(event)) {
      return;
    }
    this.disablePointer();
  }
  handlePointer(event) {
    const {
      lastPick,
      hoverRect
    } = this;
    const {
      offsetX,
      offsetY
    } = event;
    const disablePointer = (highlightOnly = false) => {
      if (lastPick) {
        // Cursor moved from a non-marker node to empty space.
        this.disablePointer(highlightOnly);
      }
    };
    if (!(hoverRect === null || hoverRect === void 0 ? void 0 : hoverRect.containsPoint(offsetX, offsetY))) {
      disablePointer();
      return;
    }
    // Handle node highlighting and tooltip toggling when pointer within `tooltip.range`
    this.handlePointerTooltip(event, disablePointer);
    // Handle node highlighting and mouse cursor when pointer withing `series[].nodeClickRange`
    this.handlePointerNode(event);
  }
  handlePointerTooltip(event, disablePointer) {
    var _a, _b;
    const {
      lastPick,
      tooltip
    } = this;
    const {
      range
    } = tooltip;
    const {
      pageX,
      pageY,
      offsetX,
      offsetY
    } = event;
    let pixelRange;
    if (typeof range === 'number' && Number.isFinite(range)) {
      pixelRange = range;
    }
    const pick = this.pickSeriesNode({
      x: offsetX,
      y: offsetY
    }, range === 'exact', pixelRange);
    if (!pick) {
      this.tooltipManager.updateTooltip(this.id);
      if (this.highlight.range === 'tooltip') disablePointer(true);
      return;
    }
    const isNewDatum = this.highlight.range === 'node' || !lastPick || lastPick.datum !== pick.datum;
    let html;
    if (isNewDatum) {
      html = pick.series.getTooltipHtml(pick.datum);
      if (this.highlight.range === 'tooltip') {
        this.highlightManager.updateHighlight(this.id, pick.datum);
      }
    } else if (lastPick) {
      lastPick.event = event.sourceEvent;
    }
    const isPixelRange = pixelRange != null;
    const tooltipEnabled = this.tooltip.enabled && pick.series.tooltip.enabled;
    const exactlyMatched = range === 'exact' && pick.distance === 0;
    const rangeMatched = range === 'nearest' || isPixelRange || exactlyMatched;
    const shouldUpdateTooltip = tooltipEnabled && rangeMatched && (!isNewDatum || html !== undefined);
    const position = {
      xOffset: pick.datum.series.tooltip.position.xOffset,
      yOffset: pick.datum.series.tooltip.position.yOffset
    };
    const meta = this.mergePointerDatum({
      pageX,
      pageY,
      offsetX,
      offsetY,
      event: event,
      showArrow: pick.series.tooltip.showArrow,
      position
    }, pick.datum);
    meta.enableInteraction = (_b = (_a = pick.series.tooltip.interaction) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : false;
    if (shouldUpdateTooltip) {
      this.tooltipManager.updateTooltip(this.id, meta, html);
    }
  }
  handlePointerNode(event) {
    const found = this.checkSeriesNodeRange(event, (series, datum) => {
      if (series.hasEventListener('nodeClick') || series.hasEventListener('nodeDoubleClick')) {
        this.cursorManager.updateCursor('chart', 'pointer');
      }
      if (this.highlight.range === 'node') {
        this.highlightManager.updateHighlight(this.id, datum);
      }
    });
    if (!found) {
      this.cursorManager.updateCursor('chart');
      if (this.highlight.range === 'node') {
        this.highlightManager.updateHighlight(this.id);
      }
    }
  }
  onClick(event) {
    if (this.checkSeriesNodeClick(event)) {
      this.update(ChartUpdateType.SERIES_UPDATE);
      return;
    }
    this.fireEvent({
      type: 'click',
      event: event.sourceEvent
    });
  }
  onDoubleClick(event) {
    if (this.checkSeriesNodeDoubleClick(event)) {
      this.update(ChartUpdateType.SERIES_UPDATE);
      return;
    }
    this.fireEvent({
      type: 'doubleClick',
      event: event.sourceEvent
    });
  }
  checkSeriesNodeClick(event) {
    return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));
  }
  checkSeriesNodeDoubleClick(event) {
    return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum));
  }
  checkSeriesNodeRange(event, callback) {
    const nearestNode = this.pickSeriesNode({
      x: event.offsetX,
      y: event.offsetY
    }, false);
    const datum = nearestNode === null || nearestNode === void 0 ? void 0 : nearestNode.datum;
    const nodeClickRange = datum === null || datum === void 0 ? void 0 : datum.series.nodeClickRange;
    // First check if we should trigger the callback based on nearest node
    if (datum && nodeClickRange === 'nearest') {
      callback(datum.series, datum);
      return true;
    }
    // Then check for an exact match or within the given range
    let pixelRange;
    if (typeof nodeClickRange === 'number' && Number.isFinite(nodeClickRange)) {
      pixelRange = nodeClickRange;
    }
    const pick = this.pickSeriesNode({
      x: event.offsetX,
      y: event.offsetY
    }, nodeClickRange === 'exact', pixelRange);
    if (!pick) return false;
    // Then if we've picked a node within the pixel range, or exactly, trigger the callback
    const isPixelRange = pixelRange != null;
    const exactlyMatched = nodeClickRange === 'exact' && pick.distance === 0;
    if (isPixelRange || exactlyMatched) {
      callback(pick.series, pick.datum);
      return true;
    }
    return false;
  }
  mergePointerDatum(meta, datum) {
    const {
      type
    } = datum.series.tooltip.position;
    if (type === 'node' && datum.nodeMidPoint) {
      const {
        x,
        y
      } = datum.nodeMidPoint;
      const {
        canvas
      } = this.scene;
      const point = datum.series.rootGroup.inverseTransformPoint(x, y);
      const canvasRect = canvas.element.getBoundingClientRect();
      return Object.assign(Object.assign({}, meta), {
        pageX: Math.round(canvasRect.left + window.scrollX + point.x),
        pageY: Math.round(canvasRect.top + window.scrollY + point.y),
        offsetX: Math.round(point.x),
        offsetY: Math.round(point.y)
      });
    }
    return meta;
  }
  changeHighlightDatum(event) {
    var _a, _b;
    const seriesToUpdate = new Set();
    const {
      series: newSeries = undefined,
      datum: newDatum
    } = (_a = event.currentHighlight) !== null && _a !== void 0 ? _a : {};
    const {
      series: lastSeries = undefined,
      datum: lastDatum
    } = (_b = event.previousHighlight) !== null && _b !== void 0 ? _b : {};
    if (lastSeries) {
      seriesToUpdate.add(lastSeries);
    }
    if (newSeries) {
      seriesToUpdate.add(newSeries);
    }
    // Adjust cursor if a specific datum is highlighted, rather than just a series.
    if ((lastSeries === null || lastSeries === void 0 ? void 0 : lastSeries.cursor) && lastDatum) {
      this.cursorManager.updateCursor(lastSeries.id);
    }
    if ((newSeries === null || newSeries === void 0 ? void 0 : newSeries.cursor) && newDatum) {
      this.cursorManager.updateCursor(newSeries.id, newSeries.cursor);
    }
    this.lastPick = event.currentHighlight ? {
      datum: event.currentHighlight
    } : undefined;
    const updateAll = newSeries == null || lastSeries == null;
    if (updateAll) {
      this.update(ChartUpdateType.SERIES_UPDATE);
    } else {
      this.update(ChartUpdateType.SERIES_UPDATE, {
        seriesToUpdate
      });
    }
  }
  waitForUpdate(timeoutMs = 5000) {
    return chart_awaiter(this, void 0, void 0, function* () {
      const start = performance.now();
      while (this._pendingFactoryUpdates.length > 0 || this.updatePending) {
        if (performance.now() - start > timeoutMs) {
          throw new Error('waitForUpdate() timeout reached.');
        }
        yield sleep(5);
      }
      yield this.awaitUpdateCompletion();
    });
  }
  handleOverlays() {
    this.handleNoDataOverlay();
  }
  handleNoDataOverlay() {
    const shouldDisplayNoDataOverlay = !this.series.some(s => s.hasData());
    const rect = this.getSeriesRect();
    if (shouldDisplayNoDataOverlay && rect) {
      this.overlays.noData.show(rect);
    } else {
      this.overlays.noData.hide();
    }
  }
}
chart_decorate([ActionOnSet({
  newValue(value) {
    this.scene.debug.consoleLog = value;
  }
})], Chart.prototype, "debug", void 0);
chart_decorate([ActionOnSet({
  newValue(value) {
    var _a;
    (_a = this.series) === null || _a === void 0 ? void 0 : _a.forEach(series => series.data = value);
  }
})], Chart.prototype, "data", void 0);
chart_decorate([ActionOnSet({
  newValue(value) {
    this.resize(value);
  }
})], Chart.prototype, "width", void 0);
chart_decorate([ActionOnSet({
  newValue(value) {
    this.resize(undefined, value);
  }
})], Chart.prototype, "height", void 0);
chart_decorate([ActionOnSet({
  changeValue(value) {
    this.autoSizeChanged(value);
  }
}), Validate(BOOLEAN)], Chart.prototype, "autoSize", void 0);
chart_decorate([ActionOnSet({
  newValue(value) {
    var _a;
    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);
  },
  oldValue(oldValue) {
    var _a;
    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);
  }
})], Chart.prototype, "title", void 0);
chart_decorate([ActionOnSet({
  newValue(value) {
    var _a;
    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);
  },
  oldValue(oldValue) {
    var _a;
    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);
  }
})], Chart.prototype, "subtitle", void 0);
chart_decorate([ActionOnSet({
  newValue(value) {
    var _a;
    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);
  },
  oldValue(oldValue) {
    var _a;
    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);
  }
})], Chart.prototype, "footnote", void 0);
chart_decorate([Validate(STRING_UNION('standalone', 'integrated'))], Chart.prototype, "mode", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/layout/tree.mjs

/**
 * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)
 * and the tree grows downward from the root.
 */
class TreeNode {
  constructor(label = '', parent, number = 0) {
    this.x = 0;
    this.y = 0;
    this.subtreeLeft = NaN;
    this.subtreeRight = NaN;
    this.screenX = 0;
    this.screenY = 0;
    this.children = [];
    this.leafCount = 0;
    this.prelim = 0;
    this.mod = 0;
    this.ancestor = this;
    this.change = 0;
    this.shift = 0;
    this.label = label;
    // screenX and screenY are meant to be recomputed from (layout) x and y
    // when the tree is resized (without performing another layout)
    this.parent = parent;
    this.depth = parent ? parent.depth + 1 : 0;
    this.number = number;
  }
  getLeftSibling() {
    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;
  }
  getLeftmostSibling() {
    return this.number > 0 && this.parent ? this.parent.children[0] : undefined;
  }
  // traverse the left contour of a subtree, return the successor of v on this contour
  nextLeft() {
    return this.children ? this.children[0] : this.thread;
  }
  // traverse the right contour of a subtree, return the successor of v on this contour
  nextRight() {
    return this.children ? this.children[this.children.length - 1] : this.thread;
  }
  getSiblings() {
    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];
  }
}
/**
 * Converts an array of ticks, where each tick has an array of labels, to a label tree.
 * If `pad` is `true`, will ensure that every branch matches the depth of the tree by
 * creating empty labels.
 */
function ticksToTree(ticks, pad = true) {
  const root = new TreeNode();
  let depth = 0;
  if (pad) {
    ticks.forEach(tick => depth = Math.max(depth, tick.labels.length));
  }
  ticks.forEach(tick => {
    if (pad) {
      while (tick.labels.length < depth) {
        tick.labels.unshift('');
      }
    }
    insertTick(root, tick);
  });
  return root;
}
function insertTick(root, tick) {
  const pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label
  const lastPartIndex = pathParts.length - 1;
  pathParts.forEach((pathPart, partIndex) => {
    const children = root.children;
    const existingNode = children.find(child => child.label === pathPart);
    const isNotLeaf = partIndex !== lastPartIndex;
    if (existingNode && isNotLeaf) {
      // the isNotLeaf check is to allow duplicate leafs
      root = existingNode;
    } else {
      const node = new TreeNode(pathPart, root);
      node.number = children.length;
      children.push(node);
      if (isNotLeaf) {
        root = node;
      }
    }
  });
}
// Shift the subtree.
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.number - wm.number;
  const ratio = shift / subtrees;
  wp.change -= ratio;
  wp.shift += shift;
  wm.change += ratio;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
// Spaces out the children.
function executeShifts(v) {
  const children = v.children;
  if (children) {
    let shift = 0;
    let change = 0;
    for (let i = children.length - 1; i >= 0; i--) {
      const w = children[i];
      w.prelim += shift;
      w.mod += shift;
      change += w.change;
      shift += w.shift + change;
    }
  }
}
// Moves current subtree with v as the root if some nodes are conflicting in space.
function apportion(v, defaultAncestor, distance) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + distance;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.thread = vim.nextRight();
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.thread = vip.nextLeft();
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
// Compute the preliminary x-coordinate of node and its children (recursively).
function firstWalk(node, distance) {
  const children = node.children;
  if (children.length) {
    let defaultAncestor = children[0];
    children.forEach(child => {
      firstWalk(child, distance);
      defaultAncestor = apportion(child, defaultAncestor, distance);
    });
    executeShifts(node);
    const midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + distance;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + distance : 0;
  }
}
class Dimensions {
  constructor() {
    this.top = Infinity;
    this.right = -Infinity;
    this.bottom = -Infinity;
    this.left = Infinity;
  }
  update(node, xy) {
    const {
      x,
      y
    } = xy(node);
    if (x > this.right) {
      this.right = x;
    }
    if (x < this.left) {
      this.left = x;
    }
    if (y > this.bottom) {
      this.bottom = y;
    }
    if (y < this.top) {
      this.top = y;
    }
  }
}
function secondWalk(v, m, layout) {
  v.x = v.prelim + m;
  v.y = v.depth;
  layout.update(v);
  v.children.forEach(w => secondWalk(w, m + v.mod, layout));
}
// After the second walk the parent nodes are positioned at the center of their immediate children.
// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,
// we need a third walk to adjust the positions.
function thirdWalk(v) {
  const children = v.children;
  let leafCount = 0;
  children.forEach(w => {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  });
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[v.children.length - 1].subtreeRight;
    v.x = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.x;
    v.subtreeRight = v.x;
  }
}
function treeLayout(root) {
  const layout = new TreeLayout();
  firstWalk(root, 1);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
class TreeLayout {
  constructor() {
    this.dimensions = new Dimensions();
    this.leafCount = 0;
    this.nodes = [];
    // One might want to process leaf nodes separately from the rest of the tree.
    // For example, position labels corresponding to leafs vertically, rather than horizontally.
    this.leafNodes = [];
    this.nonLeafNodes = [];
    this.depth = 0;
  }
  update(node) {
    this.dimensions.update(node, node => ({
      x: node.x,
      y: node.y
    }));
    if (!node.children.length) {
      this.leafCount++;
      this.leafNodes.push(node);
    } else {
      this.nonLeafNodes.push(node);
    }
    if (node.depth > this.depth) {
      this.depth = node.depth;
    }
    this.nodes.push(node);
  }
  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {
    const xSteps = this.leafCount - 1;
    const ySteps = this.depth;
    const dimensions = this.dimensions;
    let scalingX = 1;
    let scalingY = 1;
    if (width > 0 && xSteps) {
      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;
      const desiredSpacingX = width / xSteps;
      scalingX = desiredSpacingX / existingSpacingX;
      if (flipX) {
        scalingX = -scalingX;
      }
    }
    if (height > 0 && ySteps) {
      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;
      const desiredSpacingY = height / ySteps;
      scalingY = desiredSpacingY / existingSpacingY;
    }
    const screenDimensions = new Dimensions();
    this.nodes.forEach(node => {
      node.screenX = node.x * scalingX;
      node.screenY = node.y * scalingY;
      screenDimensions.update(node, node => ({
        x: node.screenX,
        y: node.screenY
      }));
    });
    // Normalize so that root top and leftmost leaf left start at zero.
    const offsetX = -screenDimensions.left;
    const offsetY = -screenDimensions.top;
    this.nodes.forEach(node => {
      node.screenX += offsetX + shiftX;
      node.screenY += offsetY + shiftY;
    });
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/axis/groupedCategoryAxis.mjs

var groupedCategoryAxis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};












class GroupedCategoryAxisLabel extends AxisLabel {
  constructor() {
    super(...arguments);
    this.grid = false;
  }
}
groupedCategoryAxis_decorate([Validate(BOOLEAN)], GroupedCategoryAxisLabel.prototype, "grid", void 0);
class GroupedCategoryAxis extends ChartAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale());
    // Label scale (labels are positioned between ticks, tick count = label count + 1).
    // We don't call is `labelScale` for consistency with other axes.
    this.tickScale = new BandScale();
    this.translation = {
      x: 0,
      y: 0
    };
    this.line = new AxisLine();
    this.label = new GroupedCategoryAxisLabel();
    /**
     * The color of the labels.
     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.
     */
    this.labelColor = 'rgba(87, 87, 87, 1)';
    this.includeInvisibleDomains = true;
    const {
      tickLineGroup,
      tickLabelGroup,
      gridLineGroup,
      tickScale,
      scale
    } = this;
    scale.paddingOuter = 0.1;
    scale.paddingInner = scale.paddingOuter * 2;
    this.range = scale.range.slice();
    this.refreshScale();
    tickScale.paddingInner = 1;
    tickScale.paddingOuter = 0;
    this.gridLineSelection = Selection.select(gridLineGroup, Line);
    this.axisLineSelection = Selection.select(tickLineGroup, Line);
    this.separatorSelection = Selection.select(tickLineGroup, Line);
    this.labelSelection = Selection.select(tickLabelGroup, Text);
  }
  updateRange() {
    const {
      range: rr,
      visibleRange: vr,
      scale
    } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start = rr[0] - shift;
    this.tickScale.range = scale.range = [start, start + span];
    this.resizeTickTree();
  }
  resizeTickTree() {
    var _a;
    const s = this.scale;
    const range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;
    const layout = this.tickTreeLayout;
    const lineHeight = this.lineHeight;
    if (layout) {
      layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + ((_a = s.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);
    }
  }
  get lineHeight() {
    return this.label.fontSize * 1.5;
  }
  /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */
  set gridLength(value) {
    // Was visible and now invisible, or was invisible and now visible.
    if (this._gridLength && !value || !this._gridLength && value) {
      this.gridLineSelection.clear();
      this.labelSelection.clear();
    }
    this._gridLength = value;
  }
  get gridLength() {
    return this._gridLength;
  }
  calculateDomain() {
    var _a;
    const {
      direction,
      boundSeries
    } = this;
    const domains = [];
    let isNumericX = undefined;
    boundSeries.filter(s => s.visible).forEach(series => {
      if (direction === ChartAxisDirection.X) {
        if (isNumericX === undefined) {
          // always add first X domain
          const domain = series.getDomain(direction);
          domains.push(domain);
          isNumericX = typeof domain[0] === 'number';
        } else if (isNumericX) {
          // only add further X domains if the axis is numeric
          domains.push(series.getDomain(direction));
        }
      } else {
        domains.push(series.getDomain(direction));
      }
    });
    const domain = new Array().concat(...domains);
    const values = (_a = extent(domain)) !== null && _a !== void 0 ? _a : domain;
    this.dataDomain = this.normaliseDataDomain(values);
    this.scale.domain = this.dataDomain;
  }
  normaliseDataDomain(d) {
    // Prevent duplicate categories.
    const values = d.filter((s, i, arr) => arr.indexOf(s) === i);
    const tickTree = ticksToTree(values);
    this.tickTreeLayout = treeLayout(tickTree);
    const tickScaleDomain = values.slice();
    tickScaleDomain.push('');
    this.tickScale.domain = tickScaleDomain;
    this.resizeTickTree();
    return values;
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */
  update(primaryTickCount) {
    this.updateDirection();
    this.calculateDomain();
    this.updateRange();
    const {
      scale,
      label,
      label: {
        parallel
      },
      moduleCtx: {
        callbackCache
      },
      tickScale,
      range: requestedRange,
      title,
      title: {
        formatter = p => p.defaultValue
      } = {},
      _titleCaption
    } = this;
    const rangeStart = scale.range[0];
    const rangeEnd = scale.range[1];
    const rangeLength = Math.abs(rangeEnd - rangeStart);
    const bandwidth = rangeLength / scale.domain.length || 0;
    const rotation = toRadians(this.rotation);
    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;
    const sideFlag = label.getSideFlag();
    this.updatePosition({
      rotation,
      sideFlag
    });
    // The Text `node` of the Caption is not used to render the title of the grouped category axis.
    // The phantom root of the tree layout is used instead.
    _titleCaption.node.visible = false;
    const lineHeight = this.lineHeight;
    // Render ticks and labels.
    const tickTreeLayout = this.tickTreeLayout;
    const labels = scale.ticks();
    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];
    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;
    const ticks = tickScale.ticks();
    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to
    // flip the labels to avoid upside-down text, when the axis is rotated
    // such that it is in the right hemisphere, i.e. the angle of rotation
    // is in the [0, Ï] interval.
    // The rotation angle is normalized, so that we have an easier time checking
    // if it's in the said interval. Since the axis is always rendered vertically
    // and then rotated, zero rotation means 12 (not 3) o-clock.
    // -1 = flip
    //  1 = don't flip (default)
    const {
      defaultRotation,
      configuredRotation,
      parallelFlipFlag
    } = calculateLabelRotation({
      rotation: label.rotation,
      parallel,
      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),
      parallelFlipRotation: normalizeAngle360(rotation)
    });
    const gridLineSelection = this.gridLineSelection.update(this.gridLength ? ticks : []);
    const labelSelection = this.labelSelection.update(treeLabels);
    const labelFormatter = label.formatter;
    const labelBBoxes = new Map();
    let maxLeafLabelWidth = 0;
    labelSelection.each((node, datum, index) => {
      var _a;
      node.fontStyle = label.fontStyle;
      node.fontWeight = label.fontWeight;
      node.fontSize = label.fontSize;
      node.fontFamily = label.fontFamily;
      node.fill = label.color;
      node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';
      node.textAlign = 'center';
      node.translationX = datum.screenY - label.fontSize * 0.25;
      node.translationY = datum.screenX;
      if (index === 0) {
        // use the phantom root as the axis title
        if ((title === null || title === void 0 ? void 0 : title.enabled) && labels.length > 0) {
          node.visible = true;
          node.text = callbackCache.call(formatter, this.getTitleFormatterParams());
          node.fontSize = title.fontSize;
          node.fontStyle = title.fontStyle;
          node.fontWeight = title.fontWeight;
          node.fontFamily = title.fontFamily;
          node.textBaseline = 'hanging';
        } else {
          node.visible = false;
        }
      } else if (labelFormatter) {
        node.text = (_a = callbackCache.call(labelFormatter, {
          value: String(datum.label),
          index
        })) !== null && _a !== void 0 ? _a : String(datum.label);
        node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];
      } else {
        node.text = String(datum.label);
        node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];
      }
      const bbox = node.computeBBox();
      labelBBoxes.set(node.id, bbox);
      if (bbox.width > maxLeafLabelWidth) {
        maxLeafLabelWidth = bbox.width;
      }
    });
    const labelX = sideFlag * label.padding;
    const labelGrid = this.label.grid;
    const separatorData = [];
    labelSelection.each((label, datum, index) => {
      label.x = labelX;
      label.rotationCenterX = labelX;
      if (!datum.children.length) {
        label.rotation = configuredRotation;
        label.textAlign = 'end';
        label.textBaseline = 'middle';
        const bbox = labelBBoxes.get(label.id);
        if (bbox && bbox.height > bandwidth) {
          label.visible = false;
        }
      } else {
        label.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;
        const availableRange = datum.leafCount * bandwidth;
        const bbox = labelBBoxes.get(label.id);
        if (bbox && bbox.width > availableRange) {
          label.visible = false;
        } else if (isHorizontal) {
          label.rotation = defaultRotation;
        } else {
          label.rotation = -Math.PI / 2;
        }
      }
      // Calculate positions of label separators for all nodes except the root.
      // Each separator is placed to the top of the current label.
      if (datum.parent && isLabelTree) {
        const y = !datum.children.length ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;
        if (!datum.children.length) {
          if (datum.number !== datum.children.length - 1 || labelGrid) {
            separatorData.push({
              y,
              x1: 0,
              x2: -maxLeafLabelWidth - this.label.padding * 2,
              toString: () => String(index)
            });
          }
        } else {
          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;
          separatorData.push({
            y,
            x1: x + lineHeight,
            x2: x,
            toString: () => String(index)
          });
        }
      }
    });
    // Calculate the position of the long separator on the far bottom of the axis.
    let minX = 0;
    separatorData.forEach(d => minX = Math.min(minX, d.x2));
    separatorData.push({
      y: Math.max(rangeStart, rangeEnd),
      x1: 0,
      x2: minX,
      toString: () => String(separatorData.length)
    });
    const separatorSelection = this.separatorSelection.update(separatorData);
    const epsilon = 0.0000001;
    separatorSelection.each((line, datum) => {
      line.x1 = datum.x1;
      line.x2 = datum.x2;
      line.y1 = datum.y;
      line.y2 = datum.y;
      line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;
      line.stroke = this.tick.color;
      line.fill = undefined;
      line.strokeWidth = 1;
    });
    this.gridLineSelection = gridLineSelection;
    this.labelSelection = labelSelection;
    // Render axis lines.
    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;
    const lines = [];
    for (let i = 0; i < lineCount; i++) {
      lines.push(i);
    }
    const axisLineSelection = this.axisLineSelection.update(lines);
    axisLineSelection.each((line, _, index) => {
      const x = index > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (index - 1) * lineHeight : 0;
      line.x1 = x;
      line.x2 = x;
      line.y1 = requestedRange[0];
      line.y2 = requestedRange[1];
      line.strokeWidth = this.line.width;
      line.stroke = this.line.color;
      line.visible = labels.length > 0 && (index === 0 || labelGrid && isLabelTree);
    });
    if (this.gridLength) {
      const styles = this.gridStyle;
      const styleCount = styles.length;
      gridLineSelection.each((line, datum, index) => {
        const y = Math.round(tickScale.convert(datum));
        line.x1 = 0;
        line.x2 = -sideFlag * this.gridLength;
        line.y1 = y;
        line.y2 = y;
        line.visible = y >= requestedRange[0] && y <= requestedRange[1];
        const style = styles[index % styleCount];
        line.stroke = style.stroke;
        line.strokeWidth = this.tick.width;
        line.lineDash = style.lineDash;
        line.fill = undefined;
      });
    }
    return primaryTickCount;
  }
}
GroupedCategoryAxis.className = 'GroupedCategoryAxis';
GroupedCategoryAxis.type = 'groupedCategory';
groupedCategoryAxis_decorate([Validate(OPT_COLOR_STRING)], GroupedCategoryAxis.prototype, "labelColor", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/cartesianChart.mjs
var cartesianChart_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};






const directions = ['top', 'right', 'bottom', 'left'];
class CartesianChart extends Chart {
  constructor(document = window.document, overrideDevicePixelRatio, resources) {
    super(document, overrideDevicePixelRatio, resources);
    /** Integrated Charts feature state - not used in Standalone Charts. */
    this.paired = true;
    this._lastAxisWidths = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    this._lastVisibility = {
      crossLines: true,
      series: true
    };
  }
  performLayout() {
    const _super = Object.create(null, {
      performLayout: {
        get: () => super.performLayout
      }
    });
    return cartesianChart_awaiter(this, void 0, void 0, function* () {
      const shrinkRect = yield _super.performLayout.call(this);
      const {
        seriesRect,
        visibility,
        clipSeries
      } = this.updateAxes(shrinkRect);
      this.seriesRoot.visible = visibility.series;
      this.seriesRect = seriesRect;
      this.series.forEach(series => {
        series.rootGroup.translationX = Math.floor(seriesRect.x);
        series.rootGroup.translationY = Math.floor(seriesRect.y);
      });
      const {
        seriesRoot,
        seriesAreaPadding
      } = this;
      const seriesPaddedRect = seriesRect.clone().grow(seriesAreaPadding);
      const hoverRectPadding = 20;
      const hoverRect = seriesPaddedRect.clone().grow(hoverRectPadding);
      this.hoverRect = hoverRect;
      this.layoutService.dispatchLayoutComplete({
        type: 'layout-complete',
        chart: {
          width: this.scene.width,
          height: this.scene.height
        },
        series: {
          rect: seriesRect,
          paddedRect: seriesPaddedRect,
          hoverRect,
          visible: visibility.series
        },
        axes: this.axes.map(axis => Object.assign({
          id: axis.id
        }, axis.getLayoutState()))
      });
      if (clipSeries) {
        seriesRoot.setClipRectInGroupCoordinateSpace(seriesPaddedRect);
      } else {
        seriesRoot.setClipRectInGroupCoordinateSpace();
      }
      return shrinkRect;
    });
  }
  updateAxes(inputShrinkRect) {
    var _a;
    // Start with a good approximation from the last update - this should mean that in many resize
    // cases that only a single pass is needed \o/.
    const axisWidths = Object.assign({}, this._lastAxisWidths);
    const visibility = Object.assign({}, this._lastVisibility);
    // Clean any positions which aren't valid with the current axis status (otherwise we end up
    // never being able to find a stable result).
    const liveAxisWidths = new Set(this._axes.map(a => a.position));
    for (const position of Object.keys(axisWidths)) {
      if (!liveAxisWidths.has(position)) {
        delete axisWidths[position];
      }
    }
    const stableOutputs = (otherAxisWidths, otherVisibility) => {
      // Check for new axis positions.
      if (Object.keys(otherAxisWidths).some(k => axisWidths[k] == null)) {
        return false;
      }
      return visibility.crossLines === otherVisibility.crossLines && visibility.series === otherVisibility.series &&
      // Check for existing axis positions and equality.
      Object.entries(axisWidths).every(([p, w]) => {
        const otherW = otherAxisWidths[p];
        if (w != null || otherW != null) {
          return w === otherW;
        }
        return true;
      });
    };
    const ceilValues = records => {
      return Object.entries(records).reduce((out, [key, value]) => {
        if (value && Math.abs(value) === Infinity) {
          value = 0;
        }
        out[key] = value != null ? Math.ceil(value) : value;
        return out;
      }, {});
    };
    // Iteratively try to resolve axis widths - since X axis width affects Y axis range,
    // and vice-versa, we need to iteratively try and find a fit for the axes and their
    // ticks/labels.
    let lastPassAxisWidths = {};
    let lastPassVisibility = {};
    let clipSeries = false;
    let seriesRect = (_a = this.seriesRect) === null || _a === void 0 ? void 0 : _a.clone();
    let count = 0;
    do {
      Object.assign(axisWidths, lastPassAxisWidths);
      Object.assign(visibility, lastPassVisibility);
      const result = this.updateAxesPass(axisWidths, inputShrinkRect.clone(), seriesRect);
      lastPassAxisWidths = ceilValues(result.axisWidths);
      lastPassVisibility = result.visibility;
      clipSeries = result.clipSeries;
      seriesRect = result.seriesRect;
      if (count++ > 10) {
        Logger.warn('unable to find stable axis layout.');
        break;
      }
    } while (!stableOutputs(lastPassAxisWidths, lastPassVisibility));
    const clipRectPadding = 5;
    this.axes.forEach(axis => {
      // update visibility of crosslines
      axis.setCrossLinesVisible(visibility.crossLines);
      if (!seriesRect) {
        return;
      }
      axis.clipGrid(seriesRect.x, seriesRect.y, seriesRect.width + clipRectPadding, seriesRect.height + clipRectPadding);
      switch (axis.position) {
        case 'left':
        case 'right':
          axis.clipTickLines(inputShrinkRect.x, seriesRect.y, inputShrinkRect.width + clipRectPadding, seriesRect.height + clipRectPadding);
          break;
        case 'top':
        case 'bottom':
          axis.clipTickLines(seriesRect.x, inputShrinkRect.y, seriesRect.width + clipRectPadding, inputShrinkRect.height + clipRectPadding);
          break;
      }
    });
    this._lastAxisWidths = axisWidths;
    this._lastVisibility = visibility;
    return {
      seriesRect,
      visibility,
      clipSeries
    };
  }
  updateAxesPass(axisWidths, bounds, lastPassSeriesRect) {
    const {
      axes
    } = this;
    const visited = {};
    const newAxisWidths = {};
    const visibility = {
      series: true,
      crossLines: true
    };
    let clipSeries = false;
    const primaryTickCounts = {};
    const paddedBounds = this.applySeriesPadding(bounds);
    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisWidths) : {};
    const axisBound = this.buildAxisBound(paddedBounds, axisWidths, crossLinePadding, visibility);
    const seriesRect = this.buildSeriesRect(axisBound, axisWidths);
    // Set the number of ticks for continuous axes based on the available range
    // before updating the axis domain via `this.updateAxes()` as the tick count has an effect on the calculated `nice` domain extent
    axes.forEach(axis => {
      var _a, _b;
      const {
        position
      } = axis;
      const {
        clipSeries: newClipSeries,
        axisThickness,
        axisOffset
      } = this.calculateAxisDimensions({
        axis,
        seriesRect,
        paddedBounds,
        axisWidths,
        newAxisWidths,
        primaryTickCounts,
        clipSeries,
        addInterAxisPadding: ((_a = visited[position]) !== null && _a !== void 0 ? _a : 0) > 0
      });
      visited[position] = ((_b = visited[position]) !== null && _b !== void 0 ? _b : 0) + 1;
      clipSeries = clipSeries || newClipSeries;
      this.positionAxis({
        axis,
        axisBound,
        axisOffset,
        axisThickness,
        axisWidths,
        primaryTickCounts,
        seriesRect
      });
    });
    return {
      clipSeries,
      seriesRect,
      axisWidths: newAxisWidths,
      visibility
    };
  }
  buildCrossLinePadding(axisWidths) {
    var _a;
    const crossLinePadding = {};
    this.axes.forEach(axis => {
      if (axis.crossLines) {
        axis.crossLines.forEach(crossLine => {
          crossLine.calculatePadding(crossLinePadding);
        });
      }
    });
    // Reduce cross-line padding to account for overlap with axes.
    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {
      crossLinePadding[side] = Math.max(padding - ((_a = axisWidths[side]) !== null && _a !== void 0 ? _a : 0), 0);
    }
    return crossLinePadding;
  }
  applySeriesPadding(bounds) {
    const paddedRect = bounds.clone();
    const reversedAxes = this.axes.slice().reverse();
    directions.forEach(dir => {
      const padding = this.seriesAreaPadding[dir];
      const axis = reversedAxes.find(axis => axis.position === dir);
      if (axis) {
        axis.seriesAreaPadding = padding;
      } else {
        paddedRect.shrink(padding, dir);
      }
    });
    return paddedRect;
  }
  buildAxisBound(bounds, axisWidths, crossLinePadding, visibility) {
    var _a, _b, _c, _d;
    const result = bounds.clone();
    const {
      top = 0,
      right = 0,
      bottom = 0,
      left = 0
    } = crossLinePadding;
    const horizontalPadding = left + right;
    const verticalPadding = top + bottom;
    const totalWidth = ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0) + ((_b = axisWidths.right) !== null && _b !== void 0 ? _b : 0) + horizontalPadding;
    const totalHeight = ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0) + ((_d = axisWidths.bottom) !== null && _d !== void 0 ? _d : 0) + verticalPadding;
    if (result.width <= totalWidth || result.height <= totalHeight) {
      // Not enough space for crossLines and series
      visibility.crossLines = false;
      visibility.series = false;
      return result;
    }
    result.x += left;
    result.y += top;
    result.width -= horizontalPadding;
    result.height -= verticalPadding;
    return result;
  }
  buildSeriesRect(axisBound, axisWidths) {
    const result = axisBound.clone();
    const {
      top,
      bottom,
      left,
      right
    } = axisWidths;
    result.x += left !== null && left !== void 0 ? left : 0;
    result.y += top !== null && top !== void 0 ? top : 0;
    result.width -= (left !== null && left !== void 0 ? left : 0) + (right !== null && right !== void 0 ? right : 0);
    result.height -= (top !== null && top !== void 0 ? top : 0) + (bottom !== null && bottom !== void 0 ? bottom : 0);
    // Width and height should not be negative.
    result.width = Math.max(0, result.width);
    result.height = Math.max(0, result.height);
    return result;
  }
  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
    const {
      x,
      y,
      width,
      height
    } = seriesRect;
    const clampBounds = [x, y, x + width, y + height];
    const fn = direction === 1 ? Math.min : Math.max;
    const compareTo = clampBounds[(dimension === 'x' ? 0 : 1) + (direction === 1 ? 0 : 2)];
    return fn(value, compareTo);
  }
  calculateAxisDimensions(opts) {
    var _a, _b, _c, _d, _e, _f;
    const {
      axis,
      seriesRect,
      paddedBounds,
      axisWidths,
      newAxisWidths,
      primaryTickCounts,
      addInterAxisPadding
    } = opts;
    let {
      clipSeries
    } = opts;
    const {
      position,
      direction
    } = axis;
    const axisLeftRightRange = axis => {
      if (axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis) {
        return [0, seriesRect.height];
      }
      return [seriesRect.height, 0];
    };
    const axisOffset = (_a = newAxisWidths[position]) !== null && _a !== void 0 ? _a : 0;
    switch (position) {
      case 'top':
      case 'bottom':
        axis.range = [0, seriesRect.width];
        axis.gridLength = seriesRect.height;
        break;
      case 'right':
      case 'left':
        axis.range = axisLeftRightRange(axis);
        axis.gridLength = seriesRect.width;
        break;
    }
    const zoom = (_b = this.zoomManager.getZoom()) === null || _b === void 0 ? void 0 : _b[axis.direction];
    const {
      min = 0,
      max = 1
    } = zoom !== null && zoom !== void 0 ? zoom : {};
    axis.visibleRange = [min, max];
    if (!clipSeries && (axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1)) {
      clipSeries = true;
    }
    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : undefined;
    const paddedBoundsCoefficient = 0.3;
    if (axis.thickness > 0) {
      axis.maxThickness = axis.thickness;
    } else if (direction === ChartAxisDirection.Y) {
      axis.maxThickness = paddedBounds.width * paddedBoundsCoefficient;
    } else {
      axis.maxThickness = paddedBounds.height * paddedBoundsCoefficient;
    }
    primaryTickCount = axis.update(primaryTickCount);
    primaryTickCounts[direction] = (_c = primaryTickCounts[direction]) !== null && _c !== void 0 ? _c : primaryTickCount;
    let axisThickness = 0;
    if (axis.thickness) {
      axisThickness = axis.thickness;
    } else {
      const bbox = axis.computeBBox();
      axisThickness = direction === ChartAxisDirection.X ? bbox.height : bbox.width;
    }
    // for multiple axes in the same direction and position, apply padding at the top of each inner axis (i.e. between axes).
    const axisPadding = 15;
    if (addInterAxisPadding) {
      axisThickness += axisPadding;
    }
    axisThickness = Math.ceil(axisThickness);
    newAxisWidths[position] = ((_d = newAxisWidths[position]) !== null && _d !== void 0 ? _d : 0) + axisThickness;
    axis.gridPadding = ((_e = axisWidths[position]) !== null && _e !== void 0 ? _e : 0) - ((_f = newAxisWidths[position]) !== null && _f !== void 0 ? _f : 0);
    return {
      clipSeries,
      axisThickness,
      axisOffset
    };
  }
  positionAxis(opts) {
    var _a, _b, _c, _d;
    const {
      axis,
      axisBound,
      axisWidths,
      seriesRect,
      axisOffset,
      axisThickness
    } = opts;
    const {
      position
    } = axis;
    switch (position) {
      case 'top':
        axis.translation.x = axisBound.x + ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0);
        axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + 1 + axisOffset + axisThickness, 'y', 1);
        break;
      case 'bottom':
        axis.translation.x = axisBound.x + ((_b = axisWidths.left) !== null && _b !== void 0 ? _b : 0);
        axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + axisBound.height + 1 - axisThickness - axisOffset, 'y', -1);
        break;
      case 'left':
        axis.translation.y = axisBound.y + ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0);
        axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisOffset + axisThickness, 'x', 1);
        break;
      case 'right':
        axis.translation.y = axisBound.y + ((_d = axisWidths.top) !== null && _d !== void 0 ? _d : 0);
        axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisBound.width - axisThickness - axisOffset, 'x', -1);
        break;
    }
    axis.updatePosition({
      rotation: toRadians(axis.rotation),
      sideFlag: axis.label.getSideFlag()
    });
  }
}
CartesianChart.className = 'CartesianChart';
CartesianChart.type = 'cartesian';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/polar/polarSeries.mjs


class PolarSeries extends Series {
  constructor({
    moduleCtx,
    useLabelLayer = false,
    pickModes = [SeriesNodePickMode.EXACT_SHAPE_MATCH]
  }) {
    super({
      moduleCtx,
      useLabelLayer,
      pickModes,
      directionKeys: {
        [ChartAxisDirection.X]: ['angleKey'],
        [ChartAxisDirection.Y]: ['radiusKey']
      },
      directionNames: {
        [ChartAxisDirection.X]: ['angleName'],
        [ChartAxisDirection.Y]: ['radiusName']
      }
    });
    /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */
    this.centerX = 0;
    this.centerY = 0;
    /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */
    this.radius = 0;
  }
  getLabelData() {
    return [];
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/sector.mjs

function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const {
    innerRadius,
    outerRadius
  } = sector;
  if (radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  // Start and End angles are expected to be [-90, 270]
  // while Math.atan2 returns [-180, 180]
  let angle = Math.atan2(y, x);
  if (angle < -Math.PI / 2) {
    angle += 2 * Math.PI;
  }
  // Start is actually bigger than End clock-wise
  const {
    startAngle,
    endAngle
  } = sector;
  if (endAngle === -Math.PI / 2) {
    return angle < startAngle;
  }
  if (startAngle === 3 * Math.PI / 2) {
    return angle > endAngle;
  }
  return angle <= endAngle && angle >= startAngle;
}
function lineCollidesSector(line, sector) {
  const {
    startAngle,
    endAngle,
    innerRadius,
    outerRadius
  } = sector;
  const outerStart = {
    x: outerRadius * Math.cos(startAngle),
    y: outerRadius * Math.sin(startAngle)
  };
  const outerEnd = {
    x: outerRadius * Math.cos(endAngle),
    y: outerRadius * Math.sin(endAngle)
  };
  const innerStart = innerRadius === 0 ? {
    x: 0,
    y: 0
  } : {
    x: innerRadius * Math.cos(startAngle),
    y: innerRadius * Math.sin(startAngle)
  };
  const innerEnd = innerRadius === 0 ? {
    x: 0,
    y: 0
  } : {
    x: innerRadius * Math.cos(endAngle),
    y: innerRadius * Math.sin(endAngle)
  };
  return segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerStart.x, outerStart.y, innerStart.x, innerStart.y) != null || segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerEnd.x, outerEnd.y, innerEnd.x, innerEnd.y) != null || arcIntersections(0, 0, outerRadius, startAngle, endAngle, true, line.start.x, line.start.y, line.end.x, line.end.y).length > 0;
}
function boxCollidesSector(box, sector) {
  const topLeft = {
    x: box.x,
    y: box.y
  };
  const topRight = {
    x: box.x + box.width,
    y: box.y
  };
  const bottomLeft = {
    x: box.x,
    y: box.y + box.height
  };
  const bottomRight = {
    x: box.x + box.width,
    y: box.y + box.height
  };
  return lineCollidesSector({
    start: topLeft,
    end: topRight
  }, sector) || lineCollidesSector({
    start: bottomLeft,
    end: bottomRight
  }, sector);
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/sector.mjs
var sector_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class Sector extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.innerRadius = 10;
    this.outerRadius = 20;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.angleOffset = 0;
  }
  computeBBox() {
    const radius = this.outerRadius;
    return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);
  }
  updatePath() {
    const path = this.path;
    const angleOffset = this.angleOffset;
    const startAngle = Math.min(this.startAngle, this.endAngle) + angleOffset;
    const endAngle = Math.max(this.startAngle, this.endAngle) + angleOffset;
    const innerRadius = Math.min(this.innerRadius, this.outerRadius);
    const outerRadius = Math.max(this.innerRadius, this.outerRadius);
    const fullPie = isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));
    const centerX = this.centerX;
    const centerY = this.centerY;
    path.clear();
    if (fullPie) {
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > 0) {
        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      }
    } else {
      path.moveTo(centerX + innerRadius * Math.cos(startAngle), centerY + innerRadius * Math.sin(startAngle));
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > 0) {
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      } else {
        path.lineTo(centerX, centerY);
      }
    }
    path.closePath();
    this.dirtyPath = false;
  }
  isPointInPath(x, y) {
    const {
      angleOffset
    } = this;
    const startAngle = this.startAngle + angleOffset;
    const endAngle = this.endAngle + angleOffset;
    const innerRadius = Math.min(this.innerRadius, this.outerRadius);
    const outerRadius = Math.max(this.innerRadius, this.outerRadius);
    const point = this.transformPoint(x, y);
    return isPointInSector(point.x, point.y, {
      startAngle,
      endAngle,
      innerRadius,
      outerRadius
    });
  }
}
Sector.className = 'Sector';
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "centerX", void 0);
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "centerY", void 0);
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "innerRadius", void 0);
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "outerRadius", void 0);
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "startAngle", void 0);
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "endAngle", void 0);
sector_decorate([ScenePathChangeDetection()], Sector.prototype, "angleOffset", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/data/processors.mjs
const SMALLEST_KEY_INTERVAL = {
  type: 'reducer',
  property: 'smallestKeyInterval',
  initialValue: Infinity,
  reducer: () => {
    let prevX = NaN;
    return (smallestSoFar, next) => {
      const nextX = next.keys[0];
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
        return interval;
      }
      return smallestSoFar;
    };
  }
};
const AGG_VALUES_EXTENT = {
  type: 'processor',
  property: 'aggValuesExtent',
  calculate: processedData => {
    var _a, _b, _c, _d;
    const result = [...((_b = (_a = processedData.domain.aggValues) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : [0, 0])];
    for (const [min, max] of (_d = (_c = processedData.domain.aggValues) === null || _c === void 0 ? void 0 : _c.slice(1)) !== null && _d !== void 0 ? _d : []) {
      if (min < result[0]) {
        result[0] = min;
      }
      if (max > result[1]) {
        result[1] = max;
      }
    }
    return result;
  }
};
const SORT_DOMAIN_GROUPS = {
  type: 'processor',
  property: 'sortedGroupDomain',
  calculate: ({
    domain: {
      groups
    }
  }) => {
    if (groups == null) return undefined;
    return [...groups].sort((a, b) => {
      for (let i = 0; i < a.length; i++) {
        const result = a[i] - b[i];
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
  }
};
function normaliseGroupTo(properties, normaliseTo, mode = 'sum') {
  const normalise = (val, extent) => {
    const result = val * normaliseTo / extent;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return {
    type: 'group-value-processor',
    properties,
    adjust: () => (values, valueIndexes) => {
      const valuesExtent = [0, 0];
      for (const valueIdx of valueIndexes) {
        const value = values[valueIdx];
        const valIdx = value < 0 ? 0 : 1;
        if (mode === 'sum') {
          valuesExtent[valIdx] += value;
        } else if (valIdx === 0) {
          valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);
        } else {
          valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);
        }
      }
      const extent = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
      for (const valueIdx of valueIndexes) {
        values[valueIdx] = normalise(values[valueIdx], extent);
      }
    }
  };
}
function normalisePropertyTo(property, normaliseTo, rangeMin, rangeMax) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise = (val, start, span) => {
    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;
    if (span === 0) return normaliseTo[1];
    if (result >= normaliseTo[1]) return normaliseTo[1];
    if (result < normaliseTo[0]) return normaliseTo[0];
    return result;
  };
  return {
    type: 'property-value-processor',
    property,
    adjust: () => (pData, pIdx) => {
      let [start, end] = pData.domain.values[pIdx];
      if (rangeMin != null) start = rangeMin;
      if (rangeMax != null) end = rangeMax;
      const span = end - start;
      pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
      for (const group of pData.data) {
        let groupValues = group.values;
        if (pData.type === 'ungrouped') {
          groupValues = [groupValues];
        }
        for (const values of groupValues) {
          values[pIdx] = normalise(values[pIdx], start, span);
        }
      }
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/polar/pieSeries.mjs

var pieSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var pieSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
























class PieSeriesNodeBaseClickEvent extends SeriesNodeBaseClickEvent {
  constructor(angleKey, calloutLabelKey, sectorLabelKey, radiusKey, nativeEvent, datum, series) {
    super(nativeEvent, datum, series);
    this.angleKey = angleKey;
    this.calloutLabelKey = calloutLabelKey;
    this.sectorLabelKey = sectorLabelKey;
    this.radiusKey = radiusKey;
  }
}
class PieSeriesNodeClickEvent extends PieSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeClick';
  }
}
class PieSeriesNodeDoubleClickEvent extends PieSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeDoubleClick';
  }
}
var PieNodeTag;
(function (PieNodeTag) {
  PieNodeTag[PieNodeTag["Sector"] = 0] = "Sector";
  PieNodeTag[PieNodeTag["Callout"] = 1] = "Callout";
  PieNodeTag[PieNodeTag["Label"] = 2] = "Label";
})(PieNodeTag || (PieNodeTag = {}));
class PieSeriesCalloutLabel extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3; // from the callout line
    this.minAngle = 0; // in degrees
    this.formatter = undefined;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
  }
}
pieSeries_decorate([Validate(NUMBER(0))], PieSeriesCalloutLabel.prototype, "offset", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeriesCalloutLabel.prototype, "minAngle", void 0);
pieSeries_decorate([Validate(OPT_FUNCTION)], PieSeriesCalloutLabel.prototype, "formatter", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeriesCalloutLabel.prototype, "minSpacing", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeriesCalloutLabel.prototype, "maxCollisionOffset", void 0);
class PieSeriesSectorLabel extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
    this.formatter = undefined;
  }
}
pieSeries_decorate([Validate(NUMBER())], PieSeriesSectorLabel.prototype, "positionOffset", void 0);
pieSeries_decorate([Validate(NUMBER(0, 1))], PieSeriesSectorLabel.prototype, "positionRatio", void 0);
pieSeries_decorate([Validate(OPT_FUNCTION)], PieSeriesSectorLabel.prototype, "formatter", void 0);
class PieSeriesCalloutLine {
  constructor() {
    this.colors = undefined;
    this.length = 10;
    this.strokeWidth = 1;
  }
}
pieSeries_decorate([Validate(OPT_COLOR_STRING_ARRAY)], PieSeriesCalloutLine.prototype, "colors", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeriesCalloutLine.prototype, "length", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeriesCalloutLine.prototype, "strokeWidth", void 0);
class PieSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
  }
}
pieSeries_decorate([Validate(OPT_FUNCTION)], PieSeriesTooltip.prototype, "renderer", void 0);
class PieTitle extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
}
pieSeries_decorate([Validate(BOOLEAN)], PieTitle.prototype, "showInLegend", void 0);
class DoughnutInnerLabel extends Label {
  constructor() {
    super(...arguments);
    this.text = '';
    this.margin = 2;
  }
}
pieSeries_decorate([Validate(STRING)], DoughnutInnerLabel.prototype, "text", void 0);
pieSeries_decorate([Validate(NUMBER())], DoughnutInnerLabel.prototype, "margin", void 0);
class DoughnutInnerCircle {
  constructor() {
    this.fill = 'transparent';
    this.fillOpacity = 1;
  }
}
pieSeries_decorate([Validate(COLOR_STRING)], DoughnutInnerCircle.prototype, "fill", void 0);
pieSeries_decorate([Validate(OPT_NUMBER(0, 1))], DoughnutInnerCircle.prototype, "fillOpacity", void 0);
class PieStateMachine extends StateMachine {}
class PieSeries extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true
    });
    this.radiusScale = new LinearScale();
    this.groupSelection = Selection.select(this.contentGroup, Group);
    this.highlightSelection = Selection.select(this.highlightGroup, Group);
    this.nodeData = [];
    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
    this.seriesItemEnabled = [];
    this.title = undefined;
    this.calloutLabel = new PieSeriesCalloutLabel();
    this.sectorLabel = new PieSeriesSectorLabel();
    this.calloutLine = new PieSeriesCalloutLine();
    this.tooltip = new PieSeriesTooltip();
    /**
     * The key of the numeric field to use to determine the angle (for example,
     * a pie sector angle).
     */
    this.angleKey = '';
    this.angleName = '';
    this.innerLabels = [];
    this.innerCircle = undefined;
    /**
     * The key of the numeric field to use to determine the radii of pie sectors.
     * The largest value will correspond to the full radius and smaller values to
     * proportionally smaller radii.
     */
    this.radiusKey = undefined;
    this.radiusName = undefined;
    this.radiusMin = undefined;
    this.radiusMax = undefined;
    this.calloutLabelKey = undefined;
    this.calloutLabelName = undefined;
    this.sectorLabelKey = undefined;
    this.sectorLabelName = undefined;
    this.legendItemKey = undefined;
    this.fills = ['#c16068', '#a2bf8a', '#ebcc87', '#80a0c3', '#b58dae', '#85c0d1'];
    this.strokes = ['#874349', '#718661', '#a48f5f', '#5a7088', '#7f637a', '#5d8692'];
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.formatter = undefined;
    /**
     * The series rotation in degrees.
     */
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.innerRadiusOffset = 0;
    this.innerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.shadow = undefined;
    this.highlightStyle = new HighlightStyle();
    this.surroundingRadius = undefined;
    this.angleScale = new LinearScale();
    // Each sector is a ratio of the whole, where all ratios add up to 1.
    this.angleScale.domain = [0, 1];
    // Add 90 deg to start the first pie at 12 o'clock.
    this.angleScale.range = [-Math.PI, Math.PI].map(angle => angle + Math.PI / 2);
    this.backgroundGroup = this.rootGroup.appendChild(new Group({
      name: `${this.id}-background`,
      layer: true,
      zIndex: Layers.SERIES_BACKGROUND_ZINDEX
    }));
    const pieCalloutLabels = new Group({
      name: 'pieCalloutLabels'
    });
    const pieSectorLabels = new Group({
      name: 'pieSectorLabels'
    });
    const innerLabels = new Group({
      name: 'innerLabels'
    });
    this.labelGroup.append(pieCalloutLabels);
    this.labelGroup.append(pieSectorLabels);
    this.labelGroup.append(innerLabels);
    this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);
    this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);
    this.innerLabelsSelection = Selection.select(innerLabels, Text);
    this.animationState = new PieStateMachine('empty', {
      empty: {
        on: {
          update: {
            target: 'ready',
            action: () => this.animateEmptyUpdateReady()
          }
        }
      },
      ready: {
        on: {
          update: {
            target: 'ready',
            action: () => this.animateReadyUpdateReady()
          }
        }
      }
    });
  }
  set data(input) {
    this._data = input;
    this.processSeriesItemEnabled();
  }
  get data() {
    return this._data;
  }
  addChartEventListeners() {
    var _a;
    (_a = this.chartEventManager) === null || _a === void 0 ? void 0 : _a.addListener('legend-item-click', event => this.onLegendItemClick(event));
  }
  visibleChanged() {
    this.processSeriesItemEnabled();
  }
  processSeriesItemEnabled() {
    var _a;
    const {
      data,
      visible
    } = this;
    this.seriesItemEnabled = (_a = data === null || data === void 0 ? void 0 : data.map(() => visible)) !== null && _a !== void 0 ? _a : [];
  }
  getDomain(direction) {
    if (direction === ChartAxisDirection.X) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  processData() {
    var _a, _b;
    return pieSeries_awaiter(this, void 0, void 0, function* () {
      let {
        data = []
      } = this;
      const {
        angleKey,
        radiusKey,
        seriesItemEnabled
      } = this;
      if (!angleKey) return;
      const extraProps = [];
      if (radiusKey) {
        extraProps.push(rangedValueProperty(radiusKey, {
          id: 'radiusValue',
          min: (_a = this.radiusMin) !== null && _a !== void 0 ? _a : 0,
          max: this.radiusMax
        }), valueProperty(radiusKey, true, {
          id: `radiusRaw`
        }),
        // Raw value pass-through.
        normalisePropertyTo({
          id: 'radiusValue'
        }, [0, 1], (_b = this.radiusMin) !== null && _b !== void 0 ? _b : 0, this.radiusMax));
        extraProps.push();
      }
      data = data.map((d, idx) => seriesItemEnabled[idx] ? d : Object.assign(Object.assign({}, d), {
        [angleKey]: 0
      }));
      this.dataModel = new DataModel({
        props: [accumulativeValueProperty(angleKey, true, {
          id: `angleValue`
        }), valueProperty(angleKey, true, {
          id: `angleRaw`
        }), normalisePropertyTo({
          id: 'angleValue'
        }, [0, 1], 0), ...extraProps]
      });
      this.processedData = this.dataModel.processData(data);
    });
  }
  maybeRefreshNodeData() {
    if (!this.nodeDataRefresh) return;
    const [{
      nodeData = []
    } = {}] = this._createNodeData();
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  createNodeData() {
    return pieSeries_awaiter(this, void 0, void 0, function* () {
      return this._createNodeData();
    });
  }
  _createNodeData() {
    var _a, _b, _c, _d;
    const {
      id: seriesId,
      processedData,
      dataModel,
      rotation,
      angleScale
    } = this;
    if (!processedData || !dataModel || processedData.type !== 'ungrouped') return [];
    const angleIdx = (_b = (_a = dataModel.resolveProcessedDataIndexById(`angleValue`)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    const radiusIdx = (_d = (_c = dataModel.resolveProcessedDataIndexById(`radiusValue`)) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : -1;
    if (angleIdx < 0) return [];
    let currentStart = 0;
    const nodeData = processedData.data.map((group, index) => {
      var _a;
      const {
        datum,
        values
      } = group;
      const currentValue = values[angleIdx];
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = values[angleIdx + 1];
      const radius = radiusIdx >= 0 ? (_a = values[radiusIdx]) !== null && _a !== void 0 ? _a : 1 : 1;
      const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : undefined;
      const labels = this.getLabels(datum, midAngle, span, true);
      const sectorFormat = this.getSectorFormat(datum, index, index, false);
      return Object.assign({
        itemId: index,
        series: this,
        datum,
        index,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        sectorFormat,
        radius,
        radiusValue
      }, labels);
    });
    return [{
      itemId: seriesId,
      nodeData,
      labelData: nodeData
    }];
  }
  getLabels(datum, midAngle, span, skipDisabled) {
    const {
      calloutLabel,
      sectorLabel,
      legendItemKey,
      ctx: {
        callbackCache
      }
    } = this;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.calloutLabelKey : undefined;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.sectorLabelKey : undefined;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) return {};
    const labelFormatterParams = this.getLabelFormatterParams(datum);
    let calloutLabelText;
    if (calloutLabelKey) {
      const calloutLabelMinAngle = toRadians(calloutLabel.minAngle);
      const calloutLabelVisible = span > calloutLabelMinAngle;
      if (!calloutLabelVisible) {
        calloutLabelText = undefined;
      } else if (calloutLabel.formatter) {
        calloutLabelText = callbackCache.call(calloutLabel.formatter, labelFormatterParams);
      } else {
        calloutLabelText = String(datum[calloutLabelKey]);
      }
    }
    let sectorLabelText;
    if (sectorLabelKey) {
      if (sectorLabel.formatter) {
        sectorLabelText = callbackCache.call(sectorLabel.formatter, labelFormatterParams);
      } else {
        sectorLabelText = String(datum[sectorLabelKey]);
      }
    }
    let legendItemText;
    if (legendItemKey) {
      legendItemText = String(datum[legendItemKey]);
    }
    return Object.assign(Object.assign(Object.assign({}, calloutLabelText != null ? {
      calloutLabel: Object.assign(Object.assign({}, this.getTextAlignment(midAngle)), {
        text: calloutLabelText,
        hidden: false,
        collisionTextAlign: undefined,
        collisionOffsetY: 0,
        box: undefined
      })
    } : {}), sectorLabelText != null ? {
      sectorLabel: {
        text: sectorLabelText
      }
    } : {}), legendItemKey != null && legendItemText != null ? {
      legendItem: {
        key: legendItemKey,
        text: legendItemText
      }
    } : {});
  }
  getLabelFormatterParams(datum) {
    const {
      id: seriesId,
      radiusKey,
      radiusName,
      angleKey,
      angleName,
      calloutLabelKey,
      calloutLabelName,
      sectorLabelKey,
      sectorLabelName
    } = this;
    return {
      datum,
      angleKey,
      angleValue: datum[angleKey],
      angleName,
      radiusKey,
      radiusValue: radiusKey ? datum[radiusKey] : undefined,
      radiusName,
      calloutLabelKey,
      calloutLabelValue: calloutLabelKey ? datum[calloutLabelKey] : undefined,
      calloutLabelName,
      sectorLabelKey,
      sectorLabelValue: sectorLabelKey ? datum[sectorLabelKey] : undefined,
      sectorLabelName,
      seriesId
    };
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [{
      textAlign: 'center',
      textBaseline: 'bottom'
    }, {
      textAlign: 'left',
      textBaseline: 'middle'
    }, {
      textAlign: 'center',
      textBaseline: 'hanging'
    }, {
      textAlign: 'right',
      textBaseline: 'middle'
    }];
    const midAngle180 = normalizeAngle180(midAngle);
    // Split the circle into quadrants like so: â
    const quadrantStart = -3 * Math.PI / 4; // same as `normalizeAngle180(toRadians(-135))`
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getSectorFormat(datum, itemId, index, highlight) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const {
      angleKey,
      radiusKey,
      fills,
      strokes,
      fillOpacity: seriesFillOpacity,
      formatter,
      id: seriesId,
      ctx: {
        callbackCache
      }
    } = this;
    const highlightedDatum = (_a = this.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();
    const isDatumHighlighted = highlight && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && itemId === highlightedDatum.itemId;
    const highlightedStyle = isDatumHighlighted ? this.highlightStyle.item : null;
    const fill = (_b = highlightedStyle === null || highlightedStyle === void 0 ? void 0 : highlightedStyle.fill) !== null && _b !== void 0 ? _b : fills[index % fills.length];
    const fillOpacity = (_c = highlightedStyle === null || highlightedStyle === void 0 ? void 0 : highlightedStyle.fillOpacity) !== null && _c !== void 0 ? _c : seriesFillOpacity;
    const stroke = (_d = highlightedStyle === null || highlightedStyle === void 0 ? void 0 : highlightedStyle.stroke) !== null && _d !== void 0 ? _d : strokes[index % strokes.length];
    const strokeWidth = (_e = highlightedStyle === null || highlightedStyle === void 0 ? void 0 : highlightedStyle.strokeWidth) !== null && _e !== void 0 ? _e : this.getStrokeWidth(this.strokeWidth);
    let format;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum,
        angleKey,
        radiusKey,
        fill,
        stroke,
        strokeWidth,
        highlighted: isDatumHighlighted,
        seriesId
      });
    }
    return {
      fill: (_f = format === null || format === void 0 ? void 0 : format.fill) !== null && _f !== void 0 ? _f : fill,
      fillOpacity: (_g = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _g !== void 0 ? _g : fillOpacity,
      stroke: (_h = format === null || format === void 0 ? void 0 : format.stroke) !== null && _h !== void 0 ? _h : stroke,
      strokeWidth: (_j = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _j !== void 0 ? _j : strokeWidth
    };
  }
  getInnerRadius() {
    const {
      radius,
      innerRadiusRatio,
      innerRadiusOffset
    } = this;
    const innerRadius = radius * (innerRadiusRatio !== null && innerRadiusRatio !== void 0 ? innerRadiusRatio : 1) + (innerRadiusOffset ? innerRadiusOffset : 0);
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    const {
      radius,
      outerRadiusRatio,
      outerRadiusOffset
    } = this;
    const outerRadius = radius * (outerRadiusRatio !== null && outerRadiusRatio !== void 0 ? outerRadiusRatio : 1) + (outerRadiusOffset ? outerRadiusOffset : 0);
    if (outerRadius < 0) {
      return 0;
    }
    return outerRadius;
  }
  updateRadiusScale() {
    const innerRadius = this.getInnerRadius();
    const outerRadius = this.getOuterRadius();
    this.radiusScale.range = [innerRadius, outerRadius];
  }
  getTitleTranslationY() {
    var _a, _b;
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = (_b = (_a = this.title) === null || _a === void 0 ? void 0 : _a.spacing) !== null && _b !== void 0 ? _b : 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  update({
    seriesRect
  }) {
    return pieSeries_awaiter(this, void 0, void 0, function* () {
      const {
        title
      } = this;
      this.maybeRefreshNodeData();
      this.updateTitleNodes();
      this.updateRadiusScale();
      this.updateInnerCircleNodes();
      this.rootGroup.translationX = this.centerX;
      this.rootGroup.translationY = this.centerY;
      if (title) {
        const dy = this.getTitleTranslationY();
        const titleBox = title.node.computeBBox();
        title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);
        title.node.translationY = isFinite(dy) ? dy : 0;
      }
      this.updateNodeMidPoint();
      yield this.updateSelections();
      yield this.updateNodes(seriesRect);
    });
  }
  updateTitleNodes() {
    var _a, _b;
    const {
      title,
      oldTitle
    } = this;
    if (oldTitle !== title) {
      if (oldTitle) {
        (_a = this.labelGroup) === null || _a === void 0 ? void 0 : _a.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = 'bottom';
        (_b = this.labelGroup) === null || _b === void 0 ? void 0 : _b.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateInnerCircleNodes() {
    var _a;
    const {
      innerCircle,
      oldInnerCircle,
      innerCircleNode: oldNode
    } = this;
    if (oldInnerCircle !== innerCircle) {
      let circle;
      if (oldNode) {
        this.backgroundGroup.removeChild(oldNode);
      }
      if (innerCircle) {
        circle = new Circle();
        circle.fill = innerCircle.fill;
        circle.fillOpacity = (_a = innerCircle.fillOpacity) !== null && _a !== void 0 ? _a : 1;
        this.backgroundGroup.appendChild(circle);
      }
      this.oldInnerCircle = innerCircle;
      this.innerCircleNode = circle;
    }
  }
  updateNodeMidPoint() {
    this.nodeData.forEach(d => {
      const radius = this.radiusScale.convert(d.radius);
      d.nodeMidPoint = {
        x: d.midCos * Math.max(0, radius / 2),
        y: d.midSin * Math.max(0, radius / 2)
      };
    });
  }
  updateSelections() {
    return pieSeries_awaiter(this, void 0, void 0, function* () {
      yield this.updateGroupSelection();
    });
  }
  updateGroupSelection() {
    return pieSeries_awaiter(this, void 0, void 0, function* () {
      const {
        groupSelection,
        highlightSelection,
        calloutLabelSelection,
        sectorLabelSelection,
        innerLabelsSelection
      } = this;
      const update = selection => {
        return selection.update(this.nodeData, group => {
          const sector = new Sector();
          sector.tag = PieNodeTag.Sector;
          group.appendChild(sector);
        });
      };
      this.groupSelection = update(groupSelection);
      this.highlightSelection = update(highlightSelection);
      calloutLabelSelection.update(this.nodeData, group => {
        const line = new Line();
        line.tag = PieNodeTag.Callout;
        line.pointerEvents = PointerEvents.None;
        group.appendChild(line);
        const text = new Text();
        text.tag = PieNodeTag.Label;
        text.pointerEvents = PointerEvents.None;
        group.appendChild(text);
      });
      sectorLabelSelection.update(this.nodeData, node => {
        node.pointerEvents = PointerEvents.None;
      });
      innerLabelsSelection.update(this.innerLabels, node => {
        node.pointerEvents = PointerEvents.None;
      });
    });
  }
  updateNodes(seriesRect) {
    var _a;
    return pieSeries_awaiter(this, void 0, void 0, function* () {
      const highlightedDatum = (_a = this.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();
      const isVisible = this.seriesItemEnabled.indexOf(true) >= 0;
      this.rootGroup.visible = isVisible;
      this.backgroundGroup.visible = isVisible;
      this.contentGroup.visible = isVisible;
      this.highlightGroup.visible = isVisible && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this;
      this.labelGroup.visible = isVisible;
      this.contentGroup.opacity = this.getOpacity();
      this.updateInnerCircle();
      const {
        radiusScale
      } = this;
      const innerRadius = radiusScale.convert(0);
      const updateSectorFn = (sector, datum, index, isDatumHighlighted) => {
        const radius = radiusScale.convert(datum.radius);
        // Bring highlighted sector's parent group to front.
        const sectorParent = sector.parent;
        const sectorGrandParent = sectorParent === null || sectorParent === void 0 ? void 0 : sectorParent.parent;
        if (isDatumHighlighted && sectorParent && sectorGrandParent) {
          sectorGrandParent.removeChild(sectorParent);
          sectorGrandParent.appendChild(sectorParent);
        }
        sector.innerRadius = Math.max(0, innerRadius);
        sector.outerRadius = Math.max(0, radius);
        if (isDatumHighlighted) {
          sector.startAngle = datum.startAngle;
          sector.endAngle = datum.endAngle;
        }
        const format = this.getSectorFormat(datum.datum, datum.itemId, index, isDatumHighlighted);
        sector.fill = format.fill;
        sector.stroke = format.stroke;
        sector.strokeWidth = format.strokeWidth;
        sector.fillOpacity = format.fillOpacity;
        sector.strokeOpacity = this.strokeOpacity;
        sector.lineDash = this.lineDash;
        sector.lineDashOffset = this.lineDashOffset;
        sector.fillShadow = this.shadow;
        sector.lineJoin = 'round';
        sector.visible = this.seriesItemEnabled[index];
      };
      this.groupSelection.selectByTag(PieNodeTag.Sector).forEach((node, index) => updateSectorFn(node, node.datum, index, false));
      this.highlightSelection.selectByTag(PieNodeTag.Sector).forEach((node, index) => {
        const isDatumHighlighted = (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;
        node.visible = isDatumHighlighted;
        if (node.visible) {
          updateSectorFn(node, node.datum, index, isDatumHighlighted);
        }
      });
      this.animationState.transition('update');
      this.updateCalloutLineNodes();
      this.updateCalloutLabelNodes(seriesRect);
      this.updateSectorLabelNodes();
      this.updateInnerLabelNodes();
    });
  }
  updateCalloutLineNodes() {
    var _a;
    const {
      radiusScale,
      calloutLine
    } = this;
    const calloutLength = calloutLine.length;
    const calloutStrokeWidth = calloutLine.strokeWidth;
    const calloutColors = (_a = calloutLine.colors) !== null && _a !== void 0 ? _a : this.strokes;
    const {
      offset
    } = this.calloutLabel;
    this.calloutLabelSelection.selectByTag(PieNodeTag.Callout).forEach((line, index) => {
      const datum = line.datum;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      const label = datum.calloutLabel;
      if ((label === null || label === void 0 ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[index % calloutColors.length];
        line.fill = undefined;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        if (label.collisionTextAlign || label.collisionOffsetY !== 0) {
          // Get the closest point to the text bounding box
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          // Apply label offset
          const dx = cx - x2;
          const dy = cy - y2;
          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length - offset;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length;
            y2 = y2 + dy * paddedLength / length;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = seriesRect.x - this.centerX;
    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
    const seriesTop = seriesRect.y - this.centerY;
    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
    const errPx = 1; // Prevents errors related to floating point calculations
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return {
      visibleTextPart,
      textLength,
      hasVerticalOverflow,
      hasSurroundingSeriesOverflow
    };
  }
  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {
    const {
      surroundingRadius
    } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [{
      x: box.x + dx,
      y: box.y + dy
    }, {
      x: box.x + box.width + dx,
      y: box.y + dy
    }, {
      x: box.x + box.width + dx,
      y: box.y + box.height + dy
    }, {
      x: box.x + dx,
      y: box.y + box.height + dy
    }];
    const sur2 = Math.pow(surroundingRadius, 2);
    return corners.some(corner => Math.pow(corner.x, 2) + Math.pow(corner.y, 2) > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const {
      radiusScale,
      calloutLabel,
      calloutLine
    } = this;
    const {
      offset,
      minSpacing
    } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = datum => {
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      return !label || outerRadius === 0;
    };
    const fullData = this.nodeData;
    const data = this.nodeData.filter(text => !shouldSkip(text));
    data.forEach(datum => {
      const label = datum.calloutLabel;
      label.hidden = false;
      label.collisionTextAlign = undefined;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter(d => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter(d => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter(d => d.midSin < 0 && d.calloutLabel.textAlign === 'center').sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter(d => d.midSin >= 0 && d.calloutLabel.textAlign === 'center').sort((a, b) => a.midCos - b.midCos);
    const tempTextNode = new Text();
    const getTextBBox = datum => {
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      const labelRadius = outerRadius + calloutLine.length + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      this.setTextDimensionalProps(tempTextNode, x, y, this.calloutLabel, label);
      return tempTextNode.computeBBox();
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      // The full collision is not detected, because sometimes
      // the next label can appear behind the label with offset
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === 'to-top' ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        const dy = direction === 'to-top' ? box.y - other.y - other.height : box.y + box.height - other.y;
        next.calloutLabel.collisionOffsetY = dy;
      }
    };
    const avoidYCollisions = labels => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, 'to-top');
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, 'to-bottom');
      }
    };
    const avoidXCollisions = labels => {
      const labelsCollideLabelsByY = data.some(datum => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map(label => getTextBBox(label));
      const paddedBoxes = boxes.map(box => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map(datum => {
        const {
          startAngle,
          endAngle
        } = datum;
        const radius = radiusScale.convert(datum.radius);
        const outerRadius = Math.max(0, radius);
        return {
          startAngle,
          endAngle,
          innerRadius,
          outerRadius
        };
      });
      const labelsCollideSectors = boxes.some(box => {
        return sectors.some(sector => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter(datum => datum.calloutLabel.textAlign === 'center').forEach(datum => {
        const label = datum.calloutLabel;
        if (datum.midCos < 0) {
          label.collisionTextAlign = 'right';
        } else if (datum.midCos > 0) {
          label.collisionTextAlign = 'left';
        } else {
          label.collisionTextAlign = 'center';
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const {
      radiusScale,
      calloutLabel,
      calloutLine
    } = this;
    const calloutLength = calloutLine.length;
    const {
      offset,
      color
    } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(PieNodeTag.Label).forEach(text => {
      const {
        datum
      } = text;
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!(label === null || label === void 0 ? void 0 : label.text) || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      // Detect text overflow
      this.setTextDimensionalProps(tempTextNode, x, y, this.calloutLabel, label);
      const box = tempTextNode.computeBBox();
      const {
        visibleTextPart,
        textLength,
        hasVerticalOverflow
      } = this.getLabelOverflow(label.text, box, seriesRect);
      const displayText = visibleTextPart === 1 ? label.text : `${label.text.substring(0, textLength)}â¦`;
      this.setTextDimensionalProps(text, x, y, this.calloutLabel, Object.assign(Object.assign({}, label), {
        text: displayText
      }));
      text.fill = color;
      text.visible = !hasVerticalOverflow;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    var _a;
    const {
      radiusScale,
      calloutLabel,
      calloutLine
    } = this;
    const calloutLength = calloutLine.length;
    const {
      offset,
      maxCollisionOffset,
      minSpacing
    } = calloutLabel;
    this.maybeRefreshNodeData();
    this.updateRadiusScale();
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text = new Text();
    let titleBox;
    if (((_a = this.title) === null || _a === void 0 ? void 0 : _a.text) && this.title.enabled) {
      const dy = this.getTitleTranslationY();
      if (isFinite(dy)) {
        this.setTextDimensionalProps(text, 0, dy, this.title, {
          text: this.title.text,
          textBaseline: 'bottom',
          textAlign: 'center',
          hidden: false,
          collisionTextAlign: undefined,
          collisionOffsetY: 0
        });
        titleBox = text.computeBBox();
        textBoxes.push(titleBox);
      }
    }
    this.nodeData.forEach(datum => {
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label || outerRadius === 0) {
        return null;
      }
      const labelRadius = outerRadius + calloutLength + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      this.setTextDimensionalProps(text, x, y, this.calloutLabel, label);
      const box = text.computeBBox();
      label.box = box;
      // Hide labels that where pushed to far by the collision avoidance algorithm
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      // Hide labels intersecting or above the title
      if (titleBox) {
        const seriesTop = seriesRect.y - this.centerY;
        const titleCleanArea = new BBox(titleBox.x - minSpacing, seriesTop, titleBox.width + 2 * minSpacing, titleBox.y + titleBox.height + minSpacing - seriesTop);
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const {
          textLength,
          hasVerticalOverflow,
          hasSurroundingSeriesOverflow
        } = this.getLabelOverflow(label.text, box, seriesRect);
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  setTextDimensionalProps(textNode, x, y, style, label) {
    var _a, _b;
    const {
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily
    } = style;
    textNode.fontStyle = fontStyle;
    textNode.fontWeight = fontWeight;
    textNode.fontSize = fontSize;
    textNode.fontFamily = fontFamily;
    textNode.text = label.text;
    textNode.x = x;
    textNode.y = y;
    textNode.textAlign = (_b = (_a = label === null || label === void 0 ? void 0 : label.collisionTextAlign) !== null && _a !== void 0 ? _a : label === null || label === void 0 ? void 0 : label.textAlign) !== null && _b !== void 0 ? _b : 'center';
    textNode.textBaseline = label.textBaseline;
  }
  updateSectorLabelNodes() {
    const {
      radiusScale
    } = this;
    const innerRadius = radiusScale.convert(0);
    const {
      fontSize,
      fontStyle,
      fontWeight,
      fontFamily,
      positionOffset,
      positionRatio,
      color
    } = this.sectorLabel;
    const isDoughnut = innerRadius > 0;
    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;
    this.sectorLabelSelection.each((text, datum) => {
      const sectorLabel = datum.sectorLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + radius * positionRatio + positionOffset;
        text.fill = color;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        const shouldPutTextInCenter = !isDoughnut && singleVisibleSector;
        if (shouldPutTextInCenter) {
          text.x = 0;
          text.y = 0;
        } else {
          text.x = datum.midCos * labelRadius;
          text.y = datum.midSin * labelRadius;
        }
        text.textAlign = 'center';
        text.textBaseline = 'middle';
        const bbox = text.computeBBox();
        const corners = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x + bbox.width, bbox.y + bbox.height], [bbox.x, bbox.y + bbox.height]];
        const {
          startAngle,
          endAngle
        } = datum;
        const sectorBounds = {
          startAngle,
          endAngle,
          innerRadius,
          outerRadius
        };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    });
  }
  updateInnerCircle() {
    const circle = this.innerCircleNode;
    if (!circle) {
      return;
    }
    const innerRadius = this.getInnerRadius();
    if (innerRadius === 0) {
      circle.size = 0;
    } else {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      circle.size = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text, datum) => {
      const {
        fontStyle,
        fontWeight,
        fontSize,
        fontFamily,
        color
      } = datum;
      text.fontStyle = fontStyle;
      text.fontWeight = fontWeight;
      text.fontSize = fontSize;
      text.fontFamily = fontFamily;
      text.text = datum.text;
      text.x = 0;
      text.y = 0;
      text.fill = color;
      text.textAlign = 'center';
      text.textBaseline = 'alphabetic';
      textBBoxes.push(text.computeBBox());
      margins.push(datum.margin);
    });
    const getMarginTop = index => index === 0 ? 0 : margins[index];
    const getMarginBottom = index => index === margins.length - 1 ? 0 : margins[index];
    const totalHeight = textBBoxes.reduce((sum, bbox, i) => {
      return sum + bbox.height + getMarginTop(i) + getMarginBottom(i);
    }, 0);
    const totalWidth = Math.max(...textBBoxes.map(bbox => bbox.width));
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text, _datum, index) => {
      text.y = textBottoms[index];
      text.visible = labelsVisible;
    });
  }
  getNodeClickEvent(event, datum) {
    return new PieSeriesNodeClickEvent(this.angleKey, this.calloutLabelKey, this.sectorLabelKey, this.radiusKey, event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    return new PieSeriesNodeDoubleClickEvent(this.angleKey, this.calloutLabelKey, this.sectorLabelKey, this.radiusKey, event, datum, this);
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    const {
      angleKey
    } = this;
    if (!angleKey) {
      return '';
    }
    const {
      tooltip,
      angleName,
      radiusKey,
      radiusName,
      calloutLabelKey,
      sectorLabelKey,
      calloutLabelName,
      sectorLabelName,
      id: seriesId
    } = this;
    const {
      renderer: tooltipRenderer
    } = tooltip;
    const {
      datum,
      angleValue,
      radiusValue,
      sectorFormat: {
        fill: color
      },
      calloutLabel: {
        text: label = ''
      } = {}
    } = nodeDatum;
    const formattedAngleValue = typeof angleValue === 'number' ? toFixed(angleValue) : String(angleValue);
    const title = (_a = this.title) === null || _a === void 0 ? void 0 : _a.text;
    const content = `${label ? `${label}: ` : ''}${formattedAngleValue}`;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    if (tooltipRenderer) {
      return toTooltipHtml(tooltipRenderer({
        datum,
        angleKey,
        angleValue,
        angleName,
        radiusKey,
        radiusValue,
        radiusName,
        calloutLabelKey,
        calloutLabelName,
        sectorLabelKey,
        sectorLabelName,
        title,
        color,
        seriesId
      }), defaults);
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    var _a, _b, _c;
    const {
      calloutLabelKey,
      legendItemKey,
      id,
      data
    } = this;
    if (!data || data.length === 0) return [];
    if (!legendItemKey && !calloutLabelKey) return [];
    const titleText = ((_a = this.title) === null || _a === void 0 ? void 0 : _a.showInLegend) && this.title.text;
    const legendData = [];
    for (let index = 0; index < data.length; index++) {
      const datum = data[index];
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(datum, 2 * Math.PI, 2 * Math.PI, false);
      if (legendItemKey && labels.legendItem !== undefined) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && ((_b = labels.calloutLabel) === null || _b === void 0 ? void 0 : _b.text) !== undefined) {
        labelParts.push((_c = labels.calloutLabel) === null || _c === void 0 ? void 0 : _c.text);
      }
      if (labelParts.length === 0) continue;
      const sectorFormat = this.getSectorFormat(datum, index, index, false);
      legendData.push({
        legendType: 'category',
        id,
        itemId: index,
        seriesId: id,
        enabled: this.seriesItemEnabled[index],
        label: {
          text: labelParts.join(' - ')
        },
        marker: {
          fill: sectorFormat.fill,
          stroke: sectorFormat.stroke,
          fillOpacity: this.fillOpacity,
          strokeOpacity: this.strokeOpacity
        }
      });
    }
    return legendData;
  }
  onLegendItemClick(event) {
    const {
      enabled,
      itemId,
      series
    } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    } else if (series.type === 'pie') {
      this.toggleOtherSeriesItems(series, itemId, enabled);
    }
  }
  toggleSeriesItem(itemId, enabled) {
    this.seriesItemEnabled[itemId] = enabled;
    this.nodeDataRefresh = true;
  }
  toggleOtherSeriesItems(series, itemId, enabled) {
    var _a, _b;
    const {
      legendItemKey
    } = this;
    if (!legendItemKey) return;
    const datumToggledLegendItemValue = series.legendItemKey && ((_a = series.data) === null || _a === void 0 ? void 0 : _a.find((_, index) => index === itemId)[series.legendItemKey]);
    if (!datumToggledLegendItemValue) return;
    (_b = this.data) === null || _b === void 0 ? void 0 : _b.forEach((datum, datumItemId) => {
      if (datum[legendItemKey] === datumToggledLegendItemValue) {
        this.toggleSeriesItem(datumItemId, enabled);
      }
    });
  }
  animateEmptyUpdateReady() {
    const duration = 1000;
    const labelDuration = 200;
    const rotation = Math.PI / -2 + toRadians(this.rotation);
    this.groupSelection.selectByTag(PieNodeTag.Sector).forEach(node => {
      var _a;
      const datum = node.datum;
      (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animateMany(`${this.id}_empty-update-ready_${node.id}`, [{
        from: rotation,
        to: datum.startAngle
      }, {
        from: rotation,
        to: datum.endAngle
      }], {
        disableInteractions: true,
        duration,
        ease: easeOut,
        repeat: 0,
        onUpdate([startAngle, endAngle]) {
          node.startAngle = startAngle;
          node.endAngle = endAngle;
        }
      });
    });
    const labelAnimationOptions = {
      from: 0,
      to: 1,
      delay: duration,
      duration: labelDuration,
      ease: linear,
      repeat: 0
    };
    this.calloutLabelSelection.each(label => {
      var _a;
      (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, Object.assign(Object.assign({}, labelAnimationOptions), {
        onUpdate(opacity) {
          label.opacity = opacity;
        }
      }));
    });
    this.sectorLabelSelection.each(label => {
      var _a;
      (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, Object.assign(Object.assign({}, labelAnimationOptions), {
        onUpdate(opacity) {
          label.opacity = opacity;
        }
      }));
    });
    this.innerLabelsSelection.each(label => {
      var _a;
      (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, Object.assign(Object.assign({}, labelAnimationOptions), {
        onUpdate(opacity) {
          label.opacity = opacity;
        }
      }));
    });
  }
  animateReadyUpdateReady() {
    this.groupSelection.selectByTag(PieNodeTag.Sector).forEach(node => {
      const {
        datum
      } = node;
      node.startAngle = datum.startAngle;
      node.endAngle = datum.endAngle;
    });
  }
}
PieSeries.className = 'PieSeries';
PieSeries.type = 'pie';
pieSeries_decorate([Validate(STRING)], PieSeries.prototype, "angleKey", void 0);
pieSeries_decorate([Validate(STRING)], PieSeries.prototype, "angleName", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "radiusKey", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "radiusName", void 0);
pieSeries_decorate([Validate(OPT_NUMBER(0))], PieSeries.prototype, "radiusMin", void 0);
pieSeries_decorate([Validate(OPT_NUMBER(0))], PieSeries.prototype, "radiusMax", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "calloutLabelKey", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "calloutLabelName", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "sectorLabelKey", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "sectorLabelName", void 0);
pieSeries_decorate([Validate(OPT_STRING)], PieSeries.prototype, "legendItemKey", void 0);
pieSeries_decorate([Validate(COLOR_STRING_ARRAY)], PieSeries.prototype, "fills", void 0);
pieSeries_decorate([Validate(COLOR_STRING_ARRAY)], PieSeries.prototype, "strokes", void 0);
pieSeries_decorate([Validate(NUMBER(0, 1))], PieSeries.prototype, "fillOpacity", void 0);
pieSeries_decorate([Validate(NUMBER(0, 1))], PieSeries.prototype, "strokeOpacity", void 0);
pieSeries_decorate([Validate(OPT_LINE_DASH)], PieSeries.prototype, "lineDash", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeries.prototype, "lineDashOffset", void 0);
pieSeries_decorate([Validate(OPT_FUNCTION)], PieSeries.prototype, "formatter", void 0);
pieSeries_decorate([Validate(NUMBER(-360, 360))], PieSeries.prototype, "rotation", void 0);
pieSeries_decorate([Validate(NUMBER())], PieSeries.prototype, "outerRadiusOffset", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeries.prototype, "outerRadiusRatio", void 0);
pieSeries_decorate([Validate(NUMBER())], PieSeries.prototype, "innerRadiusOffset", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeries.prototype, "innerRadiusRatio", void 0);
pieSeries_decorate([Validate(NUMBER(0))], PieSeries.prototype, "strokeWidth", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/polarChart.mjs

var polarChart_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};





class PolarChart extends Chart {
  constructor(document = window.document, overrideDevicePixelRatio, resources) {
    super(document, overrideDevicePixelRatio, resources);
    this.padding = new Padding(40);
  }
  performLayout() {
    const _super = Object.create(null, {
      performLayout: {
        get: () => super.performLayout
      }
    });
    return polarChart_awaiter(this, void 0, void 0, function* () {
      const shrinkRect = yield _super.performLayout.call(this);
      const fullSeriesRect = shrinkRect.clone();
      this.computeSeriesRect(shrinkRect);
      this.computeCircle();
      const hoverRectPadding = 20;
      const hoverRect = shrinkRect.clone().grow(hoverRectPadding);
      this.hoverRect = hoverRect;
      this.layoutService.dispatchLayoutComplete({
        type: 'layout-complete',
        chart: {
          width: this.scene.width,
          height: this.scene.height
        },
        series: {
          rect: fullSeriesRect,
          paddedRect: shrinkRect,
          hoverRect,
          visible: true
        },
        axes: []
      });
      return shrinkRect;
    });
  }
  computeSeriesRect(shrinkRect) {
    const {
      seriesAreaPadding
    } = this;
    shrinkRect.shrink(seriesAreaPadding.left, 'left');
    shrinkRect.shrink(seriesAreaPadding.top, 'top');
    shrinkRect.shrink(seriesAreaPadding.right, 'right');
    shrinkRect.shrink(seriesAreaPadding.bottom, 'bottom');
    this.seriesRect = shrinkRect;
  }
  computeCircle() {
    const seriesBox = this.seriesRect;
    const polarSeries = this.series.filter(series => {
      return series instanceof PolarSeries;
    });
    const setSeriesCircle = (cx, cy, r) => {
      polarSeries.forEach(series => {
        series.centerX = cx;
        series.centerY = cy;
        series.radius = r;
      });
      const pieSeries = polarSeries.filter(series => series instanceof PieSeries);
      if (pieSeries.length > 1) {
        const innerRadii = pieSeries.map(series => {
          const innerRadius = series.getInnerRadius();
          return {
            series,
            innerRadius
          };
        }).sort((a, b) => a.innerRadius - b.innerRadius);
        innerRadii[innerRadii.length - 1].series.surroundingRadius = undefined;
        for (let i = 0; i < innerRadii.length - 1; i++) {
          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
        }
      }
    };
    const centerX = seriesBox.x + seriesBox.width / 2;
    const centerY = seriesBox.y + seriesBox.height / 2;
    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
    let radius = initialRadius;
    setSeriesCircle(centerX, centerY, radius);
    const shake = ({
      hideWhenNecessary = false
    } = {}) => {
      const labelBoxes = [];
      for (const series of polarSeries) {
        const box = series.computeLabelsBBox({
          hideWhenNecessary
        }, seriesBox);
        if (box == null) continue;
        labelBoxes.push(box);
      }
      if (labelBoxes.length === 0) {
        setSeriesCircle(centerX, centerY, initialRadius);
        return;
      }
      const labelBox = BBox.merge(labelBoxes);
      const refined = this.refineCircle(labelBox, radius);
      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
      if (refined.radius === radius) {
        return;
      }
      radius = refined.radius;
    };
    shake(); // Initial attempt
    shake(); // Precise attempt
    shake(); // Just in case
    shake({
      hideWhenNecessary: true
    }); // Hide unnecessary labels
    shake({
      hideWhenNecessary: true
    }); // Final result
  }

  refineCircle(labelsBox, radius) {
    const minCircleRatio = 0.5; // Prevents reduced circle to be too small
    const seriesBox = this.seriesRect;
    const circleLeft = -radius;
    const circleTop = -radius;
    const circleRight = radius;
    const circleBottom = radius;
    // Label padding around the circle
    let padLeft = Math.max(0, circleLeft - labelsBox.x);
    let padTop = Math.max(0, circleTop - labelsBox.y);
    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
    // Available area for the circle (after the padding will be applied)
    const availCircleWidth = seriesBox.width - padLeft - padRight;
    const availCircleHeight = seriesBox.height - padTop - padBottom;
    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
    if (newRadius < minRadius) {
      // If the radius is too small, reduce the label padding
      newRadius = minRadius;
      const horizontalPadding = padLeft + padRight;
      const verticalPadding = padTop + padBottom;
      if (2 * newRadius + verticalPadding > seriesBox.height) {
        const padHeight = seriesBox.height - 2 * newRadius;
        if (Math.min(padTop, padBottom) * 2 > padHeight) {
          padTop = padHeight / 2;
          padBottom = padHeight / 2;
        } else if (padTop > padBottom) {
          padTop = padHeight - padBottom;
        } else {
          padBottom = padHeight - padTop;
        }
      }
      if (2 * newRadius + horizontalPadding > seriesBox.width) {
        const padWidth = seriesBox.width - 2 * newRadius;
        if (Math.min(padLeft, padRight) * 2 > padWidth) {
          padLeft = padWidth / 2;
          padRight = padWidth / 2;
        } else if (padLeft > padRight) {
          padLeft = padWidth - padRight;
        } else {
          padRight = padWidth - padLeft;
        }
      }
    }
    const newWidth = padLeft + 2 * newRadius + padRight;
    const newHeight = padTop + 2 * newRadius + padBottom;
    return {
      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,
      radius: newRadius
    };
  }
}
PolarChart.className = 'PolarChart';
PolarChart.type = 'polar';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/hierarchyChart.mjs
var hierarchyChart_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};


class HierarchyChart extends Chart {
  constructor(document = window.document, overrideDevicePixelRatio, resources) {
    super(document, overrideDevicePixelRatio, resources);
    this._data = {};
  }
  performLayout() {
    const _super = Object.create(null, {
      performLayout: {
        get: () => super.performLayout
      }
    });
    return hierarchyChart_awaiter(this, void 0, void 0, function* () {
      const shrinkRect = yield _super.performLayout.call(this);
      const {
        seriesAreaPadding
      } = this;
      const fullSeriesRect = shrinkRect.clone();
      shrinkRect.shrink(seriesAreaPadding.left, 'left');
      shrinkRect.shrink(seriesAreaPadding.top, 'top');
      shrinkRect.shrink(seriesAreaPadding.right, 'right');
      shrinkRect.shrink(seriesAreaPadding.bottom, 'bottom');
      this.seriesRect = shrinkRect;
      const hoverRectPadding = 20;
      const hoverRect = shrinkRect.clone().grow(hoverRectPadding);
      this.hoverRect = hoverRect;
      yield Promise.all(this.series.map(series => hierarchyChart_awaiter(this, void 0, void 0, function* () {
        series.rootGroup.translationX = Math.floor(shrinkRect.x);
        series.rootGroup.translationY = Math.floor(shrinkRect.y);
        yield series.update({
          seriesRect: shrinkRect
        }); // this has to happen after the `updateAxes` call
      })));

      const {
        seriesRoot
      } = this;
      seriesRoot.setClipRectInGroupCoordinateSpace(new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height));
      this.layoutService.dispatchLayoutComplete({
        type: 'layout-complete',
        chart: {
          width: this.scene.width,
          height: this.scene.height
        },
        series: {
          rect: fullSeriesRect,
          paddedRect: shrinkRect,
          hoverRect,
          visible: true
        },
        axes: []
      });
      return shrinkRect;
    });
  }
}
HierarchyChart.className = 'HierarchyChart';
HierarchyChart.type = 'hierarchy';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/string.mjs

const interpolatePattern = /(#\{(.*?)\})/g;
function interpolate(input, values, formats) {
  return input.replace(interpolatePattern, function (...args) {
    const name = args[2];
    const [valueName, formatName] = name.split(':');
    const value = values[valueName];
    if (typeof value === 'number') {
      const format = formatName && formats && formats[formatName];
      if (format) {
        const {
          locales,
          options
        } = format;
        return value.toLocaleString(locales, options);
      }
      return String(value);
    }
    if (value instanceof Date) {
      const format = formatName && formats && formats[formatName];
      if (typeof format === 'string') {
        const formatter = buildFormatter(format);
        return formatter(value);
      }
      return value.toDateString();
    }
    if (typeof value === 'string' || (value === null || value === void 0 ? void 0 : value.toString)) {
      return String(value);
    }
    return '';
  });
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/sanitize.mjs
let sanitize_element = null;
function sanitizeHtml(text) {
  sanitize_element = sanitize_element !== null && sanitize_element !== void 0 ? sanitize_element : document.createElement('div');
  if (!text) {
    return '';
  }
  sanitize_element.textContent = text;
  return sanitize_element.innerHTML;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/secondaryAxisTicks.mjs

function calculateNiceSecondaryAxis(domain, primaryTickCount) {
  // Make secondary axis domain nice using strict tick count, matching the tick count from the primary axis.
  // This is to make the secondary axis grid lines/ tick positions align with the ones from the primary axis.
  let start = Math.floor(domain[0]);
  let stop = domain[1];
  start = calculateNiceStart(start, stop, primaryTickCount);
  const step = getTickStep(start, stop, primaryTickCount);
  const segments = primaryTickCount - 1;
  stop = start + segments * step;
  const d = [start, stop];
  const ticks = getTicks(start, step, primaryTickCount);
  return [d, ticks];
}
function calculateNiceStart(a, b, count) {
  const rawStep = Math.abs(b - a) / (count - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start, step, count) {
  // power of the step will be negative if the step is a fraction (between 0 and 1)
  const stepPower = Math.floor(Math.log10(step));
  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;
  const f = Math.pow(10, fractionDigits);
  const ticks = new NumericTicks(fractionDigits);
  for (let i = 0; i < count; i++) {
    const tick = start + step * i;
    ticks[i] = Math.round(tick * f) / f;
  }
  return ticks;
}
function getTickStep(start, stop, count) {
  const segments = count - 1;
  const rawStep = (stop - start) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  // Make order 1
  const step = rawStep / magnitude * 10;
  if (step > 0 && step <= 1) {
    return magnitude / 10;
  }
  if (step > 1 && step <= 2) {
    return 2 * magnitude / 10;
  }
  if (step > 1 && step <= 5) {
    return 5 * magnitude / 10;
  }
  if (step > 5 && step <= 10) {
    return 10 * magnitude / 10;
  }
  if (step > 10 && step <= 20) {
    return 20 * magnitude / 10;
  }
  if (step > 20 && step <= 40) {
    return 40 * magnitude / 10;
  }
  if (step > 40 && step <= 50) {
    return 50 * magnitude / 10;
  }
  if (step > 50 && step <= 100) {
    return 100 * magnitude / 10;
  }
  return step;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/axis/numberAxis.mjs
var numberAxis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};








class NumberAxisTick extends BaseAxisTick {
  constructor() {
    super(...arguments);
    this.maxSpacing = NaN;
  }
}
numberAxis_decorate([Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))), Default(NaN)], NumberAxisTick.prototype, "maxSpacing", void 0);
class NumberAxis extends ChartAxis {
  constructor(moduleCtx, scale = new LinearScale()) {
    super(moduleCtx, scale);
    this.min = NaN;
    this.max = NaN;
    scale.strictClampByDefault = true;
  }
  normaliseDataDomain(d) {
    var _a;
    const {
      min,
      max
    } = this;
    if (d.length > 2) {
      d = (_a = extent(d)) !== null && _a !== void 0 ? _a : [NaN, NaN];
    }
    if (!isNaN(min)) {
      d = [min, d[1]];
    }
    if (!isNaN(max)) {
      d = [d[0], max];
    }
    if (d[0] > d[1]) {
      d = [];
    }
    return d;
  }
  formatDatum(datum) {
    if (typeof datum === 'number') {
      return datum.toFixed(2);
    } else {
      Logger.warnOnce('data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers.');
      return String(datum);
    }
  }
  createTick() {
    return new NumberAxisTick();
  }
  updateSecondaryAxisTicks(primaryTickCount) {
    if (this.dataDomain == null) {
      throw new Error('AG Charts - dataDomain not calculated, cannot perform tick calculation.');
    }
    const [d, ticks] = calculateNiceSecondaryAxis(this.dataDomain, primaryTickCount !== null && primaryTickCount !== void 0 ? primaryTickCount : 0);
    this.scale.nice = false;
    this.scale.domain = d;
    this.scale.update();
    return ticks;
  }
}
NumberAxis.className = 'NumberAxis';
NumberAxis.type = 'number';
numberAxis_decorate([Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'))), Default(NaN)], NumberAxis.prototype, "min", void 0);
numberAxis_decorate([Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'))), Default(NaN)], NumberAxis.prototype, "max", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/axis/logAxis.mjs
var logAxis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






function NON_ZERO_NUMBER() {
  // Cannot be 0
  const message = `expecting a non-zero Number`;
  return predicateWithMessage(v => typeof v === 'number' && v !== 0, message);
}
class LogAxis extends NumberAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LogScale());
    this.min = NaN;
    this.max = NaN;
    this.scale.strictClampByDefault = true;
  }
  normaliseDataDomain(d) {
    var _a;
    const {
      min,
      max
    } = this;
    if (d.length > 2) {
      d = (_a = extent(d)) !== null && _a !== void 0 ? _a : [NaN, NaN];
    }
    if (!isNaN(min)) {
      d = [min, d[1]];
    }
    if (!isNaN(max)) {
      d = [d[0], max];
    }
    const isInverted = d[0] > d[1];
    const crossesZero = d[0] < 0 && d[1] > 0;
    const hasZeroExtent = d[0] === 0 && d[1] === 0;
    const invalidDomain = isInverted || crossesZero || hasZeroExtent;
    if (invalidDomain) {
      d = [];
      if (crossesZero) {
        Logger.warn(`the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`);
      } else if (hasZeroExtent) {
        Logger.warn(`the data domain has 0 extent, no data is rendered.`);
      }
    }
    if (d[0] === 0) {
      d[0] = 1;
    }
    if (d[1] === 0) {
      d[1] = -1;
    }
    return d;
  }
  set base(value) {
    this.scale.base = value;
  }
  get base() {
    return this.scale.base;
  }
}
LogAxis.className = 'LogAxis';
LogAxis.type = 'log';
logAxis_decorate([Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'), NON_ZERO_NUMBER())), Default(NaN)], LogAxis.prototype, "min", void 0);
logAxis_decorate([Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'), NON_ZERO_NUMBER())), Default(NaN)], LogAxis.prototype, "max", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/axis/timeAxis.mjs
var timeAxis_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class TimeAxisTick extends BaseAxisTick {
  constructor() {
    super(...arguments);
    this.maxSpacing = NaN;
  }
}
timeAxis_decorate([Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))), Default(NaN)], TimeAxisTick.prototype, "maxSpacing", void 0);
class TimeAxis extends ChartAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new TimeScale());
    this.datumFormat = '%m/%d/%y, %H:%M:%S';
    this.min = undefined;
    this.max = undefined;
    const {
      scale
    } = this;
    scale.strictClampByDefault = true;
    this.refreshScale();
    this.datumFormatter = scale.tickFormat({
      specifier: this.datumFormat
    });
  }
  normaliseDataDomain(d) {
    var _a;
    let {
      min,
      max
    } = this;
    if (typeof min === 'number') {
      min = new Date(min);
    }
    if (typeof max === 'number') {
      max = new Date(max);
    }
    if (d.length > 2) {
      d = ((_a = extent(d)) !== null && _a !== void 0 ? _a : [0, 1000]).map(x => new Date(x));
    }
    if (min instanceof Date) {
      d = [min, d[1]];
    }
    if (max instanceof Date) {
      d = [d[0], max];
    }
    if (d[0] > d[1]) {
      d = [];
    }
    return d;
  }
  createTick() {
    return new TimeAxisTick();
  }
  onLabelFormatChange(ticks, format) {
    if (format) {
      super.onLabelFormatChange(ticks, format);
    } else {
      // For time axis labels to look nice, even if date format wasn't set.
      this.labelFormatter = this.scale.tickFormat({
        ticks
      });
    }
  }
  formatDatum(datum) {
    var _a;
    return (_a = this.moduleCtx.callbackCache.call(this.datumFormatter, datum)) !== null && _a !== void 0 ? _a : String(datum);
  }
  calculatePadding(_min, _max) {
    // numbers in domain correspond to Unix timestamps
    // automatically expand domain by 1 in each direction
    return 1;
  }
}
TimeAxis.className = 'TimeAxis';
TimeAxis.type = 'time';
timeAxis_decorate([Validate(AND(OPT_DATE_OR_DATETIME_MS, LESS_THAN('max')))], TimeAxis.prototype, "min", void 0);
timeAxis_decorate([Validate(AND(OPT_DATE_OR_DATETIME_MS, GREATER_THAN('min')))], TimeAxis.prototype, "max", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/areaSeries.mjs

var areaSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var areaSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




















class AreaSeriesLabel extends Label {
  constructor() {
    super(...arguments);
    this.formatter = undefined;
  }
}
areaSeries_decorate([Validate(OPT_FUNCTION)], AreaSeriesLabel.prototype, "formatter", void 0);
class AreaSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
    this.format = undefined;
  }
}
areaSeries_decorate([Validate(OPT_FUNCTION)], AreaSeriesTooltip.prototype, "renderer", void 0);
areaSeries_decorate([Validate(OPT_STRING)], AreaSeriesTooltip.prototype, "format", void 0);
var AreaSeriesTag;
(function (AreaSeriesTag) {
  AreaSeriesTag[AreaSeriesTag["Fill"] = 0] = "Fill";
  AreaSeriesTag[AreaSeriesTag["Stroke"] = 1] = "Stroke";
  AreaSeriesTag[AreaSeriesTag["Marker"] = 2] = "Marker";
  AreaSeriesTag[AreaSeriesTag["Label"] = 3] = "Label";
})(AreaSeriesTag || (AreaSeriesTag = {}));
class AreaSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pathsPerSeries: 2,
      pathsZIndexSubOrderOffset: [0, 1000],
      hasMarkers: true,
      directionKeys: {
        [ChartAxisDirection.X]: ['xKey'],
        [ChartAxisDirection.Y]: ['yKeys']
      },
      directionNames: {
        [ChartAxisDirection.X]: ['xName'],
        [ChartAxisDirection.Y]: ['yNames']
      }
    });
    this.tooltip = new AreaSeriesTooltip();
    this.marker = new CartesianSeriesMarker();
    this.label = new AreaSeriesLabel();
    this.fills = ['#c16068', '#a2bf8a', '#ebcc87', '#80a0c3', '#b58dae', '#85c0d1'];
    this.strokes = ['#874349', '#718661', '#a48f5f', '#5a7088', '#7f637a', '#5d8692'];
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.xKey = undefined;
    this.xName = undefined;
    this._yKeys = [];
    this._visibles = [];
    this.yNames = [];
    this.strokeWidth = 2;
    this.shadow = undefined;
    const {
      marker,
      label
    } = this;
    marker.enabled = false;
    label.enabled = false;
  }
  set yKeys(values) {
    if (!areArrayItemsStrictlyEqual(this._yKeys, values)) {
      this._yKeys = values;
      this.processedData = undefined;
      this.processSeriesItemEnabled();
    }
  }
  get yKeys() {
    return this._yKeys;
  }
  set visibles(visibles) {
    this._visibles = visibles;
    this.processSeriesItemEnabled();
  }
  get visibles() {
    return this._visibles;
  }
  processSeriesItemEnabled() {
    const {
      seriesItemEnabled,
      _visibles: visibles = []
    } = this;
    seriesItemEnabled.clear();
    this._yKeys.forEach((key, idx) => {
      var _a;
      return seriesItemEnabled.set(key, (_a = visibles[idx]) !== null && _a !== void 0 ? _a : true);
    });
  }
  set normalizedTo(value) {
    const absValue = value ? Math.abs(value) : undefined;
    if (this._normalizedTo !== absValue) {
      this._normalizedTo = absValue;
    }
  }
  get normalizedTo() {
    return this._normalizedTo;
  }
  processData() {
    return areaSeries_awaiter(this, void 0, void 0, function* () {
      const {
        xKey,
        yKeys,
        seriesItemEnabled,
        xAxis,
        yAxis,
        normalizedTo
      } = this;
      const data = xKey && yKeys.length && this.data ? this.data : [];
      const isContinuousX = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale) instanceof ContinuousScale;
      const isContinuousY = (yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale) instanceof ContinuousScale;
      const enabledYKeys = [...seriesItemEnabled.entries()].filter(([, enabled]) => enabled).map(([yKey]) => yKey);
      const normaliseTo = normalizedTo && isFinite(normalizedTo) ? normalizedTo : undefined;
      const extraProps = [];
      if (normaliseTo) {
        extraProps.push(normaliseGroupTo(enabledYKeys, normaliseTo, 'sum'));
      }
      this.dataModel = new DataModel({
        props: [keyProperty(xKey, isContinuousX, {
          id: 'xValue'
        }), ...enabledYKeys.map(yKey => valueProperty(yKey, isContinuousY, {
          id: `yValue-${yKey}`,
          missingValue: NaN,
          invalidValue: undefined
        })), sum(enabledYKeys), ...extraProps],
        groupByKeys: true,
        dataVisible: this.visible && enabledYKeys.length > 0
      });
      this.processedData = this.dataModel.processData(data);
    });
  }
  getDomain(direction) {
    const {
      processedData,
      xAxis,
      yAxis
    } = this;
    if (!processedData) return [];
    const {
      defs: {
        keys: [keyDef]
      },
      domain: {
        keys: [keys],
        values: [yExtent],
        aggValues: [ySumExtent] = []
      }
    } = processedData;
    if (direction === ChartAxisDirection.X) {
      if (keyDef.valueType === 'category') {
        return keys;
      }
      return this.fixNumericExtent(extent(keys), xAxis);
    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
      return this.fixNumericExtent(yExtent, yAxis);
    } else {
      return this.fixNumericExtent(ySumExtent, yAxis);
    }
  }
  createNodeData() {
    var _a;
    return areaSeries_awaiter(this, void 0, void 0, function* () {
      const {
        xAxis,
        yAxis,
        data,
        processedData: {
          data: groupedData
        } = {},
        ctx: {
          callbackCache
        }
      } = this;
      if (!xAxis || !yAxis || !data) {
        return [];
      }
      const contexts = [];
      const {
        yKeys,
        xKey = '',
        marker,
        label,
        fills,
        strokes,
        id: seriesId
      } = this;
      const {
        scale: xScale
      } = xAxis;
      const {
        scale: yScale
      } = yAxis;
      const continuousY = yScale instanceof ContinuousScale;
      const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;
      const xDataCount = data.length;
      const cumulativePathValues = new Array(xDataCount).fill(null).map(() => ({
        left: 0,
        right: 0
      }));
      const cumulativeMarkerValues = new Array(xDataCount).fill(0);
      const createPathCoordinates = (xDatum, yDatum, idx, side) => {
        const x = xScale.convert(xDatum) + xOffset;
        const prevY = cumulativePathValues[idx][side];
        const currY = cumulativePathValues[idx][side] + yDatum;
        const prevYCoordinate = yScale.convert(prevY, {
          strict: false
        });
        const currYCoordinate = yScale.convert(currY, {
          strict: false
        });
        cumulativePathValues[idx][side] = currY;
        return [{
          x,
          y: currYCoordinate,
          size: marker.size
        }, {
          x,
          y: prevYCoordinate,
          size: marker.size
        }];
      };
      const createMarkerCoordinate = (xDatum, yDatum, idx, rawYDatum) => {
        let currY;
        // if not normalized, the invalid data points will be processed as `undefined` in processData()
        // if normalized, the invalid data points will be processed as 0 rather than `undefined`
        // check if unprocessed datum is valid as we only want to show markers for valid points
        const normalized = this.normalizedTo && isFinite(this.normalizedTo);
        const normalizedAndValid = normalized && continuousY && isContinuous(rawYDatum);
        const valid = !normalized && !isNaN(rawYDatum) || normalizedAndValid;
        if (valid) {
          currY = cumulativeMarkerValues[idx] += yDatum;
        }
        const x = xScale.convert(xDatum) + xOffset;
        const y = yScale.convert(currY, {
          strict: false
        });
        return {
          x,
          y,
          size: marker.size
        };
      };
      yKeys.forEach((yKey, seriesIdx) => {
        var _a;
        const yKeyDataIndex = (_a = this.dataModel) === null || _a === void 0 ? void 0 : _a.resolveProcessedDataIndexById(`yValue-${yKey}`);
        const labelSelectionData = [];
        const markerSelectionData = [];
        const strokeSelectionData = {
          itemId: yKey,
          points: [],
          yValues: []
        };
        const fillSelectionData = {
          itemId: yKey,
          points: []
        };
        contexts[seriesIdx] = {
          itemId: yKey,
          fillSelectionData,
          labelData: labelSelectionData,
          nodeData: markerSelectionData,
          strokeSelectionData
        };
        if (!yKeyDataIndex) {
          return;
        }
        const fillPoints = fillSelectionData.points;
        const fillPhantomPoints = [];
        const strokePoints = strokeSelectionData.points;
        const yValues = strokeSelectionData.yValues;
        let datumIdx = -1;
        groupedData === null || groupedData === void 0 ? void 0 : groupedData.forEach((datumGroup, dataIdx) => {
          const {
            keys: [xDatum],
            datum: datumArray,
            values: valuesArray
          } = datumGroup;
          valuesArray.forEach((values, valueIdx) => {
            var _a;
            datumIdx++;
            const seriesDatum = datumArray[valueIdx];
            const rawYDatum = values[yKeyDataIndex.index];
            const yDatum = isNaN(rawYDatum) ? undefined : rawYDatum;
            const nextValuesSameGroup = valueIdx < valuesArray.length - 1;
            const nextDatumGroup = nextValuesSameGroup ? datumGroup : groupedData[dataIdx + 1];
            const nextXDatum = nextDatumGroup === null || nextDatumGroup === void 0 ? void 0 : nextDatumGroup.keys[0];
            const rawNextYIdx = nextValuesSameGroup ? valueIdx + 1 : 0;
            const rawNextYDatum = nextDatumGroup === null || nextDatumGroup === void 0 ? void 0 : nextDatumGroup.values[rawNextYIdx][yKeyDataIndex.index];
            const nextYDatum = isNaN(rawNextYDatum) ? undefined : rawNextYDatum;
            // marker data
            const point = createMarkerCoordinate(xDatum, +yDatum, datumIdx, seriesDatum[yKey]);
            if (marker) {
              markerSelectionData.push({
                index: datumIdx,
                series: this,
                itemId: yKey,
                datum: seriesDatum,
                nodeMidPoint: {
                  x: point.x,
                  y: point.y
                },
                cumulativeValue: cumulativeMarkerValues[datumIdx],
                yValue: yDatum,
                yKey,
                xKey,
                point,
                fill: fills[seriesIdx % fills.length],
                stroke: strokes[seriesIdx % strokes.length]
              });
            }
            // label data
            let labelText;
            if (label.formatter) {
              labelText = (_a = callbackCache.call(label.formatter, {
                value: yDatum,
                seriesId
              })) !== null && _a !== void 0 ? _a : '';
            } else {
              labelText = isNumber(yDatum) ? Number(yDatum).toFixed(2) : String(yDatum);
            }
            if (label) {
              labelSelectionData.push({
                index: datumIdx,
                itemId: yKey,
                point,
                label: labelText ? {
                  text: labelText,
                  fontStyle: label.fontStyle,
                  fontWeight: label.fontWeight,
                  fontSize: label.fontSize,
                  fontFamily: label.fontFamily,
                  textAlign: 'center',
                  textBaseline: 'bottom',
                  fill: label.color
                } : undefined
              });
            }
            // fill data
            // Handle data in pairs of current and next x and y values
            const windowX = [xDatum, nextXDatum];
            const windowY = [yDatum, nextYDatum];
            if (windowX.some(v => v == undefined)) {
              return;
            }
            if (windowY.some(v => v == undefined)) {
              windowY[0] = 0;
              windowY[1] = 0;
            }
            const currCoordinates = createPathCoordinates(windowX[0], +windowY[0], datumIdx, 'right');
            fillPoints.push(currCoordinates[0]);
            fillPhantomPoints.push(currCoordinates[1]);
            const nextCoordinates = createPathCoordinates(windowX[1], +windowY[1], datumIdx, 'left');
            fillPoints.push(nextCoordinates[0]);
            fillPhantomPoints.push(nextCoordinates[1]);
            // stroke data
            strokePoints.push({
              x: NaN,
              y: NaN
            }); // moveTo
            yValues.push(undefined);
            strokePoints.push(currCoordinates[0]);
            yValues.push(yDatum);
            if (nextYDatum !== undefined) {
              strokePoints.push(nextCoordinates[0]);
              yValues.push(yDatum);
            }
          });
        });
        for (let i = fillPhantomPoints.length - 1; i >= 0; i--) {
          fillPoints.push(fillPhantomPoints[i]);
        }
      });
      return contexts;
    });
  }
  isPathOrSelectionDirty() {
    return this.marker.isDirty();
  }
  markerFactory() {
    const {
      shape
    } = this.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updateMarkerSelection(opts) {
    return areaSeries_awaiter(this, void 0, void 0, function* () {
      const {
        nodeData,
        markerSelection
      } = opts;
      const {
        marker: {
          enabled
        }
      } = this;
      const data = enabled && nodeData ? nodeData : [];
      if (this.marker.isDirty()) {
        markerSelection.clear();
      }
      return markerSelection.update(data, marker => {
        marker.tag = AreaSeriesTag.Marker;
      });
    });
  }
  updateMarkerNodes(opts) {
    var _a;
    return areaSeries_awaiter(this, void 0, void 0, function* () {
      const {
        markerSelection,
        isHighlight: isDatumHighlighted
      } = opts;
      const {
        id: seriesId,
        xKey = '',
        marker,
        seriesItemEnabled,
        yKeys,
        fills,
        strokes,
        fillOpacity: seriesFillOpacity,
        marker: {
          fillOpacity: markerFillOpacity = seriesFillOpacity
        },
        strokeOpacity,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            fillOpacity: highlightFillOpacity = markerFillOpacity,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth
          }
        },
        ctx: {
          callbackCache
        }
      } = this;
      const {
        size,
        formatter
      } = marker;
      const markerStrokeWidth = (_a = marker.strokeWidth) !== null && _a !== void 0 ? _a : this.strokeWidth;
      const customMarker = typeof marker.shape === 'function';
      markerSelection.each((node, datum) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const yKeyIndex = yKeys.indexOf(datum.yKey);
        const fill = isDatumHighlighted && highlightedFill !== undefined ? highlightedFill : (_a = marker.fill) !== null && _a !== void 0 ? _a : fills[yKeyIndex % fills.length];
        const fillOpacity = isDatumHighlighted ? highlightFillOpacity : markerFillOpacity;
        const stroke = isDatumHighlighted && highlightedStroke !== undefined ? highlightedStroke : (_b = marker.stroke) !== null && _b !== void 0 ? _b : strokes[yKeyIndex % fills.length];
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined ? highlightedDatumStrokeWidth : markerStrokeWidth;
        let format = undefined;
        if (formatter) {
          format = callbackCache.call(formatter, {
            datum: datum.datum,
            xKey,
            yKey: datum.yKey,
            fill,
            stroke,
            strokeWidth,
            size,
            highlighted: isDatumHighlighted,
            seriesId
          });
        }
        node.fill = (_c = format === null || format === void 0 ? void 0 : format.fill) !== null && _c !== void 0 ? _c : fill;
        node.stroke = (_d = format === null || format === void 0 ? void 0 : format.stroke) !== null && _d !== void 0 ? _d : stroke;
        node.strokeWidth = (_e = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _e !== void 0 ? _e : strokeWidth;
        node.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;
        node.strokeOpacity = (_g = (_f = marker.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity) !== null && _g !== void 0 ? _g : 1;
        node.size = (_h = format === null || format === void 0 ? void 0 : format.size) !== null && _h !== void 0 ? _h : size;
        node.translationX = datum.point.x;
        node.translationY = datum.point.y;
        node.visible = node.size > 0 && !!seriesItemEnabled.get(datum.yKey) && !isNaN(datum.point.x) && !isNaN(datum.point.y);
        if (!customMarker || node.dirtyPath) {
          return;
        }
        // Only for custom marker shapes
        node.path.clear({
          trackChanges: true
        });
        node.updatePath();
        node.checkPathDirty();
      });
      if (!isDatumHighlighted) {
        this.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return areaSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelData,
        labelSelection
      } = opts;
      return labelSelection.update(labelData, text => {
        text.tag = AreaSeriesTag.Label;
      });
    });
  }
  updateLabelNodes(opts) {
    return areaSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelSelection
      } = opts;
      const {
        enabled: labelEnabled,
        fontStyle,
        fontWeight,
        fontSize,
        fontFamily,
        color
      } = this.label;
      labelSelection.each((text, datum) => {
        const {
          point,
          label
        } = datum;
        if (label && labelEnabled) {
          text.fontStyle = fontStyle;
          text.fontWeight = fontWeight;
          text.fontSize = fontSize;
          text.fontFamily = fontFamily;
          text.textAlign = label.textAlign;
          text.textBaseline = label.textBaseline;
          text.text = label.text;
          text.x = point.x;
          text.y = point.y - 10;
          text.fill = color;
          text.visible = true;
        } else {
          text.visible = false;
        }
      });
    });
  }
  getNodeClickEvent(event, datum) {
    var _a;
    return new CartesianSeriesNodeClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', datum.yKey, event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    var _a;
    return new CartesianSeriesNodeDoubleClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', datum.yKey, event, datum, this);
  }
  getTooltipHtml(nodeDatum) {
    var _a, _b, _c, _d;
    const {
      xKey,
      id: seriesId
    } = this;
    const {
      yKey
    } = nodeDatum;
    const yKeyDataIndex = (_a = this.dataModel) === null || _a === void 0 ? void 0 : _a.resolveProcessedDataIndexById(`yValue-${yKey}`);
    if (!(xKey && yKey) || !yKeyDataIndex) {
      return '';
    }
    const datum = nodeDatum.datum;
    const xValue = datum[xKey];
    const yValue = datum[yKey];
    const {
      xAxis,
      yAxis,
      yKeys
    } = this;
    if (!(xAxis && yAxis && isNumber(yValue)) || !yKeyDataIndex) {
      return '';
    }
    const {
      xName,
      yNames,
      fills,
      strokes,
      tooltip,
      marker
    } = this;
    const {
      size,
      formatter: markerFormatter,
      strokeWidth: markerStrokeWidth,
      fill: markerFill,
      stroke: markerStroke
    } = marker;
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const yKeyIndex = yKeys.indexOf(yKey);
    const processedYValue = (_c = (_b = this.processedData) === null || _b === void 0 ? void 0 : _b.data[nodeDatum.index]) === null || _c === void 0 ? void 0 : _c.values[0][yKeyDataIndex === null || yKeyDataIndex === void 0 ? void 0 : yKeyDataIndex.index];
    const yName = yNames[yKeyIndex];
    const title = sanitizeHtml(yName);
    const content = sanitizeHtml(xString + ': ' + yString);
    const strokeWidth = markerStrokeWidth !== null && markerStrokeWidth !== void 0 ? markerStrokeWidth : this.strokeWidth;
    const fill = markerFill !== null && markerFill !== void 0 ? markerFill : fills[yKeyIndex % fills.length];
    const stroke = markerStroke !== null && markerStroke !== void 0 ? markerStroke : strokes[yKeyIndex % fills.length];
    let format = undefined;
    if (markerFormatter) {
      format = markerFormatter({
        datum,
        xKey,
        yKey,
        fill,
        stroke,
        strokeWidth,
        size,
        highlighted: false,
        seriesId
      });
    }
    const color = (_d = format === null || format === void 0 ? void 0 : format.fill) !== null && _d !== void 0 ? _d : fill;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    const {
      renderer: tooltipRenderer,
      format: tooltipFormat
    } = tooltip;
    if (tooltipFormat || tooltipRenderer) {
      const params = {
        datum,
        xKey,
        xName,
        xValue,
        yKey,
        yValue,
        processedYValue,
        yName,
        color,
        title,
        seriesId
      };
      if (tooltipFormat) {
        return toTooltipHtml({
          content: interpolate(tooltipFormat, params)
        }, defaults);
      }
      if (tooltipRenderer) {
        return toTooltipHtml(tooltipRenderer(params), defaults);
      }
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    var _a, _b, _c, _d, _e;
    const {
      data,
      id,
      xKey,
      yKeys,
      yNames,
      seriesItemEnabled,
      marker,
      fills,
      strokes,
      fillOpacity,
      strokeOpacity
    } = this;
    if (!(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKeys.length) {
      return [];
    }
    const legendData = [];
    // Area stacks should be listed in the legend in reverse order, for symmetry with the
    // vertical stack display order.
    for (let index = yKeys.length - 1; index >= 0; index--) {
      const yKey = yKeys[index];
      legendData.push({
        legendType: 'category',
        id,
        itemId: yKey,
        seriesId: id,
        enabled: (_a = seriesItemEnabled.get(yKey)) !== null && _a !== void 0 ? _a : false,
        label: {
          text: yNames[index] || yKeys[index]
        },
        marker: {
          shape: marker.shape,
          fill: (_b = marker.fill) !== null && _b !== void 0 ? _b : fills[index % fills.length],
          stroke: (_c = marker.stroke) !== null && _c !== void 0 ? _c : strokes[index % strokes.length],
          fillOpacity: (_d = marker.fillOpacity) !== null && _d !== void 0 ? _d : fillOpacity,
          strokeOpacity: (_e = marker.strokeOpacity) !== null && _e !== void 0 ? _e : strokeOpacity
        }
      });
    }
    return legendData;
  }
  onLegendItemDoubleClick(event) {
    const {
      enabled,
      itemId,
      series,
      numVisibleItems
    } = event;
    const newEnableds = {};
    const totalVisibleItems = Object.values(numVisibleItems).reduce((p, v) => p + v, 0);
    const singleEnabledWasClicked = totalVisibleItems === 1 && enabled;
    if (series.id === this.id) {
      const singleEnabledInEachSeries = Object.values(numVisibleItems).filter(v => v === 1).length === Object.keys(numVisibleItems).length;
      this.yKeys.forEach(yKey => {
        var _a;
        const matches = yKey === itemId;
        const newEnabled = matches || singleEnabledWasClicked || singleEnabledInEachSeries && enabled;
        newEnableds[yKey] = (_a = newEnableds[yKey]) !== null && _a !== void 0 ? _a : newEnabled;
      });
    } else {
      this.yKeys.forEach(yKey => {
        newEnableds[yKey] = singleEnabledWasClicked;
      });
    }
    Object.keys(newEnableds).forEach(yKey => {
      super.toggleSeriesItem(yKey, newEnableds[yKey]);
    });
  }
  animateEmptyUpdateReady({
    markerSelections,
    labelSelections,
    contextData,
    paths,
    seriesRect
  }) {
    const {
      strokes,
      fills,
      fillOpacity,
      lineDash,
      lineDashOffset,
      strokeOpacity,
      strokeWidth,
      shadow
    } = this;
    contextData.forEach(({
      fillSelectionData,
      strokeSelectionData,
      itemId
    }, seriesIdx) => {
      var _a, _b, _c;
      const [fill, stroke] = paths[seriesIdx];
      const duration = 1000;
      const markerDuration = 200;
      const animationOptions = {
        from: 0,
        to: (_a = seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width) !== null && _a !== void 0 ? _a : 0,
        disableInteractions: true,
        duration,
        ease: linear,
        repeat: 0
      };
      // Stroke
      {
        const {
          points,
          yValues
        } = strokeSelectionData;
        stroke.tag = AreaSeriesTag.Stroke;
        stroke.fill = undefined;
        stroke.lineJoin = stroke.lineCap = 'round';
        stroke.pointerEvents = PointerEvents.None;
        stroke.stroke = strokes[seriesIdx % strokes.length];
        stroke.strokeWidth = this.getStrokeWidth(this.strokeWidth, {
          itemId
        });
        stroke.strokeOpacity = strokeOpacity;
        stroke.lineDash = lineDash;
        stroke.lineDashOffset = lineDashOffset;
        (_b = this.animationManager) === null || _b === void 0 ? void 0 : _b.animate(`${this.id}_empty-update-ready_stroke_${seriesIdx}`, Object.assign(Object.assign({}, animationOptions), {
          onUpdate(xValue) {
            stroke.path.clear({
              trackChanges: true
            });
            let moveTo = true;
            points.forEach((point, index) => {
              // Draw/move the full segment if past the end of this segment
              if (yValues[index] === undefined || isNaN(point.x) || isNaN(point.y)) {
                moveTo = true;
              } else if (point.x <= xValue) {
                if (moveTo) {
                  stroke.path.moveTo(point.x, point.y);
                  moveTo = false;
                } else {
                  stroke.path.lineTo(point.x, point.y);
                }
              } else if (index > 0 && yValues[index] !== undefined && yValues[index - 1] !== undefined && points[index - 1].x <= xValue) {
                // Draw/move partial line if in between the start and end of this segment
                const start = points[index - 1];
                const end = point;
                const x = xValue;
                const y = start.y + (x - start.x) * (end.y - start.y) / (end.x - start.x);
                stroke.path.lineTo(x, y);
              }
            });
            stroke.checkPathDirty();
          }
        }));
      }
      // Fill
      {
        const {
          points: allPoints
        } = fillSelectionData;
        const points = allPoints.slice(0, allPoints.length / 2);
        const bottomPoints = allPoints.slice(allPoints.length / 2);
        fill.tag = AreaSeriesTag.Fill;
        fill.stroke = undefined;
        fill.lineJoin = 'round';
        fill.pointerEvents = PointerEvents.None;
        fill.fill = fills[seriesIdx % fills.length];
        fill.fillOpacity = fillOpacity;
        fill.strokeOpacity = strokeOpacity;
        fill.strokeWidth = strokeWidth;
        fill.lineDash = lineDash;
        fill.lineDashOffset = lineDashOffset;
        fill.fillShadow = shadow;
        (_c = this.animationManager) === null || _c === void 0 ? void 0 : _c.animate(`${this.id}_empty-update-ready_fill_${seriesIdx}`, Object.assign(Object.assign({}, animationOptions), {
          onUpdate(xValue) {
            fill.path.clear({
              trackChanges: true
            });
            let x = 0;
            let y = 0;
            points.forEach((point, index) => {
              if (point.x <= xValue) {
                // Draw/move the full segment if past the end of this segment
                x = point.x;
                y = point.y;
                fill.path.lineTo(point.x, point.y);
              } else if (index > 0 && points[index - 1].x < xValue) {
                // Draw/move partial line if in between the start and end of this segment
                const start = points[index - 1];
                const end = point;
                x = xValue;
                y = start.y + (x - start.x) * (end.y - start.y) / (end.x - start.x);
                fill.path.lineTo(x, y);
              }
            });
            bottomPoints.forEach((point, index) => {
              const reverseIndex = bottomPoints.length - index - 1;
              if (point.x <= xValue) {
                fill.path.lineTo(point.x, point.y);
              } else if (reverseIndex > 0 && points[reverseIndex - 1].x < xValue) {
                const start = point;
                const end = bottomPoints[index + 1];
                const bottomY = start.y + (x - start.x) * (end.y - start.y) / (end.x - start.x);
                fill.path.lineTo(x, bottomY);
              }
            });
            if (bottomPoints.length > 0) {
              fill.path.lineTo(bottomPoints[bottomPoints.length - 1].x, bottomPoints[bottomPoints.length - 1].y);
            }
            fill.path.closePath();
            fill.checkPathDirty();
          }
        }));
      }
      markerSelections[seriesIdx].each((marker, datum) => {
        var _a, _b, _c, _d;
        const delay = (seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width) ? datum.point.x / seriesRect.width * duration : 0;
        const format = this.animateFormatter(datum);
        const size = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        (_c = this.animationManager) === null || _c === void 0 ? void 0 : _c.animate(`${this.id}_empty-update-ready_${marker.id}`, Object.assign(Object.assign({}, animationOptions), {
          to: (_d = format === null || format === void 0 ? void 0 : format.size) !== null && _d !== void 0 ? _d : size,
          delay,
          duration: markerDuration,
          onUpdate(size) {
            marker.size = size;
          }
        }));
      });
      labelSelections[seriesIdx].each((label, datum) => {
        var _a;
        const delay = (seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width) ? datum.point.x / seriesRect.width * duration : 0;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, {
          from: 0,
          to: 1,
          delay,
          duration: markerDuration,
          ease: linear,
          repeat: 0,
          onUpdate: opacity => {
            label.opacity = opacity;
          }
        });
      });
    });
  }
  animateReadyUpdate({
    contextData,
    paths
  }) {
    const {
      strokes,
      fills,
      fillOpacity,
      lineDash,
      lineDashOffset,
      strokeOpacity,
      strokeWidth,
      shadow
    } = this;
    contextData.forEach(({
      strokeSelectionData,
      fillSelectionData,
      itemId
    }, seriesIdx) => {
      const [fill, stroke] = paths[seriesIdx];
      // Stroke
      stroke.stroke = strokes[seriesIdx % strokes.length];
      stroke.strokeWidth = this.getStrokeWidth(this.strokeWidth, {
        itemId
      });
      stroke.strokeOpacity = strokeOpacity;
      stroke.lineDash = lineDash;
      stroke.lineDashOffset = lineDashOffset;
      stroke.path.clear({
        trackChanges: true
      });
      let moveTo = true;
      strokeSelectionData.points.forEach((point, index) => {
        if (strokeSelectionData.yValues[index] === undefined || isNaN(point.x) || isNaN(point.y)) {
          moveTo = true;
        } else if (moveTo) {
          stroke.path.moveTo(point.x, point.y);
          moveTo = false;
        } else {
          stroke.path.lineTo(point.x, point.y);
        }
      });
      stroke.checkPathDirty();
      // Fill
      fill.fill = fills[seriesIdx % fills.length];
      fill.fillOpacity = fillOpacity;
      fill.strokeOpacity = strokeOpacity;
      fill.strokeWidth = strokeWidth;
      fill.lineDash = lineDash;
      fill.lineDashOffset = lineDashOffset;
      fill.fillShadow = shadow;
      fill.path.clear({
        trackChanges: true
      });
      fillSelectionData.points.forEach(point => {
        fill.path.lineTo(point.x, point.y);
      });
      fill.path.closePath();
      fill.checkPathDirty();
    });
  }
  animateFormatter(datum) {
    var _a, _b, _c;
    const {
      marker,
      fills,
      strokes,
      xKey = '',
      yKeys,
      id: seriesId,
      ctx: {
        callbackCache
      }
    } = this;
    const {
      size,
      formatter
    } = marker;
    const yKeyIndex = yKeys.indexOf(datum.yKey);
    const fill = (_a = marker.fill) !== null && _a !== void 0 ? _a : fills[yKeyIndex % fills.length];
    const stroke = (_b = marker.stroke) !== null && _b !== void 0 ? _b : strokes[yKeyIndex % fills.length];
    const strokeWidth = (_c = marker.strokeWidth) !== null && _c !== void 0 ? _c : this.strokeWidth;
    let format = undefined;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum: datum.datum,
        xKey,
        yKey: datum.yKey,
        fill,
        stroke,
        strokeWidth,
        size,
        highlighted: false,
        seriesId
      });
    }
    return format;
  }
  isLabelEnabled() {
    return this.label.enabled;
  }
}
AreaSeries.className = 'AreaSeries';
AreaSeries.type = 'area';
areaSeries_decorate([Validate(COLOR_STRING_ARRAY)], AreaSeries.prototype, "fills", void 0);
areaSeries_decorate([Validate(COLOR_STRING_ARRAY)], AreaSeries.prototype, "strokes", void 0);
areaSeries_decorate([Validate(NUMBER(0, 1))], AreaSeries.prototype, "fillOpacity", void 0);
areaSeries_decorate([Validate(NUMBER(0, 1))], AreaSeries.prototype, "strokeOpacity", void 0);
areaSeries_decorate([Validate(OPT_LINE_DASH)], AreaSeries.prototype, "lineDash", void 0);
areaSeries_decorate([Validate(NUMBER(0))], AreaSeries.prototype, "lineDashOffset", void 0);
areaSeries_decorate([Validate(OPT_STRING)], AreaSeries.prototype, "xKey", void 0);
areaSeries_decorate([Validate(OPT_STRING)], AreaSeries.prototype, "xName", void 0);
areaSeries_decorate([Validate(STRING_ARRAY)], AreaSeries.prototype, "_yKeys", void 0);
areaSeries_decorate([Validate(BOOLEAN_ARRAY)], AreaSeries.prototype, "_visibles", void 0);
areaSeries_decorate([Validate(STRING_ARRAY)], AreaSeries.prototype, "yNames", void 0);
areaSeries_decorate([Validate(OPT_NUMBER())], AreaSeries.prototype, "_normalizedTo", void 0);
areaSeries_decorate([Validate(NUMBER(0))], AreaSeries.prototype, "strokeWidth", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/rect.mjs
var rect_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Rect extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new Path2D();
    this.x = 0;
    this.y = 0;
    this.width = 10;
    this.height = 10;
    this.radius = 0;
    /**
     * If `true`, the rect is aligned to the pixel grid for crisp looking lines.
     * Animated rects may not look nice with this option enabled, for example
     * when a rect is translated by a sub-pixel value on each frame.
     */
    this.crisp = false;
    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;
    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    this.microPixelEffectOpacity = 1;
  }
  isDirtyPath() {
    var _a;
    if (this.lastUpdatePathStrokeWidth !== this.strokeWidth) {
      return true;
    }
    if (this.path.isDirty() || this.borderPath.isDirty() || ((_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.isDirty())) {
      return true;
    }
    return false;
  }
  updatePath() {
    var _a, _b, _c;
    const {
      path,
      borderPath,
      crisp
    } = this;
    let {
      x,
      y,
      width: w,
      height: h,
      strokeWidth
    } = this;
    const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;
    const pixelSize = 1 / pixelRatio;
    let microPixelEffectOpacity = 1;
    path.clear({
      trackChanges: true
    });
    borderPath.clear({
      trackChanges: true
    });
    if (crisp) {
      if (w <= pixelSize) {
        microPixelEffectOpacity *= w / pixelSize;
      }
      if (h <= pixelSize) {
        microPixelEffectOpacity *= h / pixelSize;
      }
      w = this.align(x, w);
      h = this.align(y, h);
      x = this.align(x);
      y = this.align(y);
    }
    if (strokeWidth) {
      if (w < pixelSize) {
        // Too narrow, draw a vertical stroke
        const lx = x + pixelSize / 2;
        borderPath.moveTo(lx, y);
        borderPath.lineTo(lx, y + h);
        strokeWidth = pixelSize;
        this.borderClipPath = undefined;
      } else if (h < pixelSize) {
        // Too narrow, draw a horizontal stroke
        const ly = y + pixelSize / 2;
        borderPath.moveTo(x, ly);
        borderPath.lineTo(x + w, ly);
        strokeWidth = pixelSize;
        this.borderClipPath = undefined;
      } else if (strokeWidth < w && strokeWidth < h) {
        const halfStrokeWidth = strokeWidth / 2;
        x += halfStrokeWidth;
        y += halfStrokeWidth;
        w -= strokeWidth;
        h -= strokeWidth;
        // Clipping not needed in this case; fill to center of stroke.
        this.borderClipPath = undefined;
        path.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      } else {
        // Skip the fill and just render the stroke.
        this.borderClipPath = (_c = this.borderClipPath) !== null && _c !== void 0 ? _c : new Path2D();
        this.borderClipPath.clear({
          trackChanges: true
        });
        this.borderClipPath.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      }
    } else {
      // No borderPath needed, and thus no clipPath needed either. Fill to full extent of
      // Rect.
      this.borderClipPath = undefined;
      path.rect(x, y, w, h);
    }
    this.effectiveStrokeWidth = strokeWidth;
    this.lastUpdatePathStrokeWidth = strokeWidth;
    this.microPixelEffectOpacity = microPixelEffectOpacity;
  }
  computeBBox() {
    const {
      x,
      y,
      width,
      height
    } = this;
    return new BBox(x, y, width, height);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return bbox.containsPoint(point.x, point.y);
  }
  applyFillAlpha(ctx) {
    const {
      fillOpacity,
      microPixelEffectOpacity,
      opacity
    } = this;
    const {
      globalAlpha
    } = ctx;
    ctx.globalAlpha = globalAlpha * opacity * fillOpacity * microPixelEffectOpacity;
  }
  renderStroke(ctx) {
    const {
      stroke,
      effectiveStrokeWidth,
      borderPath,
      borderClipPath,
      opacity,
      microPixelEffectOpacity
    } = this;
    const borderActive = !!stroke && !!effectiveStrokeWidth;
    if (borderActive) {
      const {
        strokeOpacity,
        lineDash,
        lineDashOffset,
        lineCap,
        lineJoin
      } = this;
      if (borderClipPath) {
        // strokeWidth is larger than width or height, so use clipping to render correctly.
        // This is the simplest way to achieve the correct rendering due to nuances with ~0
        // width/height lines in Canvas operations.
        borderClipPath.draw(ctx);
        ctx.clip();
      }
      borderPath.draw(ctx);
      const {
        globalAlpha
      } = ctx;
      ctx.strokeStyle = stroke;
      ctx.globalAlpha = globalAlpha * opacity * strokeOpacity * microPixelEffectOpacity;
      ctx.lineWidth = effectiveStrokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
  }
}
Rect.className = 'Rect';
rect_decorate([ScenePathChangeDetection()], Rect.prototype, "x", void 0);
rect_decorate([ScenePathChangeDetection()], Rect.prototype, "y", void 0);
rect_decorate([ScenePathChangeDetection()], Rect.prototype, "width", void 0);
rect_decorate([ScenePathChangeDetection()], Rect.prototype, "height", void 0);
rect_decorate([ScenePathChangeDetection()], Rect.prototype, "radius", void 0);
rect_decorate([ScenePathChangeDetection()], Rect.prototype, "crisp", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/barUtil.mjs
var barUtil_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

function createLabelData({
  value,
  rect,
  placement,
  seriesId,
  padding = 0,
  formatter,
  barAlongX,
  ctx: {
    callbackCache
  }
}) {
  let labelText;
  if (formatter) {
    labelText = callbackCache.call(formatter, {
      value: isNumber(value) ? value : undefined,
      seriesId
    });
  }
  if (labelText === undefined) {
    labelText = isNumber(value) ? value.toFixed(2) : '';
  }
  let labelX = rect.x + rect.width / 2;
  let labelY = rect.y + rect.height / 2;
  let labelTextAlign = 'center';
  let labelTextBaseline = 'middle';
  const isPositive = value >= 0;
  switch (placement) {
    case 'start':
      {
        if (barAlongX) {
          labelX = isPositive ? rect.x - padding : rect.x + rect.width + padding;
          labelTextAlign = isPositive ? 'start' : 'end';
        } else {
          labelY = isPositive ? rect.y + rect.height + padding : rect.y - padding;
          labelTextBaseline = isPositive ? 'top' : 'bottom';
        }
        break;
      }
    case 'outside':
    case 'end':
      {
        if (barAlongX) {
          labelX = isPositive ? rect.x + rect.width + padding : rect.x - padding;
          labelTextAlign = isPositive ? 'start' : 'end';
        } else {
          labelY = isPositive ? rect.y - padding : rect.y + rect.height + padding;
          labelTextBaseline = isPositive ? 'bottom' : 'top';
        }
        break;
      }
    case 'inside':
    default:
      {
        labelTextBaseline = 'middle';
        break;
      }
  }
  return {
    text: labelText,
    textAlign: labelTextAlign,
    textBaseline: labelTextBaseline,
    x: labelX,
    y: labelY
  };
}
function updateRect({
  rect,
  config
}) {
  const {
    crisp = true,
    fill,
    stroke,
    strokeWidth,
    fillOpacity,
    strokeOpacity,
    lineDash,
    lineDashOffset,
    fillShadow,
    visible = true
  } = config;
  rect.crisp = crisp;
  rect.fill = fill;
  rect.stroke = stroke;
  rect.strokeWidth = strokeWidth;
  rect.fillOpacity = fillOpacity;
  rect.strokeOpacity = strokeOpacity;
  rect.lineDash = lineDash;
  rect.lineDashOffset = lineDashOffset;
  rect.fillShadow = fillShadow;
  rect.visible = visible;
}
function getRectConfig(_a) {
  var _b, _c, _d, _e, _f, _g, _h;
  var {
      datum,
      isHighlighted,
      style,
      highlightStyle,
      formatter,
      seriesId,
      stackGroup,
      ctx: {
        callbackCache
      }
    } = _a,
    opts = barUtil_rest(_a, ["datum", "isHighlighted", "style", "highlightStyle", "formatter", "seriesId", "stackGroup", "ctx"]);
  const itemFill = isHighlighted ? (_b = highlightStyle.fill) !== null && _b !== void 0 ? _b : style.fill : style.fill;
  const itemStroke = isHighlighted ? (_c = highlightStyle.stroke) !== null && _c !== void 0 ? _c : style.stroke : style.stroke;
  const itemStrokeWidth = isHighlighted ? (_d = highlightStyle.strokeWidth) !== null && _d !== void 0 ? _d : style.strokeWidth : style.strokeWidth;
  const fillOpacity = isHighlighted ? (_e = highlightStyle.fillOpacity) !== null && _e !== void 0 ? _e : style.fillOpacity : style.fillOpacity;
  const {
    strokeOpacity,
    fillShadow,
    lineDash,
    lineDashOffset
  } = style;
  let format = undefined;
  if (formatter) {
    format = callbackCache.call(formatter, Object.assign({
      datum: datum.datum,
      xKey: datum.xKey,
      yKey: datum.yKey,
      fill: itemFill,
      stroke: itemStroke,
      strokeWidth: itemStrokeWidth,
      highlighted: isHighlighted,
      seriesId,
      stackGroup
    }, opts));
  }
  return {
    fill: (_f = format === null || format === void 0 ? void 0 : format.fill) !== null && _f !== void 0 ? _f : itemFill,
    stroke: (_g = format === null || format === void 0 ? void 0 : format.stroke) !== null && _g !== void 0 ? _g : itemStroke,
    strokeWidth: (_h = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _h !== void 0 ? _h : itemStrokeWidth,
    fillOpacity,
    strokeOpacity,
    lineDash,
    lineDashOffset,
    fillShadow
  };
}
function checkCrisp(visibleRange = []) {
  const [visibleMin, visibleMax] = visibleRange;
  const isZoomed = visibleMin !== 0 || visibleMax !== 1;
  const crisp = !isZoomed;
  return crisp;
}
function updateLabel({
  labelNode,
  labelDatum,
  config,
  visible
}) {
  if (labelDatum && config && config.enabled) {
    const {
      x,
      y,
      text,
      textAlign,
      textBaseline
    } = labelDatum;
    const {
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      color
    } = config;
    labelNode.fontStyle = fontStyle;
    labelNode.fontWeight = fontWeight;
    labelNode.fontSize = fontSize;
    labelNode.fontFamily = fontFamily;
    labelNode.textAlign = textAlign;
    labelNode.textBaseline = textBaseline;
    labelNode.text = text;
    labelNode.x = x;
    labelNode.y = y;
    labelNode.fill = color;
    labelNode.visible = visible;
  } else {
    labelNode.visible = false;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/barSeries.mjs

var barSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var barSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};






















const BAR_LABEL_PLACEMENTS = ['inside', 'outside'];
const OPT_BAR_LABEL_PLACEMENT = (v, ctx) => OPTIONAL(v, ctx, v => BAR_LABEL_PLACEMENTS.includes(v));
var BarSeriesNodeTag;
(function (BarSeriesNodeTag) {
  BarSeriesNodeTag[BarSeriesNodeTag["Bar"] = 0] = "Bar";
  BarSeriesNodeTag[BarSeriesNodeTag["Label"] = 1] = "Label";
})(BarSeriesNodeTag || (BarSeriesNodeTag = {}));
class BarSeriesLabel extends Label {
  constructor() {
    super(...arguments);
    this.formatter = undefined;
    this.placement = 'inside';
  }
}
barSeries_decorate([Validate(OPT_FUNCTION)], BarSeriesLabel.prototype, "formatter", void 0);
barSeries_decorate([Validate(OPT_BAR_LABEL_PLACEMENT)], BarSeriesLabel.prototype, "placement", void 0);
class BarSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
  }
}
barSeries_decorate([Validate(OPT_FUNCTION)], BarSeriesTooltip.prototype, "renderer", void 0);
function is2dArray(array) {
  return array.length > 0 && Array.isArray(array[0]);
}
class BarSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],
      pathsPerSeries: 0,
      directionKeys: {
        [ChartAxisDirection.X]: ['xKey'],
        [ChartAxisDirection.Y]: ['yKeys']
      },
      directionNames: {
        [ChartAxisDirection.X]: ['xName'],
        [ChartAxisDirection.Y]: ['yNames']
      }
    });
    this.label = new BarSeriesLabel();
    this.tooltip = new BarSeriesTooltip();
    this.fills = ['#c16068', '#a2bf8a', '#ebcc87', '#80a0c3', '#b58dae', '#85c0d1'];
    this.strokes = ['#874349', '#718661', '#a48f5f', '#5a7088', '#7f637a', '#5d8692'];
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.formatter = undefined;
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new BandScale();
    this.xKey = undefined;
    this.xName = undefined;
    this.cumYKeyCount = [];
    this.flatYKeys = undefined; // only set when a user used a flat array for yKeys
    this.hideInLegend = [];
    this.yKeys = [];
    this.yKeysCache = [];
    this.visibles = [];
    this.grouped = false;
    this.stackGroups = {};
    /**
     * A map of `yKeys` to their names (used in legends and tooltips).
     * For example, if a key is `product_name` it's name can be a more presentable `Product Name`.
     */
    this.yNames = {};
    this.legendItemNames = {};
    this.strokeWidth = 1;
    this.shadow = undefined;
    this.smallestDataInterval = undefined;
    this.label.enabled = false;
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === ChartAxisDirection.X) {
      if (direction === ChartAxisDirection.X) {
        return ChartAxisDirection.Y;
      }
      return ChartAxisDirection.X;
    }
    return direction;
  }
  processYKeys() {
    let {
      yKeys
    } = this;
    let flatYKeys = undefined;
    // Convert from flat y-keys to grouped y-keys.
    if (!is2dArray(yKeys)) {
      flatYKeys = yKeys;
      yKeys = this.grouped ? flatYKeys.map(k => [k]) : [flatYKeys];
    }
    const stackGroups = Object.values(this.stackGroups);
    if (stackGroups.length > 0) {
      const flattenKeys = keys => keys.reduce((res, k) => res.concat(k), []);
      // Create a stack for items without a group
      const flatKeys = flattenKeys(yKeys);
      const keysInStacks = new Set(flattenKeys(stackGroups));
      const ungroupedKeys = flatKeys.filter(k => !keysInStacks.has(k));
      yKeys = stackGroups.map(keys => keys);
      if (ungroupedKeys.length > 0) {
        yKeys.push(ungroupedKeys);
      }
      // Preserve the order of colours and other properties
      const indexMap = items => items.reduce((map, key, index) => map.set(key, index), new Map());
      const newKeys = flattenKeys(yKeys);
      const newKeysIndices = indexMap(newKeys);
      const sort = items => {
        const result = Array.from({
          length: items.length
        });
        items.forEach((item, index) => {
          const key = flatKeys[index];
          const newIndex = newKeysIndices.get(key);
          result[newIndex] = item;
        });
        return result;
      };
      this.fills = sort(this.fills);
      this.strokes = sort(this.strokes);
      this.visibles = sort(this.visibles);
    }
    if (!areArrayItemsStrictlyEqual(this.yKeysCache, yKeys)) {
      this.flatYKeys = flatYKeys ? flatYKeys : undefined;
      this.yKeys = yKeys;
      let prevYKeyCount = 0;
      this.cumYKeyCount = [];
      const visibleStacks = [];
      yKeys.forEach((stack, index) => {
        if (stack.length > 0) {
          visibleStacks.push(String(index));
        }
        this.cumYKeyCount.push(prevYKeyCount);
        prevYKeyCount += stack.length;
      });
      this.processSeriesItemEnabled();
      const {
        groupScale
      } = this;
      groupScale.domain = visibleStacks;
    }
    this.yKeysCache = yKeys;
  }
  processSeriesItemEnabled() {
    const {
      seriesItemEnabled
    } = this;
    const flattenFn = (r, n) => r.concat(...(Array.isArray(n) ? n : [n]));
    const visibles = this.visibles.reduce(flattenFn, []);
    seriesItemEnabled.clear();
    let visiblesIdx = 0;
    this.yKeys.forEach(stack => {
      stack.forEach(yKey => {
        var _a;
        return seriesItemEnabled.set(yKey, (_a = visibles[visiblesIdx++]) !== null && _a !== void 0 ? _a : true);
      });
    });
  }
  getStackGroup(yKey) {
    var _a;
    const {
      stackGroups
    } = this;
    return (_a = Object.entries(stackGroups).find(([_, keys]) => keys.includes(yKey))) === null || _a === void 0 ? void 0 : _a[0];
  }
  processYNames() {
    const values = this.yNames;
    if (Array.isArray(values) && this.flatYKeys) {
      const map = {};
      this.flatYKeys.forEach((k, i) => {
        map[k] = values[i];
      });
      this.yNames = map;
    }
  }
  processData() {
    var _a, _b, _c, _d, _e;
    return barSeries_awaiter(this, void 0, void 0, function* () {
      this.processYKeys();
      this.processYNames();
      const {
        xKey,
        seriesItemEnabled,
        normalizedTo,
        data = []
      } = this;
      const normalizedToAbs = Math.abs(normalizedTo !== null && normalizedTo !== void 0 ? normalizedTo : NaN);
      const isContinuousX = ((_a = this.getCategoryAxis()) === null || _a === void 0 ? void 0 : _a.scale) instanceof ContinuousScale;
      const isContinuousY = ((_b = this.getValueAxis()) === null || _b === void 0 ? void 0 : _b.scale) instanceof ContinuousScale;
      const activeSeriesItems = [...seriesItemEnabled.entries()].filter(([, enabled]) => enabled).map(([yKey]) => yKey);
      const activeStacks = this.yKeys.map(stack => stack.filter(key => seriesItemEnabled.get(key))).filter(stack => stack.length > 0);
      const normaliseTo = normalizedToAbs && isFinite(normalizedToAbs) ? normalizedToAbs : undefined;
      const extraProps = [];
      if (normaliseTo) {
        extraProps.push(normaliseGroupTo(activeSeriesItems, normaliseTo, 'sum'));
      }
      this.dataModel = new DataModel({
        props: [keyProperty(xKey, isContinuousX), ...activeSeriesItems.map(yKey => valueProperty(yKey, isContinuousY, {
          invalidValue: null
        })), ...activeStacks.map(stack => sum(stack)), ...(isContinuousX ? [SMALLEST_KEY_INTERVAL] : []), AGG_VALUES_EXTENT, ...extraProps],
        groupByKeys: true,
        dataVisible: this.visible && activeSeriesItems.length > 0
      });
      this.processedData = this.dataModel.processData(data);
      this.smallestDataInterval = {
        x: (_e = (_d = (_c = this.processedData) === null || _c === void 0 ? void 0 : _c.reduced) === null || _d === void 0 ? void 0 : _d[SMALLEST_KEY_INTERVAL.property]) !== null && _e !== void 0 ? _e : Infinity,
        y: Infinity
      };
    });
  }
  getDomain(direction) {
    var _a;
    const {
      processedData
    } = this;
    if (!processedData) return [];
    const {
      defs: {
        keys: [keyDef]
      },
      domain: {
        keys: [keys],
        values: [yExtent]
      },
      reduced: {
        [SMALLEST_KEY_INTERVAL.property]: smallestX,
        [AGG_VALUES_EXTENT.property]: ySumExtent
      } = {}
    } = processedData;
    if (direction === this.getCategoryDirection()) {
      if (keyDef.valueType === 'category') {
        return keys;
      }
      const keysExtent = (_a = extent(keys)) !== null && _a !== void 0 ? _a : [NaN, NaN];
      if (direction === ChartAxisDirection.Y) {
        return [keysExtent[0] + -smallestX, keysExtent[1]];
      }
      return [keysExtent[0], keysExtent[1] + smallestX];
    } else if (this.getValueAxis() instanceof LogAxis) {
      return this.fixNumericExtent(yExtent);
    } else {
      return this.fixNumericExtent(ySumExtent);
    }
  }
  getNodeClickEvent(event, datum) {
    var _a;
    return new CartesianSeriesNodeClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', datum.yKey, event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    var _a;
    return new CartesianSeriesNodeDoubleClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', datum.yKey, event, datum, this);
  }
  getCategoryAxis() {
    return this.getCategoryDirection() === ChartAxisDirection.Y ? this.yAxis : this.xAxis;
  }
  getValueAxis() {
    return this.getBarDirection() === ChartAxisDirection.Y ? this.yAxis : this.xAxis;
  }
  calculateStep(range) {
    var _a;
    const {
      smallestDataInterval: smallestInterval
    } = this;
    const xAxis = this.getCategoryAxis();
    if (!xAxis) {
      return;
    }
    // calculate step
    const domainLength = xAxis.dataDomain[1] - xAxis.dataDomain[0];
    const intervals = domainLength / ((_a = smallestInterval === null || smallestInterval === void 0 ? void 0 : smallestInterval.x) !== null && _a !== void 0 ? _a : 1) + 1;
    // The number of intervals/bands is used to determine the width of individual bands by dividing the available range.
    // Allow a maximum number of bands to ensure the step does not fall below 1 pixel.
    // This means there could be some overlap of the bands in the chart.
    const maxBands = Math.floor(range); // A minimum of 1px per bar/column means the maximum number of bands will equal the available range
    const bands = Math.min(intervals, maxBands);
    const step = range / Math.max(1, bands);
    return step;
  }
  createNodeData() {
    return barSeries_awaiter(this, void 0, void 0, function* () {
      const {
        data,
        visible
      } = this;
      const xAxis = this.getCategoryAxis();
      const yAxis = this.getValueAxis();
      if (!(data && visible && xAxis && yAxis)) {
        return [];
      }
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const {
        groupScale,
        yKeys,
        xKey = '',
        cumYKeyCount,
        fills,
        strokes,
        strokeWidth,
        seriesItemEnabled,
        label,
        id: seriesId,
        processedData,
        ctx
      } = this;
      let xBandWidth = xScale.bandwidth;
      if (xScale instanceof ContinuousScale) {
        const availableRange = Math.max(xAxis.range[0], xAxis.range[1]);
        const step = this.calculateStep(availableRange);
        xBandWidth = step;
      }
      groupScale.range = [0, xBandWidth];
      if (xAxis instanceof CategoryAxis) {
        groupScale.padding = xAxis.groupPaddingInner;
      } else if (xAxis instanceof GroupedCategoryAxis) {
        groupScale.padding = 0.1;
      } else {
        // Number or Time axis
        groupScale.padding = 0;
      }
      // To get exactly `0` padding we need to turn off rounding
      if (groupScale.padding === 0) {
        groupScale.round = false;
      } else {
        groupScale.round = true;
      }
      const barWidth = groupScale.bandwidth >= 1 ?
      // Pixel-rounded value for low-volume bar charts.
      groupScale.bandwidth :
      // Handle high-volume bar charts gracefully.
      groupScale.rawBandwidth;
      const contexts = [];
      processedData === null || processedData === void 0 ? void 0 : processedData.data.forEach(({
        keys,
        datum: seriesDatum,
        values
      }, dataIndex) => {
        var _a, _b, _c, _d, _e;
        var _f;
        const x = xScale.convert(keys[0]);
        for (let stackIndex = 0; stackIndex < ((_a = yKeys === null || yKeys === void 0 ? void 0 : yKeys.length) !== null && _a !== void 0 ? _a : 0); stackIndex++) {
          const stackYKeys = (_b = yKeys === null || yKeys === void 0 ? void 0 : yKeys[stackIndex]) !== null && _b !== void 0 ? _b : []; // y-data for a stack within a group
          (_c = contexts[stackIndex]) !== null && _c !== void 0 ? _c : contexts[stackIndex] = [];
          let prevMinY = 0;
          let prevMaxY = 0;
          for (let levelIndex = 0; levelIndex < stackYKeys.length; levelIndex++) {
            const yKey = stackYKeys[levelIndex];
            const yIndex = (_d = processedData === null || processedData === void 0 ? void 0 : processedData.indices.values[yKey]) !== null && _d !== void 0 ? _d : -1;
            (_e = (_f = contexts[stackIndex])[levelIndex]) !== null && _e !== void 0 ? _e : _f[levelIndex] = {
              itemId: yKey,
              nodeData: [],
              labelData: []
            };
            if (yIndex === undefined) continue;
            const yValue = values[0][yIndex];
            const currY = +yValue;
            const barX = x + groupScale.convert(String(stackIndex));
            // Bars outside of visible range are not rendered, so we create node data
            // only for the visible subset of user data.
            if (!xAxis.inRange(barX, barWidth)) {
              continue;
            }
            if (isNaN(currY)) {
              continue;
            }
            const prevY = currY < 0 ? prevMinY : prevMaxY;
            const y = yScale.convert(prevY + currY, {
              strict: false
            });
            const bottomY = yScale.convert(prevY, {
              strict: false
            });
            const barAlongX = this.getBarDirection() === ChartAxisDirection.X;
            const rect = {
              x: barAlongX ? Math.min(y, bottomY) : barX,
              y: barAlongX ? barX : Math.min(y, bottomY),
              width: barAlongX ? Math.abs(bottomY - y) : barWidth,
              height: barAlongX ? barWidth : Math.abs(bottomY - y)
            };
            const nodeMidPoint = {
              x: rect.x + rect.width / 2,
              y: rect.y + rect.height / 2
            };
            const {
              fontStyle: labelFontStyle,
              fontWeight: labelFontWeight,
              fontSize: labelFontSize,
              fontFamily: labelFontFamily,
              color: labelColor,
              formatter,
              placement
            } = label;
            const {
              text: labelText,
              textAlign: labelTextAlign,
              textBaseline: labelTextBaseline,
              x: labelX,
              y: labelY
            } = createLabelData({
              value: yValue,
              rect,
              formatter,
              placement,
              seriesId,
              barAlongX,
              ctx
            });
            const colorIndex = cumYKeyCount[stackIndex] + levelIndex;
            const nodeData = {
              index: dataIndex,
              series: this,
              itemId: yKey,
              datum: seriesDatum[0],
              cumulativeValue: prevY + currY,
              yValue,
              yKey,
              xKey,
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height,
              nodeMidPoint,
              colorIndex,
              fill: fills[colorIndex % fills.length],
              stroke: strokes[colorIndex % strokes.length],
              strokeWidth,
              label: seriesItemEnabled.get(yKey) && labelText ? {
                text: labelText,
                fontStyle: labelFontStyle,
                fontWeight: labelFontWeight,
                fontSize: labelFontSize,
                fontFamily: labelFontFamily,
                textAlign: labelTextAlign,
                textBaseline: labelTextBaseline,
                fill: labelColor,
                x: labelX,
                y: labelY
              } : undefined
            };
            contexts[stackIndex][levelIndex].nodeData.push(nodeData);
            contexts[stackIndex][levelIndex].labelData.push(nodeData);
            if (currY < 0) {
              prevMinY += currY;
            } else {
              prevMaxY += currY;
            }
          }
        }
      });
      return contexts.reduce((r, n) => r.concat(...n), []);
    });
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    return barSeries_awaiter(this, void 0, void 0, function* () {
      const {
        nodeData,
        datumSelection
      } = opts;
      return datumSelection.update(nodeData, rect => rect.tag = BarSeriesNodeTag.Bar);
    });
  }
  updateDatumNodes(opts) {
    var _a;
    return barSeries_awaiter(this, void 0, void 0, function* () {
      const {
        datumSelection,
        isHighlight
      } = opts;
      const {
        fills,
        strokes,
        fillOpacity,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        shadow,
        formatter,
        id: seriesId,
        highlightStyle: {
          item: itemHighlightStyle
        },
        ctx
      } = this;
      const crisp = checkCrisp((_a = this.xAxis) === null || _a === void 0 ? void 0 : _a.visibleRange);
      const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection.X;
      datumSelection.each((rect, datum) => {
        const {
          colorIndex
        } = datum;
        const style = {
          fill: fills[colorIndex % fills.length],
          stroke: strokes[colorIndex % fills.length],
          fillOpacity,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          fillShadow: shadow,
          strokeWidth: this.getStrokeWidth(this.strokeWidth, datum)
        };
        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
        const config = getRectConfig({
          datum,
          isHighlighted: isHighlight,
          style,
          highlightStyle: itemHighlightStyle,
          formatter,
          seriesId,
          stackGroup: this.getStackGroup(datum.yKey),
          ctx
        });
        config.crisp = crisp;
        config.visible = visible;
        updateRect({
          rect,
          config
        });
      });
    });
  }
  updateLabelSelection(opts) {
    return barSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelData,
        labelSelection
      } = opts;
      const {
        enabled
      } = this.label;
      const data = enabled ? labelData : [];
      return labelSelection.update(data, text => {
        text.tag = BarSeriesNodeTag.Label;
        text.pointerEvents = PointerEvents.None;
      });
    });
  }
  updateLabelNodes(opts) {
    return barSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelSelection
      } = opts;
      labelSelection.each((text, datum) => {
        const labelDatum = datum.label;
        updateLabel({
          labelNode: text,
          labelDatum,
          config: this.label,
          visible: true
        });
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    const {
      xKey,
      yKeys,
      processedData,
      ctx: {
        callbackCache
      }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    const {
      yKey
    } = nodeDatum;
    if (!processedData || !xKey || !yKey || !xAxis || !yAxis) {
      return '';
    }
    let fillIndex = 0;
    let i = 0;
    let j = 0;
    for (; j < yKeys.length; j++) {
      const stack = yKeys[j];
      i = stack.indexOf(yKey);
      if (i >= 0) {
        fillIndex += i;
        break;
      }
      fillIndex += stack.length;
    }
    const {
      xName,
      yNames,
      fills,
      strokes,
      tooltip,
      formatter,
      id: seriesId
    } = this;
    const {
      renderer: tooltipRenderer
    } = tooltip;
    const datum = nodeDatum.datum;
    const yName = yNames[yKey];
    const stackGroup = this.getStackGroup(yKey);
    const fill = fills[fillIndex % fills.length];
    const stroke = strokes[fillIndex % fills.length];
    const strokeWidth = this.getStrokeWidth(this.strokeWidth);
    const xValue = datum[xKey];
    const yValue = datum[yKey];
    const xString = sanitizeHtml(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml(yAxis.formatDatum(yValue));
    const title = sanitizeHtml(yName);
    const content = xString + ': ' + yString;
    let format = undefined;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum,
        fill,
        stroke,
        strokeWidth,
        highlighted: false,
        xKey,
        yKey,
        seriesId,
        stackGroup
      });
    }
    const color = (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    if (tooltipRenderer) {
      return toTooltipHtml(tooltipRenderer({
        datum,
        xKey,
        xValue,
        xName,
        yKey,
        yValue,
        yName,
        color,
        title,
        seriesId,
        stackGroup
      }), defaults);
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    const {
      id,
      data,
      xKey,
      yKeys,
      yNames,
      legendItemNames,
      cumYKeyCount,
      seriesItemEnabled,
      hideInLegend,
      fills,
      strokes,
      fillOpacity,
      strokeOpacity
    } = this;
    if (!(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKeys.length) {
      return [];
    }
    const legendData = [];
    this.validateLegendData();
    this.yKeys.forEach((stack, stackIndex) => {
      var _a, _b, _c;
      for (let levelIndex = 0; levelIndex < stack.length; levelIndex++) {
        const yKey = stack[levelIndex];
        if (hideInLegend.indexOf(yKey) >= 0) {
          return;
        }
        const colorIndex = cumYKeyCount[stackIndex] + levelIndex;
        legendData.push({
          legendType: 'category',
          id,
          itemId: yKey,
          seriesId: id,
          enabled: (_a = seriesItemEnabled.get(yKey)) !== null && _a !== void 0 ? _a : false,
          label: {
            text: (_c = (_b = legendItemNames[yKey]) !== null && _b !== void 0 ? _b : yNames[yKey]) !== null && _c !== void 0 ? _c : yKey
          },
          marker: {
            fill: fills[colorIndex % fills.length],
            stroke: strokes[colorIndex % strokes.length],
            fillOpacity: fillOpacity,
            strokeOpacity: strokeOpacity
          }
        });
      }
    });
    return legendData;
  }
  validateLegendData() {
    const {
      hideInLegend,
      legendItemNames
    } = this;
    let hasAnyLegendItemName = false;
    this.yKeys.forEach(stack => {
      stack.forEach(yKey => {
        if (hideInLegend.indexOf(yKey) >= 0) {
          return;
        }
        const hasLegendItemName = legendItemNames[yKey] !== undefined;
        if (hasAnyLegendItemName && !hasLegendItemName) {
          Logger.warnOnce(`a series is missing the legendItemName property, unexpected behaviour may occur.`);
        }
        hasAnyLegendItemName = hasLegendItemName;
      });
    });
  }
  onLegendItemClick(event) {
    const {
      itemId,
      enabled,
      series
    } = event;
    if (series.id !== this.id) return;
    super.toggleSeriesItem(itemId, enabled);
    // Toggle items where the legendItemName matches the legendItemName of the clicked item
    Object.keys(this.legendItemNames).filter(id => this.legendItemNames[id] !== undefined && this.legendItemNames[id] === this.legendItemNames[itemId]).forEach(yKey => {
      if (yKey !== itemId) {
        super.toggleSeriesItem(yKey, enabled);
      }
    });
    this.calculateVisibleDomain();
  }
  onLegendItemDoubleClick(event) {
    const {
      enabled,
      itemId,
      numVisibleItems
    } = event;
    const totalVisibleItems = Object.values(numVisibleItems).reduce((p, v) => p + v, 0);
    const singleEnabledInEachSeries = Object.values(numVisibleItems).filter(v => v === 1).length === Object.keys(numVisibleItems).length;
    const newEnableds = {};
    this.yKeys.forEach(stack => {
      stack.forEach(yKey => {
        var _a;
        const matches = yKey === itemId;
        const singleEnabledWasClicked = totalVisibleItems === 1 && enabled;
        const newEnabled = matches || singleEnabledWasClicked || singleEnabledInEachSeries && enabled;
        newEnableds[yKey] = (_a = newEnableds[yKey]) !== null && _a !== void 0 ? _a : newEnabled;
        // Toggle other items that have matching legendItemNames which have not already been processed.
        Object.keys(this.legendItemNames).filter(id => this.legendItemNames[id] !== undefined && this.legendItemNames[id] === this.legendItemNames[yKey]).forEach(nameYKey => {
          var _a;
          newEnableds[nameYKey] = (_a = newEnableds[nameYKey]) !== null && _a !== void 0 ? _a : newEnabled;
        });
      });
    });
    Object.keys(newEnableds).forEach(yKey => {
      super.toggleSeriesItem(yKey, newEnableds[yKey]);
    });
    this.calculateVisibleDomain();
  }
  calculateVisibleDomain() {
    const yKeys = this.yKeys.map(stack => stack.slice()); // deep clone
    this.seriesItemEnabled.forEach((enabled, yKey) => {
      if (!enabled) {
        yKeys.forEach(stack => {
          const index = stack.indexOf(yKey);
          if (index >= 0) {
            stack.splice(index, 1);
          }
        });
      }
    });
    const visibleStacks = [];
    yKeys.forEach((stack, index) => {
      if (stack.length > 0) {
        visibleStacks.push(String(index));
      }
    });
    this.groupScale.domain = visibleStacks;
    this.nodeDataRefresh = true;
  }
  animateEmptyUpdateReady({
    datumSelections,
    labelSelections
  }) {
    const duration = 1000;
    const labelDuration = 200;
    let startingX = Infinity;
    datumSelections.forEach(datumSelection => datumSelection.each((_, datum) => {
      if (datum.yValue >= 0) {
        startingX = Math.min(startingX, datum.x);
      }
    }));
    datumSelections.forEach(datumSelection => {
      datumSelection.each((rect, datum) => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animateMany(`${this.id}_empty-update-ready_${rect.id}`, [{
          from: startingX,
          to: datum.x
        }, {
          from: 0,
          to: datum.width
        }], {
          disableInteractions: true,
          duration,
          ease: easeOut,
          repeat: 0,
          onUpdate([x, width]) {
            rect.x = x;
            rect.width = width;
            rect.y = datum.y;
            rect.height = datum.height;
          }
        });
      });
    });
    labelSelections.forEach(labelSelection => {
      labelSelection.each(label => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, {
          from: 0,
          to: 1,
          delay: duration,
          duration: labelDuration,
          ease: linear,
          repeat: 0,
          onUpdate: opacity => {
            label.opacity = opacity;
          }
        });
      });
    });
  }
  animateReadyUpdate({
    datumSelections
  }) {
    datumSelections.forEach(datumSelection => {
      this.resetSelectionRects(datumSelection);
    });
  }
  animateReadyHighlight(highlightSelection) {
    this.resetSelectionRects(highlightSelection);
  }
  animateReadyResize({
    datumSelections
  }) {
    var _a;
    (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.stop();
    datumSelections.forEach(datumSelection => {
      this.resetSelectionRects(datumSelection);
    });
  }
  resetSelectionRects(selection) {
    selection.each((rect, datum) => {
      rect.x = datum.x;
      rect.y = datum.y;
      rect.width = datum.width;
      rect.height = datum.height;
    });
  }
  isLabelEnabled() {
    return this.label.enabled;
  }
  getBandScalePadding() {
    return {
      inner: 0.2,
      outer: 0.3
    };
  }
  getBarDirection() {
    return ChartAxisDirection.X;
  }
  getCategoryDirection() {
    return ChartAxisDirection.Y;
  }
}
BarSeries.className = 'BarSeries';
BarSeries.type = 'bar';
barSeries_decorate([Validate(COLOR_STRING_ARRAY)], BarSeries.prototype, "fills", void 0);
barSeries_decorate([Validate(COLOR_STRING_ARRAY)], BarSeries.prototype, "strokes", void 0);
barSeries_decorate([Validate(NUMBER(0, 1))], BarSeries.prototype, "fillOpacity", void 0);
barSeries_decorate([Validate(NUMBER(0, 1))], BarSeries.prototype, "strokeOpacity", void 0);
barSeries_decorate([Validate(OPT_LINE_DASH)], BarSeries.prototype, "lineDash", void 0);
barSeries_decorate([Validate(NUMBER(0))], BarSeries.prototype, "lineDashOffset", void 0);
barSeries_decorate([Validate(OPT_FUNCTION)], BarSeries.prototype, "formatter", void 0);
barSeries_decorate([Validate(OPT_STRING)], BarSeries.prototype, "xKey", void 0);
barSeries_decorate([Validate(OPT_STRING)], BarSeries.prototype, "xName", void 0);
barSeries_decorate([Validate(STRING_ARRAY)], BarSeries.prototype, "hideInLegend", void 0);
barSeries_decorate([Validate(BOOLEAN_ARRAY)], BarSeries.prototype, "visibles", void 0);
barSeries_decorate([Validate(BOOLEAN)], BarSeries.prototype, "grouped", void 0);
barSeries_decorate([Validate(OPT_NUMBER())], BarSeries.prototype, "normalizedTo", void 0);
barSeries_decorate([Validate(NUMBER(0))], BarSeries.prototype, "strokeWidth", void 0);
class ColumnSeries extends BarSeries {
  getBarDirection() {
    return ChartAxisDirection.Y;
  }
  getCategoryDirection() {
    return ChartAxisDirection.X;
  }
  animateEmptyUpdateReady({
    datumSelections,
    labelSelections
  }) {
    const duration = 1000;
    const labelDuration = 200;
    let startingY = 0;
    datumSelections.forEach(datumSelection => datumSelection.each((_, datum) => {
      if (datum.yValue >= 0) {
        startingY = Math.max(startingY, datum.height + datum.y);
      }
    }));
    datumSelections.forEach(datumSelection => {
      datumSelection.each((rect, datum) => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animateMany(`${this.id}_empty-update-ready_${rect.id}`, [{
          from: startingY,
          to: datum.y
        }, {
          from: 0,
          to: datum.height
        }], {
          disableInteractions: true,
          duration,
          ease: easeOut,
          repeat: 0,
          onUpdate([y, height]) {
            rect.y = y;
            rect.height = height;
            rect.x = datum.x;
            rect.width = datum.width;
          }
        });
      });
    });
    labelSelections.forEach(labelSelection => {
      labelSelection.each(label => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, {
          from: 0,
          to: 1,
          delay: duration,
          duration: labelDuration,
          ease: linear,
          repeat: 0,
          onUpdate: opacity => {
            label.opacity = opacity;
          }
        });
      });
    });
  }
}
ColumnSeries.type = 'column';
ColumnSeries.className = 'ColumnSeries';
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/histogramSeries.mjs

var histogramSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var histogramSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};














const HISTOGRAM_AGGREGATIONS = ['count', 'sum', 'mean'];
const HISTOGRAM_AGGREGATION = predicateWithMessage(v => HISTOGRAM_AGGREGATIONS.includes(v), `expecting a histogram aggregation keyword such as 'count', 'sum' or 'mean`);
var HistogramSeriesNodeTag;
(function (HistogramSeriesNodeTag) {
  HistogramSeriesNodeTag[HistogramSeriesNodeTag["Bin"] = 0] = "Bin";
  HistogramSeriesNodeTag[HistogramSeriesNodeTag["Label"] = 1] = "Label";
})(HistogramSeriesNodeTag || (HistogramSeriesNodeTag = {}));
class HistogramSeriesLabel extends Label {
  constructor() {
    super(...arguments);
    this.formatter = undefined;
  }
}
histogramSeries_decorate([Validate(OPT_FUNCTION)], HistogramSeriesLabel.prototype, "formatter", void 0);
const defaultBinCount = 10;
class HistogramSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
  }
}
histogramSeries_decorate([Validate(OPT_FUNCTION)], HistogramSeriesTooltip.prototype, "renderer", void 0);
class HistogramSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH]
    });
    this.label = new HistogramSeriesLabel();
    this.tooltip = new HistogramSeriesTooltip();
    this.fill = undefined;
    this.stroke = undefined;
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.xKey = undefined;
    this.areaPlot = false;
    this.bins = undefined;
    this.aggregation = 'count';
    this.binCount = undefined;
    this.xName = undefined;
    this.yKey = undefined;
    this.yName = undefined;
    this.strokeWidth = 1;
    this.shadow = undefined;
    this.calculatedBins = [];
    this.label.enabled = false;
  }
  // During processData phase, used to unify different ways of the user specifying
  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
  deriveBins(xDomain) {
    if (this.binCount === undefined) {
      const binStarts = util_ticks(xDomain[0], xDomain[1], defaultBinCount);
      const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
      const firstBinEnd = binStarts[0];
      const expandStartToBin = n => [n, n + binSize];
      return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
    } else {
      return this.calculateNiceBins(xDomain, this.binCount);
    }
  }
  calculateNiceBins(domain, binCount) {
    const startGuess = Math.floor(domain[0]);
    const stop = domain[1];
    const segments = binCount || 1;
    const {
      start,
      binSize
    } = this.calculateNiceStart(startGuess, stop, segments);
    return this.getBins(start, stop, binSize, segments);
  }
  getBins(start, stop, step, count) {
    const bins = [];
    for (let i = 0; i < count; i++) {
      const a = Math.round((start + i * step) * 10) / 10;
      let b = Math.round((start + (i + 1) * step) * 10) / 10;
      if (i === count - 1) {
        b = Math.max(b, stop);
      }
      bins[i] = [a, b];
    }
    return bins;
  }
  calculateNiceStart(a, b, segments) {
    const binSize = Math.abs(b - a) / segments;
    const order = Math.floor(Math.log10(binSize));
    const magnitude = Math.pow(10, order);
    const start = Math.floor(a / magnitude) * magnitude;
    return {
      start,
      binSize
    };
  }
  processData() {
    return histogramSeries_awaiter(this, void 0, void 0, function* () {
      const {
        xKey,
        yKey,
        data,
        areaPlot,
        aggregation
      } = this;
      const props = [keyProperty(xKey, true), SORT_DOMAIN_GROUPS];
      if (yKey) {
        let aggProp = groupCount();
        if (aggregation === 'count') {
          // Nothing to do.
        } else if (aggregation === 'sum') {
          aggProp = groupSum([yKey]);
        } else if (aggregation === 'mean') {
          aggProp = groupAverage([yKey]);
        }
        if (areaPlot) {
          aggProp = aggregateFunctions_area([yKey], aggProp);
        }
        props.push(valueProperty(yKey, true, {
          invalidValue: undefined
        }), aggProp);
      } else {
        let aggProp = groupCount();
        if (areaPlot) {
          aggProp = aggregateFunctions_area([], aggProp);
        }
        props.push(aggProp);
      }
      const groupByFn = dataSet => {
        var _a;
        const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
        if (xExtent.length === 0) {
          // No buckets can be calculated.
          dataSet.domain.groups = [];
          return () => [];
        }
        const bins = (_a = this.bins) !== null && _a !== void 0 ? _a : this.deriveBins(xExtent);
        const binCount = bins.length;
        this.calculatedBins = [...bins];
        return item => {
          const xValue = item.keys[0];
          for (let i = 0; i < binCount; i++) {
            const nextBin = bins[i];
            if (xValue >= nextBin[0] && xValue < nextBin[1]) {
              return nextBin;
            }
            if (i === binCount - 1 && xValue <= nextBin[1]) {
              // Handle edge case of a value being at the maximum extent, and the
              // final bin aligning with it.
              return nextBin;
            }
          }
          return [];
        };
      };
      this.dataModel = new DataModel({
        props,
        dataVisible: this.visible,
        groupByFn
      });
      this.processedData = this.dataModel.processData(data !== null && data !== void 0 ? data : []);
    });
  }
  getDomain(direction) {
    var _a, _b, _c, _d;
    const {
      processedData
    } = this;
    if (!processedData) return [];
    const {
      domain: {
        aggValues: [yDomain] = []
      }
    } = processedData;
    const xDomainMin = (_a = this.calculatedBins) === null || _a === void 0 ? void 0 : _a[0][0];
    const xDomainMax = (_b = this.calculatedBins) === null || _b === void 0 ? void 0 : _b[((_d = (_c = this.calculatedBins) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) - 1][1];
    if (direction === ChartAxisDirection.X) {
      return fixNumericExtent([xDomainMin, xDomainMax]);
    }
    return fixNumericExtent(yDomain);
  }
  getNodeClickEvent(event, datum) {
    var _a, _b;
    return new CartesianSeriesNodeClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', (_b = this.yKey) !== null && _b !== void 0 ? _b : '', event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    var _a, _b;
    return new CartesianSeriesNodeDoubleClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', (_b = this.yKey) !== null && _b !== void 0 ? _b : '', event, datum, this);
  }
  createNodeData() {
    var _a;
    return histogramSeries_awaiter(this, void 0, void 0, function* () {
      const {
        xAxis,
        yAxis,
        processedData,
        ctx: {
          callbackCache
        }
      } = this;
      if (!this.seriesItemEnabled || !xAxis || !yAxis || !processedData || processedData.type !== 'grouped') {
        return [];
      }
      const {
        scale: xScale
      } = xAxis;
      const {
        scale: yScale
      } = yAxis;
      const {
        fill,
        stroke,
        strokeWidth,
        id: seriesId,
        yKey = '',
        xKey = ''
      } = this;
      const nodeData = [];
      const defaultLabelFormatter = params => String(params.value);
      const {
        label: {
          formatter: labelFormatter = defaultLabelFormatter,
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          color: labelColor
        }
      } = this;
      processedData.data.forEach(group => {
        var _a;
        const {
          aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],
          datum,
          datum: {
            length: frequency
          },
          keys: domain,
          keys: [xDomainMin, xDomainMax]
        } = group;
        const xMinPx = xScale.convert(xDomainMin);
        const xMaxPx = xScale.convert(xDomainMax);
        const total = negativeAgg + positiveAgg;
        const yZeroPx = yScale.convert(0);
        const yMaxPx = yScale.convert(total);
        const w = xMaxPx - xMinPx;
        const h = Math.abs(yMaxPx - yZeroPx);
        const selectionDatumLabel = total !== 0 ? {
          text: (_a = callbackCache.call(labelFormatter, {
            value: total,
            seriesId
          })) !== null && _a !== void 0 ? _a : String(total),
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          fill: labelColor,
          x: xMinPx + w / 2,
          y: yMaxPx + h / 2
        } : undefined;
        const nodeMidPoint = {
          x: xMinPx + w / 2,
          y: yMaxPx + h / 2
        };
        nodeData.push({
          series: this,
          datum,
          // since each selection is an aggregation of multiple data.
          aggregatedValue: total,
          frequency,
          domain: domain,
          yKey,
          xKey,
          x: xMinPx,
          y: yMaxPx,
          width: w,
          height: h,
          nodeMidPoint,
          fill: fill,
          stroke: stroke,
          strokeWidth: strokeWidth,
          label: selectionDatumLabel
        });
      });
      return [{
        itemId: (_a = this.yKey) !== null && _a !== void 0 ? _a : this.id,
        nodeData,
        labelData: nodeData
      }];
    });
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    return histogramSeries_awaiter(this, void 0, void 0, function* () {
      const {
        nodeData,
        datumSelection
      } = opts;
      return datumSelection.update(nodeData, rect => {
        rect.tag = HistogramSeriesNodeTag.Bin;
        rect.crisp = true;
      });
    });
  }
  updateDatumNodes(opts) {
    return histogramSeries_awaiter(this, void 0, void 0, function* () {
      const {
        datumSelection,
        isHighlight: isDatumHighlighted
      } = opts;
      const {
        fillOpacity: seriesFillOpacity,
        strokeOpacity,
        shadow,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            fillOpacity: highlightFillOpacity = seriesFillOpacity,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth
          }
        }
      } = this;
      datumSelection.each((rect, datum, index) => {
        var _a, _b;
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined ? highlightedDatumStrokeWidth : datum.strokeWidth;
        const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;
        rect.x = datum.x;
        rect.width = datum.width;
        rect.fill = (_a = isDatumHighlighted ? highlightedFill : undefined) !== null && _a !== void 0 ? _a : datum.fill;
        rect.stroke = (_b = isDatumHighlighted ? highlightedStroke : undefined) !== null && _b !== void 0 ? _b : datum.stroke;
        rect.fillOpacity = fillOpacity;
        rect.strokeOpacity = strokeOpacity;
        rect.strokeWidth = strokeWidth;
        rect.lineDash = this.lineDash;
        rect.lineDashOffset = this.lineDashOffset;
        rect.fillShadow = shadow;
        rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;
        rect.visible = datum.height > 0; // prevent stroke from rendering for zero height columns
      });
    });
  }

  updateLabelSelection(opts) {
    return histogramSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelData,
        labelSelection
      } = opts;
      return labelSelection.update(labelData, text => {
        text.tag = HistogramSeriesNodeTag.Label;
        text.pointerEvents = PointerEvents.None;
        text.textAlign = 'center';
        text.textBaseline = 'middle';
      });
    });
  }
  updateLabelNodes(opts) {
    return histogramSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelSelection
      } = opts;
      const labelEnabled = this.label.enabled;
      labelSelection.each((text, datum) => {
        const label = datum.label;
        if (label && labelEnabled) {
          text.text = label.text;
          text.x = label.x;
          text.y = label.y;
          text.fontStyle = label.fontStyle;
          text.fontWeight = label.fontWeight;
          text.fontSize = label.fontSize;
          text.fontFamily = label.fontFamily;
          text.fill = label.fill;
          text.visible = true;
        } else {
          text.visible = false;
        }
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    const {
      xKey,
      yKey = '',
      xAxis,
      yAxis
    } = this;
    if (!xKey || !xAxis || !yAxis) {
      return '';
    }
    const {
      xName,
      yName,
      fill: color,
      tooltip,
      aggregation,
      id: seriesId
    } = this;
    const {
      renderer: tooltipRenderer
    } = tooltip;
    const {
      aggregatedValue,
      frequency,
      domain,
      domain: [rangeMin, rangeMax]
    } = nodeDatum;
    const title = `${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;
    let content = yKey ? `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : '';
    content += `<b>Frequency</b>: ${frequency}`;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    if (tooltipRenderer) {
      return toTooltipHtml(tooltipRenderer({
        datum: {
          data: nodeDatum.datum,
          aggregatedValue: nodeDatum.aggregatedValue,
          domain: nodeDatum.domain,
          frequency: nodeDatum.frequency
        },
        xKey,
        xValue: domain,
        xName,
        yKey,
        yValue: aggregatedValue,
        yName,
        color,
        title,
        seriesId
      }), defaults);
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    var _a;
    const {
      id,
      data,
      xKey,
      yName,
      visible,
      fill,
      stroke,
      fillOpacity,
      strokeOpacity
    } = this;
    if (!data || data.length === 0) {
      return [];
    }
    const legendData = [{
      legendType: 'category',
      id,
      itemId: xKey,
      seriesId: id,
      enabled: visible,
      label: {
        text: (_a = yName !== null && yName !== void 0 ? yName : xKey) !== null && _a !== void 0 ? _a : 'Frequency'
      },
      marker: {
        fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',
        stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',
        fillOpacity: fillOpacity,
        strokeOpacity: strokeOpacity
      }
    }];
    return legendData;
  }
  animateEmptyUpdateReady({
    datumSelections,
    labelSelections
  }) {
    const duration = 1000;
    const labelDuration = 200;
    let startingY = 0;
    datumSelections.forEach(datumSelection => datumSelection.each((_, datum) => {
      startingY = Math.max(startingY, datum.height + datum.y);
    }));
    datumSelections.forEach(datumSelection => {
      datumSelection.each((rect, datum) => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animateMany(`${this.id}_empty-update-ready_${rect.id}`, [{
          from: startingY,
          to: datum.y
        }, {
          from: 0,
          to: datum.height
        }], {
          disableInteractions: true,
          duration,
          ease: easeOut,
          repeat: 0,
          onUpdate([y, height]) {
            rect.y = y;
            rect.height = height;
            rect.x = datum.x;
            rect.width = datum.width;
          }
        });
      });
    });
    labelSelections.forEach(labelSelection => {
      labelSelection.each(label => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, {
          from: 0,
          to: 1,
          delay: duration,
          duration: labelDuration,
          ease: linear,
          repeat: 0,
          onUpdate: opacity => {
            label.opacity = opacity;
          }
        });
      });
    });
  }
  animateReadyUpdate({
    datumSelections
  }) {
    datumSelections.forEach(datumSelection => {
      this.resetSelectionRects(datumSelection);
    });
  }
  animateReadyHighlight(highlightSelection) {
    this.resetSelectionRects(highlightSelection);
  }
  animateReadyResize({
    datumSelections
  }) {
    var _a;
    (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.stop();
    datumSelections.forEach(datumSelection => {
      this.resetSelectionRects(datumSelection);
    });
  }
  resetSelectionRects(selection) {
    selection.each((rect, datum) => {
      rect.x = datum.x;
      rect.y = datum.y;
      rect.width = datum.width;
      rect.height = datum.height;
    });
  }
  isLabelEnabled() {
    return this.label.enabled;
  }
}
HistogramSeries.className = 'HistogramSeries';
HistogramSeries.type = 'histogram';
histogramSeries_decorate([Validate(OPT_COLOR_STRING)], HistogramSeries.prototype, "fill", void 0);
histogramSeries_decorate([Validate(OPT_COLOR_STRING)], HistogramSeries.prototype, "stroke", void 0);
histogramSeries_decorate([Validate(NUMBER(0, 1))], HistogramSeries.prototype, "fillOpacity", void 0);
histogramSeries_decorate([Validate(NUMBER(0, 1))], HistogramSeries.prototype, "strokeOpacity", void 0);
histogramSeries_decorate([Validate(OPT_LINE_DASH)], HistogramSeries.prototype, "lineDash", void 0);
histogramSeries_decorate([Validate(NUMBER(0))], HistogramSeries.prototype, "lineDashOffset", void 0);
histogramSeries_decorate([Validate(OPT_STRING)], HistogramSeries.prototype, "xKey", void 0);
histogramSeries_decorate([Validate(BOOLEAN)], HistogramSeries.prototype, "areaPlot", void 0);
histogramSeries_decorate([Validate(OPT_ARRAY())], HistogramSeries.prototype, "bins", void 0);
histogramSeries_decorate([Validate(HISTOGRAM_AGGREGATION)], HistogramSeries.prototype, "aggregation", void 0);
histogramSeries_decorate([Validate(OPT_NUMBER(0))], HistogramSeries.prototype, "binCount", void 0);
histogramSeries_decorate([Validate(OPT_STRING)], HistogramSeries.prototype, "xName", void 0);
histogramSeries_decorate([Validate(OPT_STRING)], HistogramSeries.prototype, "yKey", void 0);
histogramSeries_decorate([Validate(OPT_STRING)], HistogramSeries.prototype, "yName", void 0);
histogramSeries_decorate([Validate(NUMBER(0))], HistogramSeries.prototype, "strokeWidth", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/lineSeries.mjs
var lineSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var lineSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};














class LineSeriesLabel extends Label {
  constructor() {
    super(...arguments);
    this.formatter = undefined;
  }
}
lineSeries_decorate([Validate(OPT_FUNCTION)], LineSeriesLabel.prototype, "formatter", void 0);
class LineSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
    this.format = undefined;
  }
}
lineSeries_decorate([Validate(OPT_FUNCTION)], LineSeriesTooltip.prototype, "renderer", void 0);
lineSeries_decorate([Validate(OPT_STRING)], LineSeriesTooltip.prototype, "format", void 0);
class LineSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      hasMarkers: true,
      pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST, SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH]
    });
    this.marker = new CartesianSeriesMarker();
    this.label = new LineSeriesLabel();
    this.title = undefined;
    this.stroke = '#874349';
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.tooltip = new LineSeriesTooltip();
    this.xKey = undefined;
    this.xName = undefined;
    this.yKey = undefined;
    this.yName = undefined;
    const {
      marker,
      label
    } = this;
    marker.fill = '#c16068';
    marker.stroke = '#874349';
    label.enabled = false;
  }
  processData() {
    return lineSeries_awaiter(this, void 0, void 0, function* () {
      const {
        xAxis,
        yAxis,
        xKey = '',
        yKey = ''
      } = this;
      const data = xKey && yKey && this.data ? this.data : [];
      const isContinuousX = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale) instanceof ContinuousScale;
      const isContinuousY = (yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale) instanceof ContinuousScale;
      this.dataModel = new DataModel({
        props: [valueProperty(xKey, isContinuousX, {
          id: 'xValue'
        }), valueProperty(yKey, isContinuousY, {
          id: 'yValue',
          invalidValue: undefined
        })],
        dataVisible: this.visible
      });
      this.processedData = this.dataModel.processData(data !== null && data !== void 0 ? data : []);
    });
  }
  getDomain(direction) {
    const {
      xAxis,
      yAxis,
      dataModel,
      processedData
    } = this;
    if (!processedData || !dataModel) return [];
    const xDef = dataModel.resolveProcessedDataDefById(`xValue`);
    if (direction === ChartAxisDirection.X) {
      const domain = dataModel.getDomain(`xValue`, processedData);
      if ((xDef === null || xDef === void 0 ? void 0 : xDef.valueType) === 'category') {
        return domain;
      }
      return this.fixNumericExtent(extent(domain), xAxis);
    } else {
      const domain = dataModel.getDomain(`yValue`, processedData);
      return this.fixNumericExtent(domain, yAxis);
    }
  }
  createNodeData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    return lineSeries_awaiter(this, void 0, void 0, function* () {
      const {
        processedData,
        dataModel,
        xAxis,
        yAxis,
        marker: {
          enabled: markerEnabled,
          size: markerSize,
          strokeWidth
        },
        ctx: {
          callbackCache
        }
      } = this;
      if (!processedData || !dataModel || !xAxis || !yAxis) {
        return [];
      }
      const {
        label,
        yKey = '',
        xKey = '',
        id: seriesId
      } = this;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;
      const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;
      const nodeData = new Array(processedData.data.length);
      const size = markerEnabled ? markerSize : 0;
      const xIdx = (_e = (_d = (_c = this.dataModel) === null || _c === void 0 ? void 0 : _c.resolveProcessedDataIndexById(`xValue`)) === null || _d === void 0 ? void 0 : _d.index) !== null && _e !== void 0 ? _e : -1;
      const yIdx = (_h = (_g = (_f = this.dataModel) === null || _f === void 0 ? void 0 : _f.resolveProcessedDataIndexById(`yValue`)) === null || _g === void 0 ? void 0 : _g.index) !== null && _h !== void 0 ? _h : -1;
      let moveTo = true;
      let prevXInRange = undefined;
      let nextPoint = undefined;
      let actualLength = 0;
      for (let i = 0; i < processedData.data.length; i++) {
        const {
          datum,
          values
        } = nextPoint !== null && nextPoint !== void 0 ? nextPoint : processedData.data[i];
        const xDatum = values[xIdx];
        const yDatum = values[yIdx];
        if (yDatum === undefined) {
          prevXInRange = undefined;
          moveTo = true;
        } else {
          const x = xScale.convert(xDatum) + xOffset;
          if (isNaN(x)) {
            prevXInRange = undefined;
            moveTo = true;
            continue;
          }
          const tolerance = ((_j = xScale.bandwidth) !== null && _j !== void 0 ? _j : markerSize * 0.5 + (strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0)) + 1;
          nextPoint = ((_k = processedData.data[i + 1]) === null || _k === void 0 ? void 0 : _k.values[yIdx]) === undefined ? undefined : processedData.data[i + 1];
          const nextXDatum = (_l = processedData.data[i + 1]) === null || _l === void 0 ? void 0 : _l.values[xIdx];
          const xInRange = xAxis.inRangeEx(x, 0, tolerance);
          const nextXInRange = nextPoint && xAxis.inRangeEx(xScale.convert(nextXDatum) + xOffset, 0, tolerance);
          if (xInRange === -1 && nextXInRange === -1) {
            moveTo = true;
            continue;
          }
          if (xInRange === 1 && prevXInRange === 1) {
            moveTo = true;
            continue;
          }
          prevXInRange = xInRange;
          const y = yScale.convert(yDatum) + yOffset;
          let labelText;
          if (label.formatter) {
            labelText = callbackCache.call(label.formatter, {
              value: yDatum,
              seriesId
            });
          }
          if (labelText !== undefined) {
            // Label retrieved from formatter successfully.
          } else if (typeof yDatum === 'number' && isFinite(yDatum)) {
            labelText = yDatum.toFixed(2);
          } else if (yDatum) {
            labelText = String(yDatum);
          }
          nodeData[actualLength++] = {
            series: this,
            datum,
            yKey,
            xKey,
            point: {
              x,
              y,
              moveTo,
              size
            },
            nodeMidPoint: {
              x,
              y
            },
            label: labelText ? {
              text: labelText,
              fontStyle: label.fontStyle,
              fontWeight: label.fontWeight,
              fontSize: label.fontSize,
              fontFamily: label.fontFamily,
              textAlign: 'center',
              textBaseline: 'bottom',
              fill: label.color
            } : undefined
          };
          moveTo = false;
        }
      }
      nodeData.length = actualLength;
      return [{
        itemId: yKey,
        nodeData,
        labelData: nodeData
      }];
    });
  }
  isPathOrSelectionDirty() {
    return this.marker.isDirty();
  }
  markerFactory() {
    const {
      shape
    } = this.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updateMarkerSelection(opts) {
    return lineSeries_awaiter(this, void 0, void 0, function* () {
      let {
        nodeData
      } = opts;
      const {
        markerSelection
      } = opts;
      const {
        shape,
        enabled
      } = this.marker;
      nodeData = shape && enabled ? nodeData : [];
      if (this.marker.isDirty()) {
        markerSelection.clear();
      }
      return markerSelection.update(nodeData);
    });
  }
  updateMarkerNodes(opts) {
    var _a;
    return lineSeries_awaiter(this, void 0, void 0, function* () {
      const {
        markerSelection,
        isHighlight: isDatumHighlighted
      } = opts;
      const {
        marker,
        marker: {
          fillOpacity: markerFillOpacity
        },
        xKey = '',
        yKey = '',
        stroke: lineStroke,
        strokeOpacity,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            fillOpacity: highlightFillOpacity = markerFillOpacity,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth
          }
        },
        id: seriesId,
        ctx: {
          callbackCache
        }
      } = this;
      const {
        size,
        formatter
      } = marker;
      const markerStrokeWidth = (_a = marker.strokeWidth) !== null && _a !== void 0 ? _a : this.strokeWidth;
      const customMarker = typeof marker.shape === 'function';
      markerSelection.each((node, datum) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const fill = isDatumHighlighted && highlightedFill !== undefined ? highlightedFill : marker.fill;
        const fillOpacity = isDatumHighlighted ? highlightFillOpacity : markerFillOpacity;
        const stroke = isDatumHighlighted && highlightedStroke !== undefined ? highlightedStroke : (_a = marker.stroke) !== null && _a !== void 0 ? _a : lineStroke;
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined ? highlightedDatumStrokeWidth : markerStrokeWidth;
        let format = undefined;
        if (formatter) {
          format = callbackCache.call(formatter, {
            datum: datum.datum,
            xKey,
            yKey,
            fill,
            stroke,
            strokeWidth,
            size,
            highlighted: isDatumHighlighted,
            seriesId
          });
        }
        node.fill = (_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : fill;
        node.stroke = (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke;
        node.strokeWidth = (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth;
        node.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;
        node.strokeOpacity = (_f = (_e = marker.strokeOpacity) !== null && _e !== void 0 ? _e : strokeOpacity) !== null && _f !== void 0 ? _f : 1;
        node.size = (_g = format === null || format === void 0 ? void 0 : format.size) !== null && _g !== void 0 ? _g : size;
        node.translationX = datum.point.x;
        node.translationY = datum.point.y;
        node.visible = node.size > 0 && !isNaN(datum.point.x) && !isNaN(datum.point.y);
        if (!customMarker || node.dirtyPath) {
          return;
        }
        // Only for cutom marker shapes
        node.path.clear({
          trackChanges: true
        });
        node.updatePath();
        node.checkPathDirty();
      });
      if (!isDatumHighlighted) {
        this.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return lineSeries_awaiter(this, void 0, void 0, function* () {
      let {
        labelData
      } = opts;
      const {
        labelSelection
      } = opts;
      const {
        shape,
        enabled
      } = this.marker;
      labelData = shape && enabled ? labelData : [];
      return labelSelection.update(labelData);
    });
  }
  updateLabelNodes(opts) {
    return lineSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelSelection
      } = opts;
      const {
        enabled: labelEnabled,
        fontStyle,
        fontWeight,
        fontSize,
        fontFamily,
        color
      } = this.label;
      labelSelection.each((text, datum) => {
        const {
          point,
          label
        } = datum;
        if (datum && label && labelEnabled) {
          text.fontStyle = fontStyle;
          text.fontWeight = fontWeight;
          text.fontSize = fontSize;
          text.fontFamily = fontFamily;
          text.textAlign = label.textAlign;
          text.textBaseline = label.textBaseline;
          text.text = label.text;
          text.x = point.x;
          text.y = point.y - 10;
          text.fill = color;
          text.visible = true;
        } else {
          text.visible = false;
        }
      });
    });
  }
  getNodeClickEvent(event, datum) {
    var _a, _b;
    return new CartesianSeriesNodeClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', (_b = this.yKey) !== null && _b !== void 0 ? _b : '', event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    var _a, _b;
    return new CartesianSeriesNodeDoubleClickEvent((_a = this.xKey) !== null && _a !== void 0 ? _a : '', (_b = this.yKey) !== null && _b !== void 0 ? _b : '', event, datum, this);
  }
  getTooltipHtml(nodeDatum) {
    var _a, _b;
    const {
      xKey,
      yKey,
      xAxis,
      yAxis
    } = this;
    if (!xKey || !yKey || !xAxis || !yAxis) {
      return '';
    }
    const {
      xName,
      yName,
      tooltip,
      marker,
      id: seriesId
    } = this;
    const {
      renderer: tooltipRenderer,
      format: tooltipFormat
    } = tooltip;
    const datum = nodeDatum.datum;
    const xValue = datum[xKey];
    const yValue = datum[yKey];
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml((_a = this.title) !== null && _a !== void 0 ? _a : yName);
    const content = sanitizeHtml(xString + ': ' + yString);
    const {
      formatter: markerFormatter,
      fill,
      stroke,
      strokeWidth: markerStrokeWidth,
      size
    } = marker;
    const strokeWidth = markerStrokeWidth !== null && markerStrokeWidth !== void 0 ? markerStrokeWidth : this.strokeWidth;
    let format = undefined;
    if (markerFormatter) {
      format = markerFormatter({
        datum,
        xKey,
        yKey,
        fill,
        stroke,
        strokeWidth,
        size,
        highlighted: false,
        seriesId
      });
    }
    const color = (_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : fill;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    if (tooltipFormat || tooltipRenderer) {
      const params = {
        datum,
        xKey,
        xValue,
        xName,
        yKey,
        yValue,
        yName,
        title,
        color,
        seriesId
      };
      if (tooltipFormat) {
        return toTooltipHtml({
          content: interpolate(tooltipFormat, params)
        }, defaults);
      }
      if (tooltipRenderer) {
        return toTooltipHtml(tooltipRenderer(params), defaults);
      }
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    var _a, _b, _c, _d, _e, _f, _g;
    const {
      id,
      data,
      xKey,
      yKey,
      yName,
      visible,
      title,
      marker,
      stroke,
      strokeOpacity
    } = this;
    if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey)) {
      return [];
    }
    const legendData = [{
      legendType: 'category',
      id: id,
      itemId: yKey,
      seriesId: id,
      enabled: visible,
      label: {
        text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey
      },
      marker: {
        shape: marker.shape,
        fill: (_b = marker.fill) !== null && _b !== void 0 ? _b : 'rgba(0, 0, 0, 0)',
        stroke: (_d = (_c = marker.stroke) !== null && _c !== void 0 ? _c : stroke) !== null && _d !== void 0 ? _d : 'rgba(0, 0, 0, 0)',
        fillOpacity: (_e = marker.fillOpacity) !== null && _e !== void 0 ? _e : 1,
        strokeOpacity: (_g = (_f = marker.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity) !== null && _g !== void 0 ? _g : 1
      }
    }];
    return legendData;
  }
  animateEmptyUpdateReady({
    markerSelections,
    labelSelections,
    contextData,
    paths,
    seriesRect
  }) {
    contextData.forEach(({
      nodeData
    }, contextDataIndex) => {
      var _a, _b;
      const [lineNode] = paths[contextDataIndex];
      const {
        path: linePath
      } = lineNode;
      lineNode.fill = undefined;
      lineNode.lineJoin = 'round';
      lineNode.pointerEvents = PointerEvents.None;
      lineNode.stroke = this.stroke;
      lineNode.strokeWidth = this.getStrokeWidth(this.strokeWidth);
      lineNode.strokeOpacity = this.strokeOpacity;
      lineNode.lineDash = this.lineDash;
      lineNode.lineDashOffset = this.lineDashOffset;
      const duration = 1000;
      const markerDuration = 200;
      const animationOptions = {
        from: 0,
        to: (_a = seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width) !== null && _a !== void 0 ? _a : 0,
        disableInteractions: true,
        ease: linear,
        repeat: 0
      };
      (_b = this.animationManager) === null || _b === void 0 ? void 0 : _b.animate(`${this.id}_empty-update-ready`, Object.assign(Object.assign({}, animationOptions), {
        duration,
        onUpdate(xValue) {
          linePath.clear({
            trackChanges: true
          });
          nodeData.forEach((datum, index) => {
            if (datum.point.x <= xValue) {
              // Draw/move the full segment if past the end of this segment
              if (datum.point.moveTo) {
                linePath.moveTo(datum.point.x, datum.point.y);
              } else {
                linePath.lineTo(datum.point.x, datum.point.y);
              }
            } else if (index > 0 && nodeData[index - 1].point.x < xValue) {
              // Draw/move partial line if in between the start and end of this segment
              const start = nodeData[index - 1].point;
              const end = datum.point;
              const x = xValue;
              const y = start.y + (x - start.x) * (end.y - start.y) / (end.x - start.x);
              if (datum.point.moveTo) {
                linePath.moveTo(x, y);
              } else {
                linePath.lineTo(x, y);
              }
            }
          });
          lineNode.checkPathDirty();
        }
      }));
      markerSelections[contextDataIndex].each((marker, datum) => {
        var _a, _b, _c, _d;
        const delay = (seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width) ? datum.point.x / seriesRect.width * duration : 0;
        const format = this.animateFormatter(datum);
        const size = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        (_c = this.animationManager) === null || _c === void 0 ? void 0 : _c.animate(`${this.id}_empty-update-ready_${marker.id}`, Object.assign(Object.assign({}, animationOptions), {
          to: (_d = format === null || format === void 0 ? void 0 : format.size) !== null && _d !== void 0 ? _d : size,
          delay,
          duration: markerDuration,
          onUpdate(size) {
            marker.size = size;
          }
        }));
      });
      labelSelections[contextDataIndex].each((label, datum) => {
        var _a;
        const delay = (seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width) ? datum.point.x / seriesRect.width * duration : 0;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, {
          from: 0,
          to: 1,
          delay,
          duration: markerDuration,
          ease: linear,
          repeat: 0,
          onUpdate: opacity => {
            label.opacity = opacity;
          }
        });
      });
    });
  }
  animateReadyUpdate(data) {
    this.resetMarkersAndPaths(data);
  }
  animateReadyResize(data) {
    var _a;
    (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.stop();
    this.resetMarkersAndPaths(data);
  }
  resetMarkersAndPaths({
    markerSelections,
    contextData,
    paths
  }) {
    contextData.forEach(({
      nodeData
    }, contextDataIndex) => {
      const [lineNode] = paths[contextDataIndex];
      const {
        path: linePath
      } = lineNode;
      lineNode.stroke = this.stroke;
      lineNode.strokeWidth = this.getStrokeWidth(this.strokeWidth);
      lineNode.strokeOpacity = this.strokeOpacity;
      lineNode.lineDash = this.lineDash;
      lineNode.lineDashOffset = this.lineDashOffset;
      linePath.clear({
        trackChanges: true
      });
      nodeData.forEach(datum => {
        if (datum.point.moveTo) {
          linePath.moveTo(datum.point.x, datum.point.y);
        } else {
          linePath.lineTo(datum.point.x, datum.point.y);
        }
      });
      lineNode.checkPathDirty();
      markerSelections[contextDataIndex].each((marker, datum) => {
        var _a, _b, _c;
        const format = this.animateFormatter(datum);
        const size = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        marker.size = (_c = format === null || format === void 0 ? void 0 : format.size) !== null && _c !== void 0 ? _c : size;
      });
    });
  }
  animateFormatter(datum) {
    var _a, _b;
    const {
      marker,
      xKey = '',
      yKey = '',
      stroke: lineStroke,
      id: seriesId,
      ctx: {
        callbackCache
      }
    } = this;
    const {
      size,
      formatter
    } = marker;
    const fill = marker.fill;
    const stroke = (_a = marker.stroke) !== null && _a !== void 0 ? _a : lineStroke;
    const strokeWidth = (_b = marker.strokeWidth) !== null && _b !== void 0 ? _b : this.strokeWidth;
    let format = undefined;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum: datum.datum,
        xKey,
        yKey,
        fill,
        stroke,
        strokeWidth,
        size,
        highlighted: false,
        seriesId
      });
    }
    return format;
  }
  isLabelEnabled() {
    return this.label.enabled;
  }
}
LineSeries.className = 'LineSeries';
LineSeries.type = 'line';
lineSeries_decorate([Validate(OPT_STRING)], LineSeries.prototype, "title", void 0);
lineSeries_decorate([Validate(OPT_COLOR_STRING)], LineSeries.prototype, "stroke", void 0);
lineSeries_decorate([Validate(OPT_LINE_DASH)], LineSeries.prototype, "lineDash", void 0);
lineSeries_decorate([Validate(NUMBER(0))], LineSeries.prototype, "lineDashOffset", void 0);
lineSeries_decorate([Validate(NUMBER(0))], LineSeries.prototype, "strokeWidth", void 0);
lineSeries_decorate([Validate(NUMBER(0, 1))], LineSeries.prototype, "strokeOpacity", void 0);
lineSeries_decorate([Validate(OPT_STRING)], LineSeries.prototype, "xKey", void 0);
lineSeries_decorate([Validate(OPT_STRING)], LineSeries.prototype, "xName", void 0);
lineSeries_decorate([Validate(OPT_STRING)], LineSeries.prototype, "yKey", void 0);
lineSeries_decorate([Validate(OPT_STRING)], LineSeries.prototype, "yName", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scale/colorScale.mjs




class ColorScale {
  constructor() {
    this.domain = [0, 1];
    this.range = ['red', 'blue'];
    this.parsedRange = this.range.map(v => Color.fromString(v));
  }
  update() {
    const {
      domain,
      range
    } = this;
    if (domain.length < 2) {
      Logger.warnOnce('`colorDomain` should have at least 2 values.');
      if (domain.length === 0) {
        domain.push(0, 1);
      } else if (domain.length === 1) {
        domain.push(domain[0] + 1);
      }
    }
    for (let i = 1; i < domain.length; i++) {
      const a = domain[i - 1];
      const b = domain[i];
      if (a >= b) {
        Logger.warnOnce('`colorDomain` values should be supplied in ascending order.');
        domain.sort((a, b) => a - b);
        break;
      }
    }
    const isSmallRange = range.length < domain.length;
    if (isSmallRange || domain.length > 2 && range.length > domain.length) {
      Logger.warnOnce('Number of elements in `colorRange` needs to match the number of elements in `colorDomain`.');
      if (isSmallRange) {
        for (let i = range.length; i < domain.length; i++) {
          range.push('black');
        }
      } else {
        range.splice(domain.length);
      }
    }
    this.parsedRange = this.range.map(v => Color.fromString(v));
  }
  convert(x) {
    const {
      domain,
      range,
      parsedRange
    } = this;
    const d0 = domain[0];
    const d1 = domain[domain.length - 1];
    const r0 = range[0];
    const r1 = range[range.length - 1];
    if (x <= d0) {
      return r0;
    }
    if (x >= d1) {
      return r1;
    }
    let index;
    let q;
    if (domain.length === 2) {
      const t = (x - d0) / (d1 - d0);
      const step = 1 / (range.length - 1);
      index = range.length <= 2 ? 0 : Math.min(Math.floor(t * (range.length - 1)), range.length - 2);
      q = (t - index * step) / step;
    } else {
      for (index = 0; index < domain.length - 2; index++) {
        if (x < domain[index + 1]) {
          break;
        }
      }
      const a = domain[index];
      const b = domain[index + 1];
      q = (x - a) / (b - a);
    }
    const c0 = parsedRange[index];
    const c1 = parsedRange[index + 1];
    return color(c0, c1)(q);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/cartesian/scatterSeries.mjs
var scatterSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var scatterSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};















class ScatterSeriesLabel extends Label {
  constructor() {
    super(...arguments);
    this.formatter = undefined;
  }
}
scatterSeries_decorate([Validate(OPT_FUNCTION)], ScatterSeriesLabel.prototype, "formatter", void 0);
class ScatterSeriesNodeBaseClickEvent extends CartesianSeriesNodeBaseClickEvent {
  constructor(sizeKey, xKey, yKey, nativeEvent, datum, series) {
    super(xKey, yKey, nativeEvent, datum, series);
    this.sizeKey = sizeKey;
  }
}
class ScatterSeriesNodeClickEvent extends ScatterSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeClick';
  }
}
class ScatterSeriesNodeDoubleClickEvent extends ScatterSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeDoubleClick';
  }
}
class ScatterSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
  }
}
scatterSeries_decorate([Validate(OPT_FUNCTION)], ScatterSeriesTooltip.prototype, "renderer", void 0);
class ScatterSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST, SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH],
      pathsPerSeries: 0,
      hasMarkers: true
    });
    this.sizeScale = new LinearScale();
    this.marker = new CartesianSeriesMarker();
    this.label = new ScatterSeriesLabel();
    this.title = undefined;
    this.labelKey = undefined;
    this.xName = undefined;
    this.yName = undefined;
    this.sizeName = 'Size';
    this.labelName = 'Label';
    this.xKey = undefined;
    this.yKey = undefined;
    this.sizeKey = undefined;
    this.colorKey = undefined;
    this.colorName = 'Color';
    this.colorDomain = undefined;
    this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];
    this.colorScale = new ColorScale();
    this.tooltip = new ScatterSeriesTooltip();
    const {
      label
    } = this;
    label.enabled = false;
  }
  processData() {
    var _a, _b, _c, _d, _e, _f;
    return scatterSeries_awaiter(this, void 0, void 0, function* () {
      const {
        xKey = '',
        yKey = '',
        sizeKey,
        xAxis,
        yAxis,
        marker,
        data
      } = this;
      const isContinuousX = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale) instanceof ContinuousScale;
      const isContinuousY = (yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale) instanceof ContinuousScale;
      const {
        colorScale,
        colorDomain,
        colorRange,
        colorKey
      } = this;
      this.dataModel = new DataModel({
        props: [valueProperty(xKey, isContinuousX, {
          id: `xValue`
        }), valueProperty(yKey, isContinuousY, {
          id: `yValue`
        }), ...(sizeKey ? [valueProperty(sizeKey, true, {
          id: `sizeValue`
        })] : []), ...(colorKey ? [valueProperty(colorKey, true, {
          id: `colorValue`
        })] : [])],
        dataVisible: this.visible
      });
      this.processedData = this.dataModel.processData(data !== null && data !== void 0 ? data : []);
      if (sizeKey) {
        const sizeKeyIdx = (_b = (_a = this.dataModel.resolveProcessedDataIndexById(`sizeValue`)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
        const processedSize = (_d = (_c = this.processedData) === null || _c === void 0 ? void 0 : _c.domain.values[sizeKeyIdx]) !== null && _d !== void 0 ? _d : [];
        this.sizeScale.domain = marker.domain ? marker.domain : processedSize;
      }
      if (colorKey) {
        const colorKeyIdx = (_f = (_e = this.dataModel.resolveProcessedDataIndexById(`colorValue`)) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : -1;
        colorScale.domain = colorDomain !== null && colorDomain !== void 0 ? colorDomain : this.processedData.domain.values[colorKeyIdx];
        colorScale.range = colorRange;
        colorScale.update();
      }
    });
  }
  getDomain(direction) {
    const {
      dataModel,
      processedData
    } = this;
    if (!processedData || !dataModel) return [];
    const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;
    const dataDef = dataModel.resolveProcessedDataDefById(id);
    const domain = dataModel.getDomain(id, processedData);
    if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.valueType) === 'category') {
      return domain;
    }
    const axis = direction === ChartAxisDirection.X ? this.xAxis : this.yAxis;
    return this.fixNumericExtent(extent(domain), axis);
  }
  getNodeClickEvent(event, datum) {
    var _a, _b;
    return new ScatterSeriesNodeClickEvent(this.sizeKey, (_a = this.xKey) !== null && _a !== void 0 ? _a : '', (_b = this.yKey) !== null && _b !== void 0 ? _b : '', event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    var _a, _b;
    return new ScatterSeriesNodeDoubleClickEvent(this.sizeKey, (_a = this.xKey) !== null && _a !== void 0 ? _a : '', (_b = this.yKey) !== null && _b !== void 0 ? _b : '', event, datum, this);
  }
  createNodeData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return scatterSeries_awaiter(this, void 0, void 0, function* () {
      const {
        visible,
        xAxis,
        yAxis,
        yKey = '',
        xKey = '',
        label,
        labelKey,
        ctx: {
          callbackCache
        }
      } = this;
      const xDataIdx = (_a = this.dataModel) === null || _a === void 0 ? void 0 : _a.resolveProcessedDataIndexById(`xValue`);
      const yDataIdx = (_b = this.dataModel) === null || _b === void 0 ? void 0 : _b.resolveProcessedDataIndexById(`yValue`);
      if (!(xDataIdx && yDataIdx && visible && xAxis && yAxis)) {
        return [];
      }
      const {
        colorScale,
        sizeKey,
        colorKey,
        id: seriesId
      } = this;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_c = xScale.bandwidth) !== null && _c !== void 0 ? _c : 0) / 2;
      const yOffset = ((_d = yScale.bandwidth) !== null && _d !== void 0 ? _d : 0) / 2;
      const {
        sizeScale,
        marker
      } = this;
      const nodeData = new Array((_f = (_e = this.processedData) === null || _e === void 0 ? void 0 : _e.data.length) !== null && _f !== void 0 ? _f : 0);
      sizeScale.range = [marker.size, marker.maxSize];
      const font = label.getFont();
      let actualLength = 0;
      for (const {
        values,
        datum
      } of (_h = (_g = this.processedData) === null || _g === void 0 ? void 0 : _g.data) !== null && _h !== void 0 ? _h : []) {
        const xDatum = values[xDataIdx.index];
        const yDatum = values[yDataIdx.index];
        const x = xScale.convert(xDatum) + xOffset;
        const y = yScale.convert(yDatum) + yOffset;
        if (!this.checkRangeXY(x, y, xAxis, yAxis)) {
          continue;
        }
        let text;
        if (label.formatter) {
          text = callbackCache.call(label.formatter, {
            value: yDatum,
            seriesId,
            datum
          });
        }
        if (text === undefined) {
          text = labelKey ? String(datum[labelKey]) : '';
        }
        const size = HdpiCanvas.getTextSize(text, font);
        const markerSize = sizeKey ? sizeScale.convert(values[2]) : marker.size;
        const colorIdx = sizeKey ? 3 : 2;
        const fill = colorKey ? colorScale.convert(values[colorIdx]) : undefined;
        nodeData[actualLength++] = {
          series: this,
          itemId: yKey,
          yKey,
          xKey,
          datum,
          point: {
            x,
            y,
            size: markerSize
          },
          nodeMidPoint: {
            x,
            y
          },
          fill,
          label: Object.assign({
            text
          }, size)
        };
      }
      nodeData.length = actualLength;
      return [{
        itemId: (_j = this.yKey) !== null && _j !== void 0 ? _j : this.id,
        nodeData,
        labelData: nodeData
      }];
    });
  }
  isPathOrSelectionDirty() {
    return this.marker.isDirty();
  }
  getLabelData() {
    var _a;
    return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);
  }
  markerFactory() {
    const {
      shape
    } = this.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updateMarkerSelection(opts) {
    return scatterSeries_awaiter(this, void 0, void 0, function* () {
      const {
        nodeData,
        markerSelection
      } = opts;
      const {
        marker: {
          enabled
        }
      } = this;
      if (this.marker.isDirty()) {
        markerSelection.clear();
      }
      const data = enabled ? nodeData : [];
      return markerSelection.update(data);
    });
  }
  updateMarkerNodes(opts) {
    return scatterSeries_awaiter(this, void 0, void 0, function* () {
      const {
        markerSelection,
        isHighlight: isDatumHighlighted
      } = opts;
      const {
        marker,
        xKey = '',
        yKey = '',
        sizeScale,
        marker: {
          fillOpacity: markerFillOpacity,
          strokeOpacity: markerStrokeOpacity,
          strokeWidth: markerStrokeWidth
        },
        highlightStyle: {
          item: {
            fill: highlightedFill,
            fillOpacity: highlightFillOpacity = markerFillOpacity,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth
          }
        },
        id: seriesId,
        ctx: {
          callbackCache
        }
      } = this;
      const {
        formatter
      } = marker;
      sizeScale.range = [marker.size, marker.maxSize];
      const customMarker = typeof marker.shape === 'function';
      markerSelection.each((node, datum) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const fill = isDatumHighlighted && highlightedFill !== undefined ? highlightedFill : (_a = datum.fill) !== null && _a !== void 0 ? _a : marker.fill;
        const fillOpacity = isDatumHighlighted ? highlightFillOpacity : markerFillOpacity;
        const stroke = isDatumHighlighted && highlightedStroke !== undefined ? highlightedStroke : marker.stroke;
        const strokeOpacity = markerStrokeOpacity;
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined ? highlightedDatumStrokeWidth : markerStrokeWidth !== null && markerStrokeWidth !== void 0 ? markerStrokeWidth : 1;
        const size = (_c = (_b = datum.point) === null || _b === void 0 ? void 0 : _b.size) !== null && _c !== void 0 ? _c : 0;
        let format = undefined;
        if (formatter) {
          format = callbackCache.call(formatter, {
            datum: datum.datum,
            xKey,
            yKey,
            fill,
            stroke,
            strokeWidth,
            size,
            highlighted: isDatumHighlighted,
            seriesId
          });
        }
        node.fill = (_d = format === null || format === void 0 ? void 0 : format.fill) !== null && _d !== void 0 ? _d : fill;
        node.stroke = (_e = format === null || format === void 0 ? void 0 : format.stroke) !== null && _e !== void 0 ? _e : stroke;
        node.strokeWidth = (_f = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _f !== void 0 ? _f : strokeWidth;
        node.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;
        node.strokeOpacity = strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1;
        node.translationX = (_h = (_g = datum.point) === null || _g === void 0 ? void 0 : _g.x) !== null && _h !== void 0 ? _h : 0;
        node.translationY = (_k = (_j = datum.point) === null || _j === void 0 ? void 0 : _j.y) !== null && _k !== void 0 ? _k : 0;
        node.visible = node.size > 0;
        if (!customMarker || node.dirtyPath) {
          return;
        }
        // Only for custom marker shapes.
        node.path.clear({
          trackChanges: true
        });
        node.updatePath();
        node.checkPathDirty();
      });
      if (!isDatumHighlighted) {
        this.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    var _a, _b;
    return scatterSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelSelection
      } = opts;
      const {
        label: {
          enabled
        }
      } = this;
      const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];
      const placedNodeDatum = placedLabels.map(v => Object.assign(Object.assign({}, v.datum), {
        point: {
          x: v.x,
          y: v.y,
          size: v.datum.point.size
        }
      }));
      return labelSelection.update(placedNodeDatum);
    });
  }
  updateLabelNodes(opts) {
    return scatterSeries_awaiter(this, void 0, void 0, function* () {
      const {
        labelSelection
      } = opts;
      const {
        label
      } = this;
      labelSelection.each((text, datum) => {
        var _a, _b, _c, _d;
        text.text = datum.label.text;
        text.fill = label.color;
        text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        text.fontStyle = label.fontStyle;
        text.fontWeight = label.fontWeight;
        text.fontSize = label.fontSize;
        text.fontFamily = label.fontFamily;
        text.textAlign = 'left';
        text.textBaseline = 'top';
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a, _b, _c, _d, _e, _f, _g;
    const {
      xKey,
      yKey,
      xAxis,
      yAxis
    } = this;
    if (!xKey || !yKey || !xAxis || !yAxis) {
      return '';
    }
    const {
      marker,
      tooltip,
      xName,
      yName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      id: seriesId,
      ctx: {
        callbackCache
      }
    } = this;
    const {
      stroke
    } = marker;
    const fill = (_a = nodeDatum.fill) !== null && _a !== void 0 ? _a : marker.fill;
    const strokeWidth = this.getStrokeWidth((_b = marker.strokeWidth) !== null && _b !== void 0 ? _b : 1);
    const {
      formatter
    } = this.marker;
    let format = undefined;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum: nodeDatum,
        xKey,
        yKey,
        fill,
        stroke,
        strokeWidth,
        size: (_d = (_c = nodeDatum.point) === null || _c === void 0 ? void 0 : _c.size) !== null && _d !== void 0 ? _d : 0,
        highlighted: false,
        seriesId
      });
    }
    const color = (_f = (_e = format === null || format === void 0 ? void 0 : format.fill) !== null && _e !== void 0 ? _e : fill) !== null && _f !== void 0 ? _f : 'gray';
    const title = (_g = this.title) !== null && _g !== void 0 ? _g : yName;
    const datum = nodeDatum.datum;
    const xValue = datum[xKey];
    const yValue = datum[yKey];
    const xString = sanitizeHtml(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` + `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;
    if (sizeKey) {
      content += `<br><b>${sanitizeHtml(sizeName !== null && sizeName !== void 0 ? sizeName : sizeKey)}</b>: ${sanitizeHtml(datum[sizeKey])}`;
    }
    if (labelKey) {
      content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(datum[labelKey])}<br>` + content;
    }
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    const {
      renderer: tooltipRenderer
    } = tooltip;
    if (tooltipRenderer) {
      return toTooltipHtml(tooltipRenderer({
        datum,
        xKey,
        xValue,
        xName,
        yKey,
        yValue,
        yName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        title,
        color,
        seriesId
      }), defaults);
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    var _a, _b, _c, _d, _e;
    const {
      id,
      data,
      xKey,
      yKey,
      yName,
      title,
      visible,
      marker
    } = this;
    const {
      fill,
      stroke,
      fillOpacity,
      strokeOpacity
    } = marker;
    if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey)) {
      return [];
    }
    const legendData = [{
      legendType: 'category',
      id,
      itemId: yKey,
      seriesId: id,
      enabled: visible,
      label: {
        text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey
      },
      marker: {
        shape: marker.shape,
        fill: (_c = (_b = marker.fill) !== null && _b !== void 0 ? _b : fill) !== null && _c !== void 0 ? _c : 'rgba(0, 0, 0, 0)',
        stroke: (_e = (_d = marker.stroke) !== null && _d !== void 0 ? _d : stroke) !== null && _e !== void 0 ? _e : 'rgba(0, 0, 0, 0)',
        fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,
        strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1
      }
    }];
    return legendData;
  }
  animateEmptyUpdateReady({
    markerSelections,
    labelSelections
  }) {
    const duration = 1000;
    const labelDuration = 200;
    markerSelections.forEach(markerSelection => {
      markerSelection.each((marker, datum) => {
        var _a, _b, _c, _d;
        const format = this.animateFormatter(marker, datum);
        const size = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        const to = (_c = format === null || format === void 0 ? void 0 : format.size) !== null && _c !== void 0 ? _c : size;
        (_d = this.animationManager) === null || _d === void 0 ? void 0 : _d.animate(`${this.id}_empty-update-ready_${marker.id}`, {
          from: 0,
          to: to,
          disableInteractions: true,
          duration,
          ease: linear,
          repeat: 0,
          onUpdate(size) {
            marker.size = size;
          }
        });
      });
    });
    labelSelections.forEach(labelSelection => {
      labelSelection.each(label => {
        var _a;
        (_a = this.animationManager) === null || _a === void 0 ? void 0 : _a.animate(`${this.id}_empty-update-ready_${label.id}`, {
          from: 0,
          to: 1,
          delay: duration,
          duration: labelDuration,
          ease: linear,
          repeat: 0,
          onUpdate: opacity => {
            label.opacity = opacity;
          }
        });
      });
    });
  }
  animateReadyUpdate({
    markerSelections
  }) {
    markerSelections.forEach(markerSelection => {
      this.resetMarkers(markerSelection);
    });
  }
  animateReadyHighlightMarkers(markerSelection) {
    this.resetMarkers(markerSelection);
  }
  resetMarkers(markerSelection) {
    markerSelection.each((marker, datum) => {
      var _a, _b, _c;
      const format = this.animateFormatter(marker, datum);
      const size = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
      marker.size = (_c = format === null || format === void 0 ? void 0 : format.size) !== null && _c !== void 0 ? _c : size;
    });
  }
  animateFormatter(marker, datum) {
    var _a, _b, _c;
    const {
      xKey = '',
      yKey = '',
      marker: {
        strokeWidth: markerStrokeWidth
      },
      id: seriesId,
      ctx: {
        callbackCache
      }
    } = this;
    const {
      formatter
    } = this.marker;
    const fill = (_a = datum.fill) !== null && _a !== void 0 ? _a : marker.fill;
    const stroke = marker.stroke;
    const strokeWidth = markerStrokeWidth !== null && markerStrokeWidth !== void 0 ? markerStrokeWidth : 1;
    const size = (_c = (_b = datum.point) === null || _b === void 0 ? void 0 : _b.size) !== null && _c !== void 0 ? _c : 0;
    let format = undefined;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum: datum.datum,
        xKey,
        yKey,
        fill,
        stroke,
        strokeWidth,
        size,
        highlighted: false,
        seriesId
      });
    }
    return format;
  }
  isLabelEnabled() {
    return this.label.enabled;
  }
}
ScatterSeries.className = 'ScatterSeries';
ScatterSeries.type = 'scatter';
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "title", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "labelKey", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "xName", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "yName", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "sizeName", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "labelName", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "xKey", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "yKey", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "sizeKey", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "colorKey", void 0);
scatterSeries_decorate([Validate(OPT_STRING)], ScatterSeries.prototype, "colorName", void 0);
scatterSeries_decorate([Validate(OPT_NUMBER_ARRAY)], ScatterSeries.prototype, "colorDomain", void 0);
scatterSeries_decorate([Validate(COLOR_STRING_ARRAY)], ScatterSeries.prototype, "colorRange", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/hierarchy/hierarchySeries.mjs

class HierarchySeries extends Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH]
    });
  }
  getLabelData() {
    return [];
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/dropShadow.mjs
var dropShadow_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class DropShadow extends ChangeDetectable {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = 'rgba(0, 0, 0, 0.5)';
    this.xOffset = 0;
    this.yOffset = 0;
    this.blur = 5;
  }
}
dropShadow_decorate([Validate(BOOLEAN), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], DropShadow.prototype, "enabled", void 0);
dropShadow_decorate([Validate(COLOR_STRING), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], DropShadow.prototype, "color", void 0);
dropShadow_decorate([Validate(NUMBER()), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], DropShadow.prototype, "xOffset", void 0);
dropShadow_decorate([Validate(NUMBER()), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], DropShadow.prototype, "yOffset", void 0);
dropShadow_decorate([Validate(NUMBER(0)), SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], DropShadow.prototype, "blur", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/series/hierarchy/treemapSeries.mjs

var treemapSeries_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var treemapSeries_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};















class TreemapSeriesTooltip extends SeriesTooltip {
  constructor() {
    super(...arguments);
    this.renderer = undefined;
  }
}
treemapSeries_decorate([Validate(OPT_FUNCTION)], TreemapSeriesTooltip.prototype, "renderer", void 0);
class TreemapSeriesNodeBaseClickEvent extends SeriesNodeBaseClickEvent {
  constructor(labelKey, sizeKey, colorKey, nativeEvent, datum, series) {
    super(nativeEvent, datum, series);
    this.labelKey = labelKey;
    this.sizeKey = sizeKey;
    this.colorKey = colorKey;
  }
}
class TreemapSeriesNodeClickEvent extends TreemapSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeClick';
  }
}
class TreemapSeriesNodeDoubleClickEvent extends TreemapSeriesNodeBaseClickEvent {
  constructor() {
    super(...arguments);
    this.type = 'nodeDoubleClick';
  }
}
class TreemapSeriesLabel extends Label {
  constructor() {
    super(...arguments);
    this.padding = 10;
  }
}
treemapSeries_decorate([Validate(NUMBER(0))], TreemapSeriesLabel.prototype, "padding", void 0);
class TreemapSeriesTileLabel extends Label {
  constructor() {
    super(...arguments);
    this.wrapping = 'on-space';
  }
}
treemapSeries_decorate([Validate(TEXT_WRAP)], TreemapSeriesTileLabel.prototype, "wrapping", void 0);
class TreemapValueLabel {
  constructor() {
    this.style = (() => {
      const label = new Label();
      label.color = 'white';
      return label;
    })();
  }
}
treemapSeries_decorate([Validate(OPT_STRING)], TreemapValueLabel.prototype, "key", void 0);
treemapSeries_decorate([Validate(OPT_STRING)], TreemapValueLabel.prototype, "name", void 0);
treemapSeries_decorate([Validate(OPT_FUNCTION)], TreemapValueLabel.prototype, "formatter", void 0);
var TextNodeTag;
(function (TextNodeTag) {
  TextNodeTag[TextNodeTag["Name"] = 0] = "Name";
  TextNodeTag[TextNodeTag["Value"] = 1] = "Value";
})(TextNodeTag || (TextNodeTag = {}));
const tempText = new Text();
function getTextSize(text, style) {
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily
  } = style;
  tempText.fontStyle = fontStyle;
  tempText.fontWeight = fontWeight;
  tempText.fontSize = fontSize;
  tempText.fontFamily = fontFamily;
  tempText.text = text;
  tempText.x = 0;
  tempText.y = 0;
  tempText.textAlign = 'left';
  tempText.textBaseline = 'top';
  const {
    width,
    height
  } = tempText.computeBBox();
  return {
    width,
    height
  };
}
function validateColor(color) {
  if (typeof color === 'string' && !Color.validColorString(color)) {
    const fallbackColor = 'black';
    Logger.warnOnce(`invalid Treemap tile colour string "${color}". Affected treemap tiles will be coloured ${fallbackColor}.`);
    return 'black';
  }
  return color;
}
class TreemapTextHighlightStyle {
  constructor() {
    this.color = 'black';
  }
}
treemapSeries_decorate([Validate(OPT_COLOR_STRING)], TreemapTextHighlightStyle.prototype, "color", void 0);
class TreemapHighlightStyle extends HighlightStyle {
  constructor() {
    super(...arguments);
    this.text = new TreemapTextHighlightStyle();
  }
}
class TreemapSeries extends HierarchySeries {
  constructor() {
    super(...arguments);
    this.groupSelection = Selection.select(this.contentGroup, Group);
    this.highlightSelection = Selection.select(this.highlightGroup, Group);
    this.title = (() => {
      const label = new TreemapSeriesLabel();
      label.color = 'white';
      label.fontWeight = 'bold';
      label.fontSize = 12;
      label.fontFamily = 'Verdana, sans-serif';
      label.padding = 15;
      return label;
    })();
    this.subtitle = (() => {
      const label = new TreemapSeriesLabel();
      label.color = 'white';
      label.fontSize = 9;
      label.fontFamily = 'Verdana, sans-serif';
      label.padding = 13;
      return label;
    })();
    this.labels = {
      large: (() => {
        const label = new TreemapSeriesTileLabel();
        label.color = 'white';
        label.fontWeight = 'bold';
        label.fontSize = 18;
        return label;
      })(),
      medium: (() => {
        const label = new TreemapSeriesTileLabel();
        label.color = 'white';
        label.fontWeight = 'bold';
        label.fontSize = 14;
        return label;
      })(),
      small: (() => {
        const label = new TreemapSeriesTileLabel();
        label.color = 'white';
        label.fontWeight = 'bold';
        label.fontSize = 10;
        return label;
      })(),
      formatter: undefined,
      value: new TreemapValueLabel()
    };
    this.nodePadding = 2;
    this.nodeGap = 0;
    this.labelKey = 'label';
    this.sizeKey = 'size';
    this.colorKey = 'color';
    this.colorDomain = [-5, 5];
    this.colorRange = ['#cb4b3f', '#6acb64'];
    this.groupFill = '#272931';
    this.groupStroke = 'black';
    this.groupStrokeWidth = 1;
    this.tileStroke = 'black';
    this.tileStrokeWidth = 1;
    this.gradient = true;
    this.formatter = undefined;
    this.colorName = 'Change';
    this.rootName = 'Root';
    this.highlightGroups = true;
    this.tileShadow = new DropShadow();
    this.labelShadow = new DropShadow();
    this.tooltip = new TreemapSeriesTooltip();
    this.highlightStyle = new TreemapHighlightStyle();
  }
  getNodePaddingTop(nodeDatum, bbox) {
    var _a;
    const {
      title,
      subtitle,
      nodePadding
    } = this;
    const label = nodeDatum.label;
    if (nodeDatum.isLeaf || !label || nodeDatum.depth === 0) {
      return nodePadding;
    }
    const font = nodeDatum.depth > 1 ? subtitle : title;
    const textSize = getTextSize(label, font);
    const heightRatioThreshold = 3;
    if (font.fontSize > bbox.width / heightRatioThreshold || font.fontSize > bbox.height / heightRatioThreshold) {
      return nodePadding;
    }
    if (textSize.height >= bbox.height) {
      return nodePadding;
    }
    return textSize.height + nodePadding + ((_a = font.padding) !== null && _a !== void 0 ? _a : 0);
  }
  getNodePadding(nodeDatum, bbox) {
    const {
      nodePadding
    } = this;
    const top = this.getNodePaddingTop(nodeDatum, bbox);
    return {
      top,
      right: nodePadding,
      bottom: nodePadding,
      left: nodePadding
    };
  }
  /**
   * Squarified Treemap algorithm
   * https://www.win.tue.nl/~vanwijk/stm.pdf
   */
  squarify(nodeDatum, bbox, outputNodesBoxes = new Map()) {
    if (bbox.width <= 0 || bbox.height <= 0) {
      return outputNodesBoxes;
    }
    outputNodesBoxes.set(nodeDatum, bbox);
    const targetTileAspectRatio = 1; // The width and height will tend to this ratio
    const padding = this.getNodePadding(nodeDatum, bbox);
    const width = bbox.width - padding.left - padding.right;
    const height = bbox.height - padding.top - padding.bottom;
    if (width <= 0 || height <= 0 || nodeDatum.value <= 0) {
      return outputNodesBoxes;
    }
    let stackSum = 0;
    let startIndex = 0;
    let minRatioDiff = Infinity;
    let partitionSum = nodeDatum.value;
    const children = nodeDatum.children;
    const innerBox = new BBox(bbox.x + padding.left, bbox.y + padding.top, width, height);
    const partition = innerBox.clone();
    for (let i = 0; i < children.length; i++) {
      const value = children[i].value;
      const firstValue = children[startIndex].value;
      const isVertical = partition.width < partition.height;
      stackSum += value;
      const partThickness = isVertical ? partition.height : partition.width;
      const partLength = isVertical ? partition.width : partition.height;
      const firstTileLength = partLength * firstValue / stackSum;
      let stackThickness = partThickness * stackSum / partitionSum;
      const ratio = Math.max(firstTileLength, stackThickness) / Math.min(firstTileLength, stackThickness);
      const diff = Math.abs(targetTileAspectRatio - ratio);
      if (diff < minRatioDiff) {
        minRatioDiff = diff;
        continue;
      }
      // Go one step back and process the best match
      stackSum -= value;
      stackThickness = partThickness * stackSum / partitionSum;
      let start = isVertical ? partition.x : partition.y;
      for (let j = startIndex; j < i; j++) {
        const child = children[j];
        const x = isVertical ? start : partition.x;
        const y = isVertical ? partition.y : start;
        const length = partLength * child.value / stackSum;
        const width = isVertical ? length : stackThickness;
        const height = isVertical ? stackThickness : length;
        const childBox = new BBox(x, y, width, height);
        this.applyGap(innerBox, childBox);
        this.squarify(child, childBox, outputNodesBoxes);
        partitionSum -= child.value;
        start += length;
      }
      if (isVertical) {
        partition.y += stackThickness;
        partition.height -= stackThickness;
      } else {
        partition.x += stackThickness;
        partition.width -= stackThickness;
      }
      startIndex = i;
      stackSum = 0;
      minRatioDiff = Infinity;
      i--;
    }
    // Process remaining space
    const isVertical = partition.width < partition.height;
    let start = isVertical ? partition.x : partition.y;
    for (let i = startIndex; i < children.length; i++) {
      const x = isVertical ? start : partition.x;
      const y = isVertical ? partition.y : start;
      const part = children[i].value / partitionSum;
      const width = partition.width * (isVertical ? part : 1);
      const height = partition.height * (isVertical ? 1 : part);
      const childBox = new BBox(x, y, width, height);
      this.applyGap(innerBox, childBox);
      this.squarify(children[i], childBox, outputNodesBoxes);
      start += isVertical ? width : height;
    }
    return outputNodesBoxes;
  }
  applyGap(innerBox, childBox) {
    const gap = this.nodeGap / 2;
    const getBounds = box => {
      return {
        left: box.x,
        top: box.y,
        right: box.x + box.width,
        bottom: box.y + box.height
      };
    };
    const innerBounds = getBounds(innerBox);
    const childBounds = getBounds(childBox);
    const sides = Object.keys(innerBounds);
    sides.forEach(side => {
      if (!isEqual(innerBounds[side], childBounds[side])) {
        childBox.shrink(gap, side);
      }
    });
  }
  processData() {
    return treemapSeries_awaiter(this, void 0, void 0, function* () {
      if (!this.data) {
        return;
      }
      const {
        data,
        sizeKey,
        labelKey,
        colorKey,
        colorDomain,
        colorRange,
        groupFill
      } = this;
      const labelFormatter = this.labels.formatter;
      const colorScale = new ColorScale();
      colorScale.domain = colorDomain;
      colorScale.range = colorRange;
      colorScale.update();
      const createTreeNodeDatum = (datum, depth = 0, parent) => {
        var _a, _b, _c;
        let label;
        if (labelFormatter) {
          label = this.ctx.callbackCache.call(labelFormatter, {
            datum
          });
        }
        if (label !== undefined) {
          // Label retrieved from formatter successfully.
        } else if (labelKey) {
          label = (_a = datum[labelKey]) !== null && _a !== void 0 ? _a : '';
        } else {
          label = '';
        }
        let colorScaleValue = colorKey ? (_b = datum[colorKey]) !== null && _b !== void 0 ? _b : depth : depth;
        colorScaleValue = validateColor(colorScaleValue);
        const isLeaf = !datum.children;
        let fill = groupFill;
        if (typeof colorScaleValue === 'string') {
          fill = colorScaleValue;
        } else if (isLeaf || !groupFill) {
          fill = colorScale.convert(colorScaleValue);
        }
        const nodeDatum = {
          datum,
          depth,
          parent,
          value: 0,
          label,
          fill,
          series: this,
          isLeaf,
          children: []
        };
        if (isLeaf) {
          nodeDatum.value = sizeKey ? (_c = datum[sizeKey]) !== null && _c !== void 0 ? _c : 1 : 1;
        } else {
          datum.children.forEach(child => {
            const childNodeDatum = createTreeNodeDatum(child, depth + 1, nodeDatum);
            const value = childNodeDatum.value;
            if (isNaN(value) || !isFinite(value) || value === 0) {
              return;
            }
            nodeDatum.value += value;
            nodeDatum.children.push(childNodeDatum);
          });
          nodeDatum.children.sort((a, b) => {
            return b.value - a.value;
          });
        }
        return nodeDatum;
      };
      this.dataRoot = createTreeNodeDatum(data);
    });
  }
  createNodeData() {
    return treemapSeries_awaiter(this, void 0, void 0, function* () {
      return [];
    });
  }
  update() {
    return treemapSeries_awaiter(this, void 0, void 0, function* () {
      yield this.updateSelections();
      yield this.updateNodes();
    });
  }
  updateSelections() {
    return treemapSeries_awaiter(this, void 0, void 0, function* () {
      if (!this.nodeDataRefresh) {
        return;
      }
      this.nodeDataRefresh = false;
      const {
        chart,
        dataRoot
      } = this;
      if (!chart || !dataRoot) {
        return;
      }
      const seriesRect = chart.getSeriesRect();
      if (!seriesRect) {
        return;
      }
      const descendants = [];
      const traverse = datum => {
        var _a;
        descendants.push(datum);
        (_a = datum.children) === null || _a === void 0 ? void 0 : _a.forEach(traverse);
      };
      traverse(this.dataRoot);
      const {
        groupSelection,
        highlightSelection
      } = this;
      const update = selection => {
        return selection.update(descendants, group => {
          const rect = new Rect();
          const nameLabel = new Text();
          nameLabel.tag = TextNodeTag.Name;
          const valueLabel = new Text();
          valueLabel.tag = TextNodeTag.Value;
          group.append([rect, nameLabel, valueLabel]);
        });
      };
      this.groupSelection = update(groupSelection);
      this.highlightSelection = update(highlightSelection);
    });
  }
  isDatumHighlighted(datum) {
    var _a;
    const highlightedDatum = (_a = this.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();
    return datum === highlightedDatum && (datum.isLeaf || this.highlightGroups);
  }
  getTileFormat(datum, isHighlighted) {
    var _a;
    const {
      formatter,
      ctx: {
        callbackCache
      }
    } = this;
    if (!formatter) {
      return {};
    }
    const {
      gradient,
      colorKey,
      labelKey,
      sizeKey,
      tileStroke,
      tileStrokeWidth,
      groupStroke,
      groupStrokeWidth
    } = this;
    const stroke = datum.isLeaf ? tileStroke : groupStroke;
    const strokeWidth = datum.isLeaf ? tileStrokeWidth : groupStrokeWidth;
    const result = callbackCache.call(formatter, {
      seriesId: this.id,
      datum: datum.datum,
      depth: datum.depth,
      parent: (_a = datum.parent) === null || _a === void 0 ? void 0 : _a.datum,
      colorKey,
      sizeKey,
      labelKey,
      fill: datum.fill,
      stroke,
      strokeWidth,
      gradient,
      highlighted: isHighlighted
    });
    return result !== null && result !== void 0 ? result : {};
  }
  updateNodes() {
    return treemapSeries_awaiter(this, void 0, void 0, function* () {
      if (!this.chart) {
        return;
      }
      const {
        gradient,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            fillOpacity: highlightedFillOpacity,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth
          },
          text: {
            color: highlightedTextColor
          }
        },
        tileStroke,
        tileStrokeWidth,
        groupStroke,
        groupStrokeWidth,
        tileShadow,
        labelShadow
      } = this;
      const seriesRect = this.chart.getSeriesRect();
      const boxes = this.squarify(this.dataRoot, new BBox(0, 0, seriesRect.width, seriesRect.height));
      const labelMeta = this.buildLabelMeta(boxes);
      const highlightedSubtree = this.getHighlightedSubtree();
      this.updateNodeMidPoint(boxes);
      const updateRectFn = (rect, datum, isDatumHighlighted) => {
        var _a, _b, _c, _d, _e, _f;
        const box = boxes.get(datum);
        if (!box) {
          rect.visible = false;
          return;
        }
        const fill = isDatumHighlighted && highlightedFill !== undefined ? highlightedFill : datum.fill;
        const fillOpacity = (_a = isDatumHighlighted ? highlightedFillOpacity : 1) !== null && _a !== void 0 ? _a : 1;
        let stroke = groupStroke;
        if (isDatumHighlighted && highlightedStroke !== undefined) {
          stroke = highlightedStroke;
        } else if (datum.isLeaf) {
          stroke = tileStroke;
        }
        let strokeWidth = groupStrokeWidth;
        if (isDatumHighlighted && highlightedDatumStrokeWidth !== undefined) {
          strokeWidth = highlightedDatumStrokeWidth;
        } else if (datum.isLeaf) {
          strokeWidth = tileStrokeWidth;
        }
        const format = this.getTileFormat(datum, isDatumHighlighted);
        const fillColor = validateColor((_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : fill);
        if ((_c = format === null || format === void 0 ? void 0 : format.gradient) !== null && _c !== void 0 ? _c : gradient) {
          const start = Color.tryParseFromString(fill).brighter().toString();
          const end = Color.tryParseFromString(fill).darker().toString();
          rect.fill = `linear-gradient(180deg, ${start}, ${end})`;
        } else {
          rect.fill = fillColor;
        }
        rect.fillOpacity = (_d = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _d !== void 0 ? _d : fillOpacity;
        rect.stroke = validateColor((_e = format === null || format === void 0 ? void 0 : format.stroke) !== null && _e !== void 0 ? _e : stroke);
        rect.strokeWidth = (_f = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _f !== void 0 ? _f : strokeWidth;
        rect.fillShadow = tileShadow;
        rect.crisp = true;
        rect.x = box.x;
        rect.y = box.y;
        rect.width = box.width;
        rect.height = box.height;
        rect.visible = true;
      };
      this.groupSelection.selectByClass(Rect).forEach(rect => updateRectFn(rect, rect.datum, false));
      this.highlightSelection.selectByClass(Rect).forEach(rect => {
        const isDatumHighlighted = this.isDatumHighlighted(rect.datum);
        rect.visible = isDatumHighlighted || highlightedSubtree.has(rect.datum);
        if (rect.visible) {
          updateRectFn(rect, rect.datum, isDatumHighlighted);
        }
      });
      const updateLabelFn = (text, datum, highlighted, key) => {
        const meta = labelMeta.get(datum);
        const label = meta === null || meta === void 0 ? void 0 : meta[key];
        if (!label) {
          text.visible = false;
          return;
        }
        text.text = label.text;
        text.fontFamily = label.style.fontFamily;
        text.fontSize = label.style.fontSize;
        text.fontWeight = label.style.fontWeight;
        text.fill = highlighted ? highlightedTextColor !== null && highlightedTextColor !== void 0 ? highlightedTextColor : label.style.color : label.style.color;
        text.fillShadow = highlighted ? undefined : labelShadow;
        text.textAlign = label.hAlign;
        text.textBaseline = label.vAlign;
        text.x = label.x;
        text.y = label.y;
        text.visible = true;
      };
      this.groupSelection.selectByTag(TextNodeTag.Name).forEach(text => updateLabelFn(text, text.datum, false, 'label'));
      this.highlightSelection.selectByTag(TextNodeTag.Name).forEach(text => {
        const isDatumHighlighted = this.isDatumHighlighted(text.datum);
        text.visible = isDatumHighlighted || highlightedSubtree.has(text.datum);
        if (text.visible) {
          updateLabelFn(text, text.datum, isDatumHighlighted, 'label');
        }
      });
      this.groupSelection.selectByTag(TextNodeTag.Value).forEach(text => updateLabelFn(text, text.datum, false, 'value'));
      this.highlightSelection.selectByTag(TextNodeTag.Value).forEach(text => {
        const isDatumHighlighted = this.isDatumHighlighted(text.datum);
        text.visible = isDatumHighlighted || highlightedSubtree.has(text.datum);
        if (text.visible) {
          updateLabelFn(text, text.datum, isDatumHighlighted, 'value');
        }
      });
    });
  }
  updateNodeMidPoint(boxes) {
    boxes.forEach((box, treeNodeDatum) => {
      treeNodeDatum.nodeMidPoint = {
        x: box.x + box.width / 2,
        y: box.y
      };
    });
  }
  getHighlightedSubtree() {
    const items = new Set();
    const traverse = datum => {
      var _a;
      if (this.isDatumHighlighted(datum) || datum.parent && items.has(datum.parent)) {
        items.add(datum);
      }
      (_a = datum.children) === null || _a === void 0 ? void 0 : _a.forEach(traverse);
    };
    traverse(this.dataRoot);
    return items;
  }
  buildLabelMeta(boxes) {
    const {
      labels,
      title,
      subtitle,
      nodePadding,
      labelKey,
      ctx: {
        callbackCache
      }
    } = this;
    const wrappedRegExp = /-$/m;
    const labelMeta = new Map();
    boxes.forEach((box, datum) => {
      var _a, _b, _c;
      if (!labelKey || datum.depth === 0) {
        return;
      }
      const availTextWidth = box.width - 2 * nodePadding;
      const availTextHeight = box.height - 2 * nodePadding;
      const isBoxTooSmall = labelStyle => {
        const minSizeRatio = 3;
        return labelStyle.fontSize > box.width / minSizeRatio || labelStyle.fontSize > box.height / minSizeRatio;
      };
      let labelText = datum.isLeaf ? datum.label : datum.label.toUpperCase();
      let valueText = '';
      const valueConfig = labels.value;
      const valueStyle = valueConfig.style;
      const valueMargin = Math.ceil(valueStyle.fontSize * 2 * (Text.defaultLineHeightRatio - 1));
      if (datum.isLeaf) {
        if (valueConfig.formatter) {
          valueText = (_a = callbackCache.call(valueConfig.formatter, {
            datum: datum.datum
          })) !== null && _a !== void 0 ? _a : '';
        } else if (valueConfig.key) {
          valueText = datum.datum[valueConfig.key];
        }
      }
      let valueSize = getTextSize(valueText, valueStyle);
      if (valueText && valueSize.width > availTextWidth) {
        valueText = '';
      }
      let labelStyle;
      let wrappedText = '';
      if (datum.isLeaf) {
        labelStyle = labels.small;
        const pickStyle = () => {
          const availHeight = availTextHeight - (valueText ? valueStyle.fontSize + valueMargin : 0);
          const labelStyles = [labels.large, labels.medium, labels.small];
          for (const style of labelStyles) {
            const {
              width,
              height
            } = getTextSize(labelText, style);
            if (height > availHeight || isBoxTooSmall(style)) {
              continue;
            }
            if (width <= availTextWidth) {
              return {
                style,
                wrappedText: undefined
              };
            }
            // Avoid hyphens and ellipsis for large and medium label styles
            const wrapped = Text.wrap(labelText, availTextWidth, availHeight, style, style.wrapping);
            if (wrapped && wrapped !== '\u2026' && (style === labels.small || !(wrappedRegExp.exec(wrapped) || wrapped.endsWith('\u2026')))) {
              return {
                style,
                wrappedText: wrapped
              };
            }
          }
          // Check if small font fits by height
          const smallSize = getTextSize(labelText, labels.small);
          if (smallSize.height <= availHeight && !isBoxTooSmall(labels.small)) {
            return {
              style: labels.small,
              wrappedText: undefined
            };
          }
          return {
            style: undefined,
            wrappedText: undefined
          };
        };
        let result = pickStyle();
        if (!result.style && valueText) {
          valueText = '';
          result = pickStyle();
        }
        labelStyle = (_b = result.style) !== null && _b !== void 0 ? _b : labels.small;
        wrappedText = (_c = result.wrappedText) !== null && _c !== void 0 ? _c : '';
      } else if (datum.depth === 1) {
        labelStyle = title;
      } else {
        labelStyle = subtitle;
      }
      const labelSize = getTextSize(wrappedText || labelText, labelStyle);
      if (isBoxTooSmall(labelStyle)) {
        // Avoid labels on too small tiles
        return;
      }
      // Crop text if not enough space
      if (labelSize.width > availTextWidth) {
        const textLength = Math.floor(labelText.length * availTextWidth / labelSize.width) - 1;
        labelText = `${labelText.substring(0, textLength).trim()}â¦`;
      }
      valueSize = getTextSize(valueText, valueStyle);
      const hasValueText = valueText && valueSize.width < availTextWidth && valueSize.height + labelSize.height + valueMargin < availTextHeight;
      labelMeta.set(datum, {
        label: Object.assign({
          text: wrappedText || labelText,
          style: labelStyle
        }, datum.isLeaf ? {
          hAlign: 'center',
          vAlign: 'middle',
          x: box.x + box.width / 2,
          y: box.y + box.height / 2 - (hasValueText ? valueSize.height / 2 + valueMargin / 2 : 0)
        } : {
          hAlign: 'left',
          vAlign: 'top',
          x: box.x + nodePadding,
          y: box.y + nodePadding
        }),
        value: hasValueText ? {
          text: valueText,
          style: valueStyle,
          hAlign: 'center',
          vAlign: 'middle',
          x: box.x + box.width / 2,
          y: box.y + box.height / 2 + labelSize.height / 2 + valueMargin / 2
        } : undefined
      });
    });
    return labelMeta;
  }
  getDomain(_direction) {
    return [0, 1];
  }
  getNodeClickEvent(event, datum) {
    return new TreemapSeriesNodeClickEvent(this.labelKey, this.sizeKey, this.colorKey, event, datum, this);
  }
  getNodeDoubleClickEvent(event, datum) {
    return new TreemapSeriesNodeDoubleClickEvent(this.labelKey, this.sizeKey, this.colorKey, event, datum, this);
  }
  getTooltipHtml(nodeDatum) {
    var _a, _b, _c, _d;
    if (!this.highlightGroups && !nodeDatum.isLeaf) {
      return '';
    }
    const {
      tooltip,
      sizeKey,
      labelKey,
      colorKey,
      rootName,
      id: seriesId,
      labels,
      ctx: {
        callbackCache
      }
    } = this;
    const {
      datum
    } = nodeDatum;
    const {
      renderer: tooltipRenderer
    } = tooltip;
    const title = nodeDatum.depth ? datum[labelKey] : (_a = datum[labelKey]) !== null && _a !== void 0 ? _a : rootName;
    let content = '';
    const format = this.getTileFormat(nodeDatum, false);
    const color = (_c = (_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : nodeDatum.fill) !== null && _c !== void 0 ? _c : 'gray';
    const valueKey = labels.value.key;
    const valueFormatter = labels.value.formatter;
    if (valueKey || valueFormatter) {
      let valueText = '';
      if (valueFormatter) {
        valueText = callbackCache.call(valueFormatter, {
          datum
        });
      } else {
        const value = datum[valueKey];
        if (typeof value === 'number' && isFinite(value)) {
          valueText = toFixed(value);
        }
      }
      if (valueText) {
        if (labels.value.name) {
          content += `<b>${labels.value.name}:</b> `;
        }
        content += valueText;
      }
    }
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    if (tooltipRenderer) {
      return toTooltipHtml(tooltipRenderer({
        datum: nodeDatum.datum,
        parent: (_d = nodeDatum.parent) === null || _d === void 0 ? void 0 : _d.datum,
        depth: nodeDatum.depth,
        sizeKey,
        labelKey,
        colorKey,
        title,
        color,
        seriesId
      }), defaults);
    }
    if (!title && !content) {
      return '';
    }
    return toTooltipHtml(defaults);
  }
  getLegendData() {
    // Override point for subclasses.
    return [];
  }
}
TreemapSeries.className = 'TreemapSeries';
TreemapSeries.type = 'treemap';
treemapSeries_decorate([Validate(NUMBER(0))], TreemapSeries.prototype, "nodePadding", void 0);
treemapSeries_decorate([Validate(NUMBER(0))], TreemapSeries.prototype, "nodeGap", void 0);
treemapSeries_decorate([Validate(STRING)], TreemapSeries.prototype, "labelKey", void 0);
treemapSeries_decorate([Validate(OPT_STRING)], TreemapSeries.prototype, "sizeKey", void 0);
treemapSeries_decorate([Validate(OPT_STRING)], TreemapSeries.prototype, "colorKey", void 0);
treemapSeries_decorate([Validate(NUMBER_ARRAY)], TreemapSeries.prototype, "colorDomain", void 0);
treemapSeries_decorate([Validate(COLOR_STRING_ARRAY)], TreemapSeries.prototype, "colorRange", void 0);
treemapSeries_decorate([Validate(OPT_STRING)], TreemapSeries.prototype, "groupFill", void 0);
treemapSeries_decorate([Validate(OPT_COLOR_STRING)], TreemapSeries.prototype, "groupStroke", void 0);
treemapSeries_decorate([Validate(OPT_NUMBER(0))], TreemapSeries.prototype, "groupStrokeWidth", void 0);
treemapSeries_decorate([Validate(OPT_COLOR_STRING)], TreemapSeries.prototype, "tileStroke", void 0);
treemapSeries_decorate([Validate(OPT_NUMBER(0))], TreemapSeries.prototype, "tileStrokeWidth", void 0);
treemapSeries_decorate([Validate(BOOLEAN)], TreemapSeries.prototype, "gradient", void 0);
treemapSeries_decorate([Validate(OPT_FUNCTION)], TreemapSeries.prototype, "formatter", void 0);
treemapSeries_decorate([Validate(STRING)], TreemapSeries.prototype, "colorName", void 0);
treemapSeries_decorate([Validate(STRING)], TreemapSeries.prototype, "rootName", void 0);
treemapSeries_decorate([Validate(OPT_BOOLEAN)], TreemapSeries.prototype, "highlightGroups", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/factory/chartTypes.mjs

const TYPES = {
  area: 'cartesian',
  bar: 'cartesian',
  column: 'cartesian',
  histogram: 'cartesian',
  line: 'cartesian',
  scatter: 'cartesian',
  treemap: 'hierarchy',
  pie: 'polar'
};
const DEFAULTS = {};
const CHART_TYPES = {
  has(seriesType) {
    return Object.prototype.hasOwnProperty.call(TYPES, seriesType);
  },
  isCartesian(seriesType) {
    return TYPES[seriesType] === 'cartesian';
  },
  isPolar(seriesType) {
    return TYPES[seriesType] === 'polar';
  },
  isHierarchy(seriesType) {
    return TYPES[seriesType] === 'hierarchy';
  },
  get seriesTypes() {
    return Object.keys(TYPES);
  },
  get cartesianTypes() {
    return this.seriesTypes.filter(t => this.isCartesian(t));
  },
  get polarTypes() {
    return this.seriesTypes.filter(t => this.isPolar(t));
  },
  get hierarchyTypes() {
    return this.seriesTypes.filter(t => this.isHierarchy(t));
  }
};
function registerChartSeriesType(seriesType, chartType) {
  TYPES[seriesType] = chartType;
}
function registerChartDefaults(chartType, defaults) {
  var _a;
  DEFAULTS[chartType] = jsonMerge([(_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {}, defaults]);
}
function getChartDefaults(chartType) {
  var _a;
  return (_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {};
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/factory/seriesTypes.mjs








const BUILT_IN_SERIES_FACTORIES = {
  area: AreaSeries,
  bar: BarSeries,
  column: ColumnSeries,
  histogram: HistogramSeries,
  line: LineSeries,
  pie: PieSeries,
  scatter: ScatterSeries,
  treemap: TreemapSeries
};
const SERIES_FACTORIES = {};
const SERIES_DEFAULTS = {};
const SERIES_THEME_TEMPLATES = {};
function registerSeries(seriesType, chartType, cstr, defaults, theme) {
  SERIES_FACTORIES[seriesType] = cstr;
  SERIES_DEFAULTS[seriesType] = defaults;
  SERIES_THEME_TEMPLATES[seriesType] = theme;
  registerChartSeriesType(seriesType, chartType);
}
function getSeries(chartType, moduleCtx) {
  var _a;
  const seriesConstructor = (_a = SERIES_FACTORIES[chartType]) !== null && _a !== void 0 ? _a : BUILT_IN_SERIES_FACTORIES[chartType];
  if (seriesConstructor) {
    return new seriesConstructor(moduleCtx);
  }
  throw new Error(`AG Charts - unknown series type: ${chartType}`);
}
function getSeriesDefaults(chartType) {
  return SERIES_DEFAULTS[chartType];
}
function getSeriesThemeTemplate(chartType) {
  return SERIES_THEME_TEMPLATES[chartType];
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/mapping/defaults.mjs


const DEFAULT_CARTESIAN_CHART_OVERRIDES = {
  axes: [{
    type: NumberAxis.type,
    position: 'left'
  }, {
    type: CategoryAxis.type,
    position: 'bottom'
  }]
};
const DEFAULT_BAR_CHART_OVERRIDES = {
  axes: [{
    type: 'number',
    position: 'bottom'
  }, {
    type: 'category',
    position: 'left'
  }]
};
const DEFAULT_SCATTER_HISTOGRAM_CHART_OVERRIDES = {
  axes: [{
    type: 'number',
    position: 'bottom'
  }, {
    type: 'number',
    position: 'left'
  }]
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/mapping/transforms.mjs
function transform(input, transforms) {
  const result = {};
  for (const p in input) {
    const t = transforms[p] || (x => x);
    result[p] = t(input[p], input);
  }
  return result;
}
function transforms_is2dArray(input) {
  return input != null && input instanceof Array && input[0] instanceof Array;
}
function yNamesMapping(p, src) {
  if (p == null) {
    return {};
  }
  if (!(p instanceof Array)) {
    return p;
  }
  const yKeys = src.yKeys;
  if (yKeys == null || transforms_is2dArray(yKeys)) {
    throw new Error('AG Charts - yNames and yKeys mismatching configuration.');
  }
  const result = {};
  yKeys.forEach((k, i) => {
    result[k] = p[i];
  });
  return result;
}
function yKeysMapping(p, src) {
  if (p == null) {
    return [[]];
  }
  if (transforms_is2dArray(p)) {
    return p;
  }
  return src.grouped ? p.map(v => [v]) : [p];
}
function legendItemNamesMapping(p, src) {
  if (p == null) {
    return {};
  }
  if (!(p instanceof Array)) {
    return p;
  }
  const yKeys = src.yKeys;
  if (yKeys == null || transforms_is2dArray(yKeys)) {
    throw new Error('AG Charts - legendItemNames and yKeys mismatching configuration.');
  }
  const result = {};
  yKeys.forEach((k, i) => {
    result[k] = p[i];
  });
  return result;
}
function barSeriesTransform(options) {
  const result = Object.assign({}, options);
  delete result['yKey'];
  delete result['yName'];
  return transform(result, {
    yNames: yNamesMapping,
    yKeys: yKeysMapping,
    legendItemNames: legendItemNamesMapping
  });
}
function columnSeriesTransform(options) {
  const result = Object.assign({}, options);
  delete result['yKey'];
  delete result['yName'];
  return transform(result, {
    yNames: yNamesMapping,
    yKeys: yKeysMapping,
    legendItemNames: legendItemNamesMapping
  });
}
function identityTransform(input) {
  return input;
}
const SERIES_TRANSFORMS = {
  area: identityTransform,
  bar: barSeriesTransform,
  column: columnSeriesTransform,
  histogram: identityTransform,
  line: identityTransform,
  pie: identityTransform,
  scatter: identityTransform,
  treemap: identityTransform
};
function applySeriesTransform(options) {
  var _a;
  const type = (_a = options.type) !== null && _a !== void 0 ? _a : 'line';
  const transform = SERIES_TRANSFORMS[type];
  return (transform !== null && transform !== void 0 ? transform : identityTransform)(options);
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/object.mjs
function deepMerge(target, source) {
  if (isPlainObject(target) && isPlainObject(source)) {
    const result = {};
    Object.keys(target).forEach(key => {
      if (key in source) {
        result[key] = deepMerge(target[key], source[key]);
      } else {
        result[key] = target[key];
      }
    });
    Object.keys(source).forEach(key => {
      if (!(key in target)) {
        result[key] = source[key];
      }
    });
    return result;
  }
  if (Array.isArray(target) && !Array.isArray(source) || isObject(target) && !isObject(source)) {
    return target;
  }
  return source;
}
function isObject(value) {
  return value && typeof value === 'object';
}
function isPlainObject(x) {
  return isObject(x) && x.constructor === Object;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chartAxesTypes.mjs
const chartAxesTypes_TYPES = {
  number: 'number',
  time: 'time',
  log: 'log',
  category: 'category',
  groupedCategory: 'groupedCategory'
};
const AXES_THEME_TEMPLATES = {};
const CHART_AXES_TYPES = {
  has(axisType) {
    return Object.prototype.hasOwnProperty.call(chartAxesTypes_TYPES, axisType);
  },
  get axesTypes() {
    return Object.keys(chartAxesTypes_TYPES);
  }
};
function registerAxisThemeTemplate(axisType, theme) {
  AXES_THEME_TEMPLATES[axisType] = theme;
}
function getAxisThemeTemplate(axisType) {
  var _a;
  return (_a = AXES_THEME_TEMPLATES[axisType]) !== null && _a !== void 0 ? _a : {};
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/chartTheme.mjs





const palette = {
  fills: ['#f3622d', '#fba71b', '#57b757', '#41a9c9', '#4258c9', '#9a42c8', '#c84164', '#888888'],
  strokes: ['#aa4520', '#b07513', '#3d803d', '#2d768d', '#2e3e8d', '#6c2e8c', '#8c2d46', '#5f5f5f']
};
const EXTENDS_SERIES_DEFAULTS = Symbol('extends-series-defaults');
const OVERRIDE_SERIES_LABEL_DEFAULTS = Symbol('override-series-label-defaults');
const DEFAULT_FONT_FAMILY = Symbol('default-font');
const BOLD = 'bold';
const INSIDE = 'inside';
const BOTTOM = 'bottom';
class ChartTheme {
  constructor(options) {
    options = deepMerge({}, options !== null && options !== void 0 ? options : {});
    const {
      overrides = null,
      palette = null
    } = options;
    const defaults = this.createChartConfigPerChartType(this.getDefaults());
    if (overrides) {
      const {
        common,
        cartesian,
        polar,
        hierarchy
      } = overrides;
      const applyOverrides = (type, seriesTypes, overrideOpts) => {
        if (overrideOpts) {
          defaults[type] = deepMerge(defaults[type], overrideOpts);
          seriesTypes.forEach(s => {
            const seriesType = s;
            defaults[seriesType] = deepMerge(defaults[seriesType], overrideOpts);
          });
        }
      };
      applyOverrides('common', Object.keys(defaults), common);
      applyOverrides('cartesian', CHART_TYPES.cartesianTypes, cartesian);
      applyOverrides('polar', CHART_TYPES.polarTypes, polar);
      applyOverrides('hierarchy', CHART_TYPES.hierarchyTypes, hierarchy);
      CHART_TYPES.seriesTypes.forEach(s => {
        const seriesType = s;
        const chartConfig = overrides[seriesType];
        if (chartConfig) {
          if (chartConfig.series) {
            chartConfig.series = {
              [seriesType]: chartConfig.series
            };
          }
          defaults[seriesType] = deepMerge(defaults[seriesType], chartConfig);
        }
      });
    }
    this.palette = palette !== null && palette !== void 0 ? palette : this.getPalette();
    this.config = Object.freeze(defaults);
  }
  getPalette() {
    return palette;
  }
  static getAxisDefaults() {
    return {
      top: {},
      right: {},
      bottom: {},
      left: {},
      thickness: 0,
      title: {
        enabled: false,
        text: 'Axis Title',
        fontStyle: undefined,
        fontWeight: BOLD,
        fontSize: 12,
        fontFamily: this.fontFamily,
        color: 'rgb(70, 70, 70)'
      },
      label: {
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: this.fontFamily,
        padding: 5,
        rotation: undefined,
        color: 'rgb(87, 87, 87)',
        formatter: undefined,
        autoRotate: false,
        avoidCollisions: true
      },
      line: {
        width: 1,
        color: 'rgb(195, 195, 195)'
      },
      tick: {
        width: 1,
        size: 6,
        color: 'rgb(195, 195, 195)'
      },
      gridStyle: [{
        stroke: 'rgb(219, 219, 219)',
        lineDash: [4, 2]
      }],
      crossLines: {
        enabled: false,
        fill: 'rgb(187,221,232)',
        stroke: 'rgb(70,162,192)',
        strokeWidth: 1,
        label: {
          enabled: false,
          fontStyle: undefined,
          fontWeight: undefined,
          fontSize: 12,
          fontFamily: this.fontFamily,
          padding: 5,
          color: 'rgb(87, 87, 87)',
          rotation: undefined
        }
      }
    };
  }
  static getSeriesDefaults() {
    return {
      tooltip: {
        enabled: true,
        renderer: undefined
      },
      visible: true,
      showInLegend: true,
      highlightStyle: {
        item: {
          fill: 'yellow',
          fillOpacity: 1
        },
        series: {
          dimOpacity: 1
        },
        text: {
          color: 'black'
        }
      },
      nodeClickRange: 'exact'
    };
  }
  static getBarSeriesDefaults() {
    return Object.assign(Object.assign({}, this.getSeriesDefaults()), {
      fillOpacity: 1,
      strokeOpacity: 1,
      normalizedTo: undefined,
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: false,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: this.fontFamily,
        color: 'rgb(70, 70, 70)',
        formatter: undefined,
        placement: INSIDE
      },
      shadow: {
        enabled: false,
        color: 'rgba(0, 0, 0, 0.5)',
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }
    });
  }
  static getLineSeriesDefaults() {
    const seriesDefaults = this.getSeriesDefaults();
    return Object.assign(Object.assign({}, seriesDefaults), {
      tooltip: Object.assign(Object.assign({}, seriesDefaults.tooltip), {
        format: undefined,
        position: {
          type: 'node'
        }
      })
    });
  }
  static getAreaSeriesDefaults() {
    const seriesDefaults = this.getSeriesDefaults();
    return Object.assign(Object.assign({}, seriesDefaults), {
      nodeClickRange: 'nearest',
      tooltip: Object.assign(Object.assign({}, seriesDefaults.tooltip), {
        position: {
          type: 'node'
        }
      })
    });
  }
  static getScatterSeriesDefaults() {
    const seriesDefaults = this.getSeriesDefaults();
    return Object.assign(Object.assign({}, seriesDefaults), {
      tooltip: Object.assign(Object.assign({}, seriesDefaults.tooltip), {
        position: {
          type: 'node'
        }
      })
    });
  }
  static getCartesianSeriesMarkerDefaults() {
    return {
      enabled: true,
      shape: 'circle',
      size: 6,
      maxSize: 30,
      strokeWidth: 1,
      formatter: undefined
    };
  }
  static getCaptionWrappingDefaults() {
    return 'hyphenate';
  }
  static getChartDefaults() {
    return {
      background: {
        visible: true,
        fill: 'white'
      },
      padding: {
        top: 20,
        right: 20,
        bottom: 20,
        left: 20
      },
      title: {
        enabled: false,
        text: 'Title',
        fontStyle: undefined,
        fontWeight: BOLD,
        fontSize: 16,
        fontFamily: this.fontFamily,
        color: 'rgb(70, 70, 70)',
        wrapping: ChartTheme.getCaptionWrappingDefaults()
      },
      subtitle: {
        enabled: false,
        text: 'Subtitle',
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: this.fontFamily,
        color: 'rgb(140, 140, 140)',
        wrapping: ChartTheme.getCaptionWrappingDefaults()
      },
      footnote: {
        enabled: false,
        text: 'Footnote',
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: this.fontFamily,
        color: 'rgb(140, 140, 140)',
        spacing: 30,
        wrapping: ChartTheme.getCaptionWrappingDefaults()
      },
      legend: {
        position: BOTTOM,
        spacing: 20,
        listeners: {},
        item: {
          paddingX: 16,
          paddingY: 8,
          marker: {
            shape: undefined,
            size: 15,
            strokeWidth: 1,
            padding: 8
          },
          label: {
            color: 'black',
            fontStyle: undefined,
            fontWeight: undefined,
            fontSize: 12,
            fontFamily: this.fontFamily,
            formatter: undefined
          }
        },
        reverseOrder: false,
        pagination: {
          marker: {
            size: 12
          },
          activeStyle: {
            fill: 'rgb(70, 70, 70)'
          },
          inactiveStyle: {
            fill: 'rgb(219, 219, 219)'
          },
          highlightStyle: {
            fill: 'rgb(70, 70, 70)'
          },
          label: {
            color: 'rgb(70, 70, 70)'
          }
        }
      },
      tooltip: {
        enabled: true,
        range: 'nearest',
        delay: 0
      },
      listeners: {}
    };
  }
  createChartConfigPerChartType(config) {
    const typeToAliases = {
      cartesian: CHART_TYPES.cartesianTypes,
      polar: CHART_TYPES.polarTypes,
      hierarchy: CHART_TYPES.hierarchyTypes,
      groupedCategory: []
    };
    Object.entries(typeToAliases).forEach(([nextType, aliases]) => {
      const type = nextType;
      const typeDefaults = this.templateTheme(getChartDefaults(type));
      aliases.forEach(next => {
        const alias = next;
        if (!config[alias]) {
          config[alias] = deepMerge({}, config[type]);
          deepMerge(config[alias], typeDefaults);
        }
      });
    });
    return config;
  }
  getDefaults() {
    const defaults = deepMerge({}, ChartTheme.defaults);
    const getOverridesByType = (chartType, seriesTypes) => {
      const result = this.templateTheme(getChartDefaults(chartType));
      result.series = seriesTypes.reduce((obj, seriesType) => {
        const template = getSeriesThemeTemplate(seriesType);
        if (template) {
          obj[seriesType] = this.templateTheme(template);
        }
        return obj;
      }, {});
      if (chartType === 'cartesian') {
        result.axes = CHART_AXES_TYPES.axesTypes.reduce((obj, axisType) => {
          const template = getAxisThemeTemplate(axisType);
          if (template) {
            obj[axisType] = this.templateTheme(template);
          }
          return obj;
        }, {});
      }
      return result;
    };
    const extension = {
      cartesian: getOverridesByType('cartesian', CHART_TYPES.cartesianTypes),
      groupedCategory: getOverridesByType('cartesian', CHART_TYPES.cartesianTypes),
      polar: getOverridesByType('polar', CHART_TYPES.polarTypes),
      hierarchy: getOverridesByType('hierarchy', CHART_TYPES.hierarchyTypes)
    };
    return deepMerge(defaults, extension);
  }
  templateTheme(themeTemplate) {
    const themeInstance = jsonMerge([themeTemplate]);
    const {
      extensions,
      properties
    } = this.getTemplateParameters();
    jsonWalk(themeInstance, (_, node) => {
      if (node['__extends__']) {
        const key = node['__extends__'];
        const source = extensions.get(key);
        if (source == null) {
          throw new Error('AG Charts - no template variable provided for: ' + key);
        }
        Object.assign(node, source, node);
        delete node['__extends__'];
      }
      if (node['__overrides__']) {
        const key = node['__overrides__'];
        const source = extensions.get(key);
        if (source == null) {
          throw new Error('AG Charts - no template variable provided for: ' + key);
        }
        Object.assign(node, source);
        delete node['__overrides__'];
      }
      for (const [name, value] of Object.entries(node)) {
        if (properties.has(value)) {
          node[name] = properties.get(value);
        }
      }
    }, {});
    return themeInstance;
  }
  getTemplateParameters() {
    const extensions = new Map();
    extensions.set(EXTENDS_SERIES_DEFAULTS, ChartTheme.getSeriesDefaults());
    extensions.set(OVERRIDE_SERIES_LABEL_DEFAULTS, {});
    const properties = new Map();
    properties.set(DEFAULT_FONT_FAMILY, ChartTheme.fontFamily);
    return {
      extensions,
      properties
    };
  }
  mergeWithParentDefaults(parentDefaults, defaults) {
    return deepMerge(parentDefaults, defaults);
  }
}
ChartTheme.fontFamily = 'Verdana, sans-serif';
ChartTheme.cartesianDefaults = Object.assign(Object.assign({}, ChartTheme.getChartDefaults()), {
  axes: {
    number: Object.assign({}, ChartTheme.getAxisDefaults()),
    log: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), {
      base: 10
    }),
    category: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), {
      groupPaddingInner: 0.1,
      label: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().label), {
        autoRotate: true
      })
    }),
    groupedCategory: Object.assign({}, ChartTheme.getAxisDefaults()),
    time: Object.assign({}, ChartTheme.getAxisDefaults())
  },
  series: {
    column: Object.assign({}, ChartTheme.getBarSeriesDefaults()),
    bar: Object.assign({}, ChartTheme.getBarSeriesDefaults()),
    line: Object.assign(Object.assign({}, ChartTheme.getLineSeriesDefaults()), {
      title: undefined,
      strokeWidth: 2,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      marker: Object.assign(Object.assign({}, ChartTheme.getCartesianSeriesMarkerDefaults()), {
        fillOpacity: 1,
        strokeOpacity: 1
      }),
      label: {
        enabled: false,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        formatter: undefined
      }
    }),
    scatter: Object.assign(Object.assign({}, ChartTheme.getScatterSeriesDefaults()), {
      sizeName: 'Size',
      labelName: 'Label',
      marker: Object.assign({}, ChartTheme.getCartesianSeriesMarkerDefaults()),
      label: {
        enabled: false,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)'
      }
    }),
    area: Object.assign(Object.assign({}, ChartTheme.getAreaSeriesDefaults()), {
      normalizedTo: undefined,
      fillOpacity: 0.8,
      strokeOpacity: 1,
      strokeWidth: 2,
      lineDash: [0],
      lineDashOffset: 0,
      shadow: {
        enabled: false,
        color: 'rgba(0, 0, 0, 0.5)',
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      marker: Object.assign(Object.assign({}, ChartTheme.getCartesianSeriesMarkerDefaults()), {
        fillOpacity: 1,
        strokeOpacity: 1,
        enabled: false
      }),
      label: {
        enabled: false,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        formatter: undefined
      }
    }),
    histogram: Object.assign(Object.assign({}, ChartTheme.getSeriesDefaults()), {
      strokeWidth: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      areaPlot: false,
      bins: undefined,
      aggregation: 'sum',
      label: {
        enabled: false,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        formatter: undefined
      },
      shadow: {
        enabled: true,
        color: 'rgba(0, 0, 0, 0.5)',
        xOffset: 0,
        yOffset: 0,
        blur: 5
      }
    })
  }
});
ChartTheme.polarDefaults = Object.assign(Object.assign({}, ChartTheme.getChartDefaults()), {
  series: {
    pie: Object.assign(Object.assign({}, ChartTheme.getSeriesDefaults()), {
      title: {
        enabled: true,
        fontStyle: undefined,
        fontWeight: 'bold',
        fontSize: 14,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        spacing: 0
      },
      radiusKey: undefined,
      radiusName: undefined,
      calloutLabelKey: undefined,
      calloutLabelName: undefined,
      sectorLabelKey: undefined,
      sectorLabelName: undefined,
      calloutLabel: {
        enabled: true,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        offset: 3,
        minAngle: 0
      },
      sectorLabel: {
        enabled: true,
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        positionOffset: 0,
        positionRatio: 0.5
      },
      calloutLine: {
        length: 10,
        strokeWidth: 2
      },
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0,
      rotation: 0,
      outerRadiusOffset: 0,
      innerRadiusOffset: 0,
      shadow: {
        enabled: false,
        color: 'rgba(0, 0, 0, 0.5)',
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      innerLabels: {
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 12,
        fontFamily: ChartTheme.fontFamily,
        color: 'rgb(70, 70, 70)',
        margin: 2
      }
    })
  }
});
ChartTheme.hierarchyDefaults = Object.assign(Object.assign({}, ChartTheme.getChartDefaults()), {
  series: {
    treemap: Object.assign(Object.assign({}, ChartTheme.getSeriesDefaults()), {
      showInLegend: false,
      labelKey: 'label',
      sizeKey: 'size',
      colorKey: 'color',
      colorDomain: [-5, 5],
      colorRange: ['#cb4b3f', '#6acb64'],
      groupFill: '#272931',
      groupStroke: 'black',
      groupStrokeWidth: 1,
      tileStroke: 'black',
      tileStrokeWidth: 1,
      gradient: true,
      tileShadow: {
        enabled: false,
        color: 'rgba(0, 0, 0, 0.5)',
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      labelShadow: {
        enabled: true,
        color: 'rgba(0, 0, 0, 0.4)',
        xOffset: 1.5,
        yOffset: 1.5,
        blur: 5
      },
      highlightGroups: true,
      nodePadding: 2,
      nodeGap: 0,
      title: {
        enabled: true,
        color: 'white',
        fontStyle: undefined,
        fontWeight: 'bold',
        fontSize: 12,
        fontFamily: 'Verdana, sans-serif',
        padding: 2
      },
      subtitle: {
        enabled: true,
        color: 'white',
        fontStyle: undefined,
        fontWeight: undefined,
        fontSize: 9,
        fontFamily: 'Verdana, sans-serif',
        padding: 2
      },
      labels: {
        large: {
          enabled: true,
          fontStyle: undefined,
          fontWeight: 'bold',
          fontSize: 18,
          fontFamily: 'Verdana, sans-serif',
          color: 'white',
          wrapping: 'on-space'
        },
        medium: {
          enabled: true,
          fontStyle: undefined,
          fontWeight: 'bold',
          fontSize: 14,
          fontFamily: 'Verdana, sans-serif',
          color: 'white',
          wrapping: 'on-space'
        },
        small: {
          enabled: true,
          fontStyle: undefined,
          fontWeight: 'bold',
          fontSize: 10,
          fontFamily: 'Verdana, sans-serif',
          color: 'white',
          wrapping: 'on-space'
        },
        value: {
          style: {
            enabled: true,
            fontStyle: undefined,
            fontWeight: undefined,
            fontSize: 12,
            fontFamily: 'Verdana, sans-serif',
            color: 'white'
          }
        }
      }
    })
  }
});
ChartTheme.defaults = {
  cartesian: ChartTheme.cartesianDefaults,
  groupedCategory: ChartTheme.cartesianDefaults,
  polar: ChartTheme.polarDefaults,
  hierarchy: ChartTheme.hierarchyDefaults
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/darkTheme.mjs



class DarkTheme extends ChartTheme {
  constructor(options) {
    super(options);
  }
  getDefaults() {
    const fontColor = DarkTheme.fontColor;
    const mutedFontColor = DarkTheme.mutedFontColor;
    const axisDefaults = {
      title: {
        color: fontColor
      },
      label: {
        color: fontColor
      },
      gridStyle: [{
        stroke: 'rgb(88, 88, 88)',
        lineDash: [4, 2]
      }]
    };
    const seriesLabelDefaults = {
      label: {
        color: fontColor
      }
    };
    const chartAxesDefaults = {
      axes: {
        number: Object.assign({}, axisDefaults),
        category: Object.assign({}, axisDefaults),
        time: Object.assign({}, axisDefaults)
      }
    };
    const chartDefaults = {
      background: {
        fill: 'rgb(34, 38, 41)'
      },
      title: {
        color: fontColor
      },
      subtitle: {
        color: mutedFontColor
      },
      legend: {
        item: {
          label: {
            color: fontColor
          }
        },
        pagination: {
          activeStyle: {
            fill: fontColor
          },
          inactiveStyle: {
            fill: mutedFontColor
          },
          highlightStyle: {
            fill: fontColor
          },
          label: {
            color: fontColor
          }
        }
      }
    };
    const getOverridesByType = seriesTypes => {
      return seriesTypes.reduce((obj, seriesType) => {
        const template = getSeriesThemeTemplate(seriesType);
        if (template) {
          obj[seriesType] = this.templateTheme(template);
        }
        return obj;
      }, {});
    };
    return this.mergeWithParentDefaults(super.getDefaults(), {
      cartesian: Object.assign(Object.assign(Object.assign({}, chartDefaults), chartAxesDefaults), {
        series: Object.assign({
          line: Object.assign({}, seriesLabelDefaults),
          bar: Object.assign({}, seriesLabelDefaults),
          column: Object.assign({}, seriesLabelDefaults),
          histogram: Object.assign({}, seriesLabelDefaults)
        }, getOverridesByType(CHART_TYPES.cartesianTypes))
      }),
      groupedCategory: Object.assign(Object.assign(Object.assign({}, chartDefaults), chartAxesDefaults), {
        series: Object.assign({
          bar: Object.assign({}, seriesLabelDefaults),
          column: Object.assign({}, seriesLabelDefaults),
          histogram: Object.assign({}, seriesLabelDefaults)
        }, getOverridesByType(CHART_TYPES.cartesianTypes))
      }),
      polar: Object.assign(Object.assign({}, chartDefaults), {
        series: Object.assign({
          pie: {
            calloutLabel: {
              color: fontColor
            },
            sectorLabel: {
              color: fontColor
            },
            title: {
              color: fontColor
            },
            innerLabels: {
              color: fontColor
            }
          }
        }, getOverridesByType(CHART_TYPES.polarTypes))
      }),
      hierarchy: Object.assign(Object.assign({}, chartDefaults), {
        series: Object.assign({
          treemap: {
            tileStroke: 'white',
            groupStroke: 'white',
            title: {
              color: fontColor
            },
            subtitle: {
              color: mutedFontColor
            },
            labels: {
              large: {
                color: fontColor
              },
              medium: {
                color: fontColor
              },
              small: {
                color: fontColor
              },
              value: {
                style: {
                  color: fontColor
                }
              }
            }
          }
        }, getOverridesByType(CHART_TYPES.hierarchyTypes))
      })
    });
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.extensions.set(OVERRIDE_SERIES_LABEL_DEFAULTS, DarkTheme.seriesLabelDefaults.label);
    return result;
  }
}
DarkTheme.fontColor = 'rgb(200, 200, 200)';
DarkTheme.mutedFontColor = 'rgb(150, 150, 150)';
DarkTheme.seriesLabelDefaults = {
  label: {
    color: DarkTheme.fontColor
  }
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/materialLight.mjs

const materialLight_palette = {
  fills: ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'],
  strokes: ['#ab2f26', '#a31545', '#6d1b7b', '#482980', '#2c397f', '#1769aa', '#0276ab', '#008494', '#00695f', '#357a38', '#618834', '#909a28', '#b3a429', '#b38705', '#b36a00', '#b33d18']
};
class MaterialLight extends ChartTheme {
  getPalette() {
    return materialLight_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/materialDark.mjs

const materialDark_palette = {
  fills: ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'],
  strokes: ['#ab2f26', '#a31545', '#6d1b7b', '#482980', '#2c397f', '#1769aa', '#0276ab', '#008494', '#00695f', '#357a38', '#618834', '#909a28', '#b3a429', '#b38705', '#b36a00', '#b33d18']
};
class MaterialDark extends DarkTheme {
  getPalette() {
    return materialDark_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/pastelLight.mjs

const pastelLight_palette = {
  fills: ['#c16068', '#a2bf8a', '#ebcc87', '#80a0c3', '#b58dae', '#85c0d1'],
  strokes: ['#874349', '#718661', '#a48f5f', '#5a7088', '#7f637a', '#5d8692']
};
class PastelLight extends ChartTheme {
  getPalette() {
    return pastelLight_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/pastelDark.mjs

const pastelDark_palette = {
  fills: ['#c16068', '#a2bf8a', '#ebcc87', '#80a0c3', '#b58dae', '#85c0d1'],
  strokes: ['#874349', '#718661', '#a48f5f', '#5a7088', '#7f637a', '#5d8692']
};
class PastelDark extends DarkTheme {
  getPalette() {
    return pastelDark_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/solarLight.mjs

const solarLight_palette = {
  fills: ['#febe76', '#ff7979', '#badc58', '#f9ca23', '#f0932b', '#eb4c4b', '#6ab04c', '#7ed6df', '#e056fd', '#686de0'],
  strokes: ['#b28553', '#b35555', '#829a3e', '#ae8d19', '#a8671e', '#a43535', '#4a7b35', '#58969c', '#9d3cb1', '#494c9d']
};
class SolarLight extends ChartTheme {
  getPalette() {
    return solarLight_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/solarDark.mjs

const solarDark_palette = {
  fills: ['#febe76', '#ff7979', '#badc58', '#f9ca23', '#f0932b', '#eb4c4b', '#6ab04c', '#7ed6df', '#e056fd', '#686de0'],
  strokes: ['#b28553', '#b35555', '#829a3e', '#ae8d19', '#a8671e', '#a43535', '#4a7b35', '#58969c', '#9d3cb1', '#494c9d']
};
class SolarDark extends DarkTheme {
  getPalette() {
    return solarDark_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/vividLight.mjs

const vividLight_palette = {
  fills: ['#5BC0EB', '#FDE74C', '#9BC53D', '#E55934', '#FA7921', '#fa3081'],
  strokes: ['#4086a4', '#b1a235', '#6c8a2b', '#a03e24', '#af5517', '#af225a']
};
class VividLight extends ChartTheme {
  getPalette() {
    return vividLight_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/themes/vividDark.mjs

const vividDark_palette = {
  fills: ['#5BC0EB', '#FDE74C', '#9BC53D', '#E55934', '#FA7921', '#fa3081'],
  strokes: ['#4086a4', '#b1a235', '#6c8a2b', '#a03e24', '#af5517', '#af225a']
};
class VividDark extends DarkTheme {
  getPalette() {
    return vividDark_palette;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/mapping/themes.mjs












const lightTheme = () => new ChartTheme();
const darkTheme = () => new DarkTheme();
const lightThemes = {
  undefined: lightTheme,
  null: lightTheme,
  'ag-default': lightTheme,
  'ag-material': () => new MaterialLight(),
  'ag-pastel': () => new PastelLight(),
  'ag-solar': () => new SolarLight(),
  'ag-vivid': () => new VividLight()
};
const darkThemes = {
  undefined: darkTheme,
  null: darkTheme,
  'ag-default-dark': darkTheme,
  'ag-material-dark': () => new MaterialDark(),
  'ag-pastel-dark': () => new PastelDark(),
  'ag-solar-dark': () => new SolarDark(),
  'ag-vivid-dark': () => new VividDark()
};
const themes = Object.assign(Object.assign({}, darkThemes), lightThemes);
function getChartTheme(value) {
  var _a;
  if (value instanceof ChartTheme) {
    return value;
  }
  const stockTheme = themes[value];
  if (stockTheme) {
    return stockTheme();
  }
  value = value;
  // Flatten recursive themes.
  const overrides = [];
  let palette;
  while (typeof value === 'object') {
    overrides.push((_a = value.overrides) !== null && _a !== void 0 ? _a : {});
    // Use first palette found, they can't be merged.
    if (value.palette && palette == null) {
      palette = value.palette;
    }
    value = value.baseTheme;
  }
  overrides.reverse();
  const flattenedTheme = Object.assign({
    baseTheme: value,
    overrides: jsonMerge(overrides)
  }, palette ? {
    palette
  } : {});
  if (flattenedTheme.baseTheme || flattenedTheme.overrides) {
    const baseTheme = getChartTheme(flattenedTheme.baseTheme);
    return new baseTheme.constructor(flattenedTheme);
  }
  return lightTheme();
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/mapping/prepareSeries.mjs


/**
 * Groups the series options objects if they are of type `column` or `bar` and places them in an array at the index where the first instance of this series type was found.
 * Returns an array of arrays containing the ordered and grouped series options objects.
 */
function groupSeriesByType(seriesOptions) {
  var _a;
  const indexMap = {};
  const result = [];
  for (const s of seriesOptions) {
    if (s.type !== 'column' && s.type !== 'bar' && (s.type !== 'area' || s.stacked !== true)) {
      // No need to use index for these cases.
      result.push([s]);
      continue;
    }
    const seriesType = (_a = s.type) !== null && _a !== void 0 ? _a : 'line';
    const groupingKey = s.stacked ? 'stacked' : 'grouped';
    const indexKey = `${seriesType}-${s.xKey}-${groupingKey}`;
    if (indexMap[indexKey] == null) {
      // Add indexed array to result on first addition.
      indexMap[indexKey] = [];
      result.push(indexMap[indexKey]);
    }
    indexMap[indexKey].push(s);
  }
  return result;
}
const FAIL = Symbol();
const SKIP = Symbol();
const ARRAY_REDUCER = prop => (result, next) => {
  var _a;
  return result.concat(...((_a = next[prop]) !== null && _a !== void 0 ? _a : []));
};
const BOOLEAN_OR_REDUCER = (prop, defaultValue) => (result, next) => {
  if (typeof next[prop] === 'boolean') {
    return (result !== null && result !== void 0 ? result : false) || next[prop];
  }
  return result !== null && result !== void 0 ? result : defaultValue;
};
const DEFAULTING_ARRAY_REDUCER = (prop, defaultValue) => (result, next, idx, length) => {
  var _a;
  const sparse = defaultValue === SKIP || defaultValue === FAIL;
  const nextValue = (_a = next[prop]) !== null && _a !== void 0 ? _a : defaultValue;
  if (nextValue === FAIL) {
    throw new Error(`AG Charts - missing value for property [${prop}] on series config.`);
  } else if (nextValue === SKIP) {
    return result;
  }
  if (result.length === 0 && !sparse) {
    // Pre-populate values on first invocation as we will only be invoked for series with a
    // value specified.
    while (result.length < length) {
      result = result.concat(defaultValue);
    }
  }
  if (!sparse) {
    result[idx] = nextValue;
    return result;
  }
  return result.concat(nextValue);
};
const YKEYS_REDUCER = (prop, activationValue) => (result, next) => {
  if (next[prop] === activationValue) {
    return result.concat(...(next.yKey ? [next.yKey] : next.yKeys));
  }
  return result;
};
const STACK_GROUPS_REDUCER = () => (result, next) => {
  return Object.assign(Object.assign({}, result), {
    [next.stackGroup]: [...(result[next.stackGroup] || []), next.yKey]
  });
};
const REDUCE_CONFIG = {
  hideInChart: {
    outputProp: 'hideInChart',
    reducer: ARRAY_REDUCER('hideInChart'),
    start: []
  },
  hideInLegend: {
    outputProp: 'hideInLegend',
    reducer: ARRAY_REDUCER('hideInLegend'),
    start: []
  },
  yKey: {
    outputProp: 'yKeys',
    reducer: DEFAULTING_ARRAY_REDUCER('yKey', SKIP),
    start: []
  },
  fill: {
    outputProp: 'fills',
    reducer: DEFAULTING_ARRAY_REDUCER('fill', SKIP),
    start: []
  },
  stroke: {
    outputProp: 'strokes',
    reducer: DEFAULTING_ARRAY_REDUCER('stroke', SKIP),
    start: []
  },
  yName: {
    outputProp: 'yNames',
    reducer: DEFAULTING_ARRAY_REDUCER('yName', SKIP),
    start: []
  },
  visible: {
    outputProp: 'visibles',
    reducer: DEFAULTING_ARRAY_REDUCER('visible', true),
    start: []
  },
  legendItemName: {
    outputProp: 'legendItemNames',
    reducer: DEFAULTING_ARRAY_REDUCER('legendItemName', SKIP),
    start: []
  },
  grouped: {
    outputProp: 'grouped',
    reducer: BOOLEAN_OR_REDUCER('grouped'),
    seriesType: ['bar', 'column'],
    start: undefined
  },
  showInLegend: {
    outputProp: 'hideInLegend',
    reducer: YKEYS_REDUCER('showInLegend', false),
    seriesType: ['bar', 'column'],
    start: []
  },
  stackGroup: {
    outputProp: 'stackGroups',
    reducer: STACK_GROUPS_REDUCER(),
    seriesType: ['bar', 'column'],
    start: {}
  }
};
/**
 * Takes an array of bar or area series options objects and returns a single object with the combined area series options.
 */
function reduceSeries(series) {
  const options = {};
  series.forEach((s, idx) => {
    Object.keys(s).forEach(prop => {
      var _a;
      const reducerConfig = REDUCE_CONFIG[prop];
      const defaultReduce = () => {
        var _a, _b;
        options[prop] = (_b = (_a = s[prop]) !== null && _a !== void 0 ? _a : options[prop]) !== null && _b !== void 0 ? _b : undefined;
      };
      if (!reducerConfig) {
        defaultReduce();
        return;
      }
      const {
        outputProp,
        reducer,
        start = undefined,
        seriesType = [s.type]
      } = reducerConfig;
      if (!seriesType.includes(s.type)) {
        defaultReduce();
        return;
      }
      const result = reducer((_a = options[outputProp]) !== null && _a !== void 0 ? _a : start, s, idx, series.length);
      if (result !== undefined) {
        options[outputProp] = result;
      }
    });
  });
  return options;
}
/**
 * Transforms provided series options array into an array containing series options which are compatible with standalone charts series options.
 */
function processSeriesOptions(seriesOptions) {
  const result = [];
  const preprocessed = seriesOptions.map(series => {
    var _a;
    // Change the default for bar/columns when yKey is used to be grouped rather than stacked.
    if ((series.type === 'bar' || series.type === 'column') && series.yKey != null && !series.stacked) {
      return Object.assign(Object.assign({}, series), {
        grouped: (_a = series.grouped) !== null && _a !== void 0 ? _a : true
      });
    }
    return series;
  });
  for (const series of groupSeriesByType(preprocessed)) {
    switch (series[0].type) {
      case 'column':
      case 'bar':
      case 'area':
        result.push(reduceSeries(series));
        break;
      case 'line':
      default:
        if (series.length > 1) {
          Logger.warn('unexpected grouping of series type: ' + series[0].type);
        }
        result.push(series[0]);
        break;
    }
  }
  return result;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/mapping/prepare.mjs










function optionsType(input) {
  var _a, _b, _c, _d;
  return (_d = (_a = input.type) !== null && _a !== void 0 ? _a : (_c = (_b = input.series) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : 'line';
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return true;
  }
  if (specifiedType === 'cartesian') {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return CHART_TYPES.isCartesian(specifiedType);
}
function isAgHierarchyChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === 'hierarchy') {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return CHART_TYPES.isHierarchy(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === 'polar') {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return CHART_TYPES.isPolar(specifiedType);
}
function isSeriesOptionType(input) {
  if (input == null) {
    return false;
  }
  return CHART_TYPES.has(input);
}
function isAxisOptionType(input) {
  if (input == null) {
    return false;
  }
  return CHART_AXES_TYPES.has(input);
}
function countArrayElements(input) {
  let count = 0;
  for (const next of input) {
    if (next instanceof Array) {
      count += countArrayElements(next);
    }
    if (next != null) {
      count++;
    }
  }
  return count;
}
function takeColours(context, colours, maxCount) {
  const result = [];
  for (let count = 0; count < maxCount; count++) {
    result.push(colours[(count + context.colourIndex) % colours.length]);
  }
  return result;
}
const noDataCloneMergeOptions = {
  avoidDeepClone: ['data']
};
function prepareOptions(newOptions, fallbackOptions) {
  var _a, _b, _c, _d, _e, _f;
  let options = jsonMerge([fallbackOptions, newOptions], noDataCloneMergeOptions);
  sanityCheckOptions(options);
  // Determine type and ensure it's explicit in the options config.
  const userSuppliedOptionsType = options.type;
  const type = optionsType(options);
  const globalTooltipPositionOptions = (_b = (_a = options.tooltip) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : {};
  const checkSeriesType = type => {
    if (type != null && !(isSeriesOptionType(type) || getSeriesDefaults(type))) {
      throw new Error(`AG Charts - unknown series type: ${type}; expected one of: ${CHART_TYPES.seriesTypes}`);
    }
  };
  checkSeriesType(type);
  for (const {
    type: seriesType
  } of (_c = options.series) !== null && _c !== void 0 ? _c : []) {
    if (seriesType == null) continue;
    checkSeriesType(seriesType);
  }
  options = Object.assign(Object.assign({}, options), {
    type
  });
  let defaultSeriesType = 'line';
  if (isAgCartesianChartOptions(options)) {
    defaultSeriesType = 'line';
  } else if (isAgHierarchyChartOptions(options)) {
    defaultSeriesType = 'treemap';
  } else if (isAgPolarChartOptions(options)) {
    defaultSeriesType = 'pie';
  }
  let defaultOverrides = {};
  const seriesDefaults = getSeriesDefaults(type);
  if (seriesDefaults) {
    defaultOverrides = seriesDefaults;
  } else if (type === 'bar') {
    defaultOverrides = DEFAULT_BAR_CHART_OVERRIDES;
  } else if (type === 'scatter' || type === 'histogram') {
    defaultOverrides = DEFAULT_SCATTER_HISTOGRAM_CHART_OVERRIDES;
  } else if (isAgCartesianChartOptions(options)) {
    defaultOverrides = DEFAULT_CARTESIAN_CHART_OVERRIDES;
  }
  removeDisabledOptions(options);
  const {
    context,
    mergedOptions,
    axesThemes,
    seriesThemes
  } = prepareMainOptions(defaultOverrides, options);
  // Special cases where we have arrays of elements which need their own defaults.
  // Apply series themes before calling processSeriesOptions() as it reduces and renames some
  // properties, and in that case then cannot correctly have themes applied.
  mergedOptions.series = processSeriesOptions(((_d = mergedOptions.series) !== null && _d !== void 0 ? _d : []).map(s => {
    let type = defaultSeriesType;
    if (s.type) {
      type = s.type;
    } else if (isSeriesOptionType(userSuppliedOptionsType)) {
      type = userSuppliedOptionsType;
    }
    const mergedSeries = mergeSeriesOptions(s, type, seriesThemes, globalTooltipPositionOptions);
    if (type === 'pie') {
      preparePieOptions(seriesThemes.pie, s, mergedSeries);
    }
    return mergedSeries;
  })).map(s => prepareSeries(context, s));
  const checkAxisType = type => {
    const isAxisType = isAxisOptionType(type);
    if (!isAxisType) {
      Logger.warnOnce(`AG Charts - unknown axis type: ${type}; expected one of: ${CHART_AXES_TYPES.axesTypes}, ignoring.`);
    }
    return isAxisType;
  };
  if (isAgCartesianChartOptions(mergedOptions)) {
    let validAxesTypes = true;
    for (const {
      type: axisType
    } of (_e = mergedOptions.axes) !== null && _e !== void 0 ? _e : []) {
      if (!checkAxisType(axisType)) {
        validAxesTypes = false;
      }
    }
    if (!validAxesTypes) {
      mergedOptions.axes = defaultOverrides.axes;
    } else {
      mergedOptions.axes = (_f = mergedOptions.axes) === null || _f === void 0 ? void 0 : _f.map(axis => {
        var _a, _b;
        const axisType = axis.type;
        const axesTheme = jsonMerge([axesThemes[axisType], (_b = axesThemes[axisType][(_a = axis.position) !== null && _a !== void 0 ? _a : 'unknown']) !== null && _b !== void 0 ? _b : {}]);
        return prepareAxis(axis, axesTheme);
      });
    }
    prepareLegendEnabledOption(options, mergedOptions);
  }
  prepareEnabledOptions(options, mergedOptions);
  return mergedOptions;
}
function sanityCheckOptions(options) {
  const deprecatedArrayProps = {
    yKeys: 'yKey',
    yNames: 'yName'
  };
  Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {
    var _a;
    if ((_a = options.series) === null || _a === void 0 ? void 0 : _a.some(s => s[oldProp] != null)) {
      Logger.warnOnce(`property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`);
    }
  });
}
function mergeSeriesOptions(series, type, seriesThemes, globalTooltipPositionOptions) {
  var _a, _b;
  const mergedTooltipPosition = jsonMerge([Object.assign({}, globalTooltipPositionOptions), (_a = series.tooltip) === null || _a === void 0 ? void 0 : _a.position], noDataCloneMergeOptions);
  const mergedSeries = jsonMerge([(_b = seriesThemes[type]) !== null && _b !== void 0 ? _b : {}, Object.assign(Object.assign({}, series), {
    type,
    tooltip: Object.assign(Object.assign({}, series.tooltip), {
      position: mergedTooltipPosition
    })
  })], noDataCloneMergeOptions);
  return mergedSeries;
}
function prepareMainOptions(defaultOverrides, options) {
  const {
    theme,
    cleanedTheme,
    axesThemes,
    seriesThemes
  } = prepareTheme(options);
  const context = {
    colourIndex: 0,
    palette: theme.palette
  };
  const mergedOptions = jsonMerge([defaultOverrides, cleanedTheme, options], noDataCloneMergeOptions);
  return {
    context,
    mergedOptions,
    axesThemes,
    seriesThemes
  };
}
function prepareTheme(options) {
  var _a, _b;
  const theme = getChartTheme(options.theme);
  const themeConfig = theme.config[(_a = optionsType(options)) !== null && _a !== void 0 ? _a : 'cartesian'];
  const seriesThemes = Object.entries(theme.config).reduce((result, [seriesType, {
    series
  }]) => {
    result[seriesType] = series === null || series === void 0 ? void 0 : series[seriesType];
    return result;
  }, {});
  return {
    theme,
    axesThemes: (_b = themeConfig['axes']) !== null && _b !== void 0 ? _b : {},
    seriesThemes: seriesThemes,
    cleanedTheme: jsonMerge([themeConfig, {
      axes: DELETE,
      series: DELETE
    }])
  };
}
function prepareSeries(context, input, ...defaults) {
  const paletteOptions = calculateSeriesPalette(context, input);
  // Part of the options interface, but not directly consumed by the series implementations.
  const removeOptions = {
    stacked: DELETE
  };
  const mergedResult = jsonMerge([...defaults, paletteOptions, input, removeOptions], noDataCloneMergeOptions);
  return applySeriesTransform(mergedResult);
}
function calculateSeriesPalette(context, input) {
  var _a;
  const paletteOptions = {};
  const {
    palette: {
      fills,
      strokes
    }
  } = context;
  const inputAny = input;
  let colourCount = countArrayElements((_a = inputAny['yKeys']) !== null && _a !== void 0 ? _a : []) || 1; // Defaults to 1 if no yKeys.
  switch (input.type) {
    case 'pie':
      colourCount = Math.max(fills.length, strokes.length);
    // eslint-disable-next-line no-fallthrough
    case 'area':
    case 'bar':
    case 'column':
      paletteOptions.fills = takeColours(context, fills, colourCount);
      paletteOptions.strokes = takeColours(context, strokes, colourCount);
      break;
    case 'histogram':
      paletteOptions.fill = takeColours(context, fills, 1)[0];
      paletteOptions.stroke = takeColours(context, strokes, 1)[0];
      break;
    case 'scatter':
      paletteOptions.marker = {
        stroke: takeColours(context, strokes, 1)[0],
        fill: takeColours(context, fills, 1)[0]
      };
      break;
    case 'line':
      paletteOptions.stroke = takeColours(context, fills, 1)[0];
      paletteOptions.marker = {
        stroke: takeColours(context, strokes, 1)[0],
        fill: takeColours(context, fills, 1)[0]
      };
      break;
  }
  context.colourIndex += colourCount;
  return paletteOptions;
}
function prepareAxis(axis, axisTheme) {
  // Remove redundant theme overload keys.
  const removeOptions = {
    top: DELETE,
    bottom: DELETE,
    left: DELETE,
    right: DELETE
  };
  // Special cross lines case where we have an array of cross line elements which need their own defaults.
  if (axis.crossLines) {
    if (!Array.isArray(axis.crossLines)) {
      Logger.warn('axis[].crossLines should be an array.');
      axis.crossLines = [];
    }
    const {
      crossLines: crossLinesTheme
    } = axisTheme;
    axis.crossLines = axis.crossLines.map(crossLine => jsonMerge([crossLinesTheme, crossLine]));
  }
  const cleanTheme = {
    crossLines: DELETE
  };
  return jsonMerge([axisTheme, cleanTheme, axis, removeOptions], noDataCloneMergeOptions);
}
function removeDisabledOptions(options) {
  // Remove configurations from all option objects with a `false` value for the `enabled` property.
  jsonWalk(options, (_, visitingUserOpts) => {
    if (!('enabled' in visitingUserOpts)) return;
    if (visitingUserOpts.enabled === false) {
      Object.entries(visitingUserOpts).forEach(([key]) => {
        if (key === 'enabled') return;
        delete visitingUserOpts[key];
      });
    }
  }, {
    skip: ['data', 'theme']
  });
}
function prepareLegendEnabledOption(options, mergedOptions) {
  var _a, _b, _c, _d;
  // Disable legend by default for single series cartesian charts
  if (((_a = options.legend) === null || _a === void 0 ? void 0 : _a.enabled) !== undefined || ((_b = mergedOptions.legend) === null || _b === void 0 ? void 0 : _b.enabled) !== undefined) {
    return;
  }
  (_c = mergedOptions.legend) !== null && _c !== void 0 ? _c : mergedOptions.legend = {};
  if (((_d = options.series) !== null && _d !== void 0 ? _d : []).length > 1) {
    mergedOptions.legend.enabled = true;
    return;
  }
  mergedOptions.legend.enabled = false;
}
function prepareEnabledOptions(options, mergedOptions) {
  // Set `enabled: true` for all option objects where the user has provided values.
  jsonWalk(options, (_, visitingUserOpts, visitingMergedOpts) => {
    if (!visitingMergedOpts) return;
    const {
      _enabledFromTheme
    } = visitingMergedOpts;
    if (_enabledFromTheme != null) {
      // Do not apply special handling, base enablement on theme.
      delete visitingMergedOpts._enabledFromTheme;
    }
    if (!('enabled' in visitingMergedOpts)) return;
    if (_enabledFromTheme) return;
    if (visitingUserOpts.enabled == null) {
      visitingMergedOpts.enabled = true;
    }
  }, {
    skip: ['data', 'theme']
  }, mergedOptions);
  // Cleanup any special properties.
  jsonWalk(mergedOptions, (_, visitingMergedOpts) => {
    if (visitingMergedOpts._enabledFromTheme != null) {
      // Do not apply special handling, base enablement on theme.
      delete visitingMergedOpts._enabledFromTheme;
    }
  }, {
    skip: ['data', 'theme']
  });
}
function preparePieOptions(pieSeriesTheme, seriesOptions, mergedSeries) {
  if (Array.isArray(seriesOptions.innerLabels)) {
    mergedSeries.innerLabels = seriesOptions.innerLabels.map(ln => {
      return jsonMerge([pieSeriesTheme.innerLabels, ln]);
    });
  } else {
    mergedSeries.innerLabels = DELETE;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/crossline/crossLineLabelPosition.mjs
const horizontalCrosslineTranslationDirections = {
  top: {
    xTranslationDirection: 0,
    yTranslationDirection: -1
  },
  bottom: {
    xTranslationDirection: 0,
    yTranslationDirection: 1
  },
  left: {
    xTranslationDirection: -1,
    yTranslationDirection: 0
  },
  right: {
    xTranslationDirection: 1,
    yTranslationDirection: 0
  },
  topLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: -1
  },
  topRight: {
    xTranslationDirection: -1,
    yTranslationDirection: -1
  },
  bottomLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: 1
  },
  bottomRight: {
    xTranslationDirection: -1,
    yTranslationDirection: 1
  },
  inside: {
    xTranslationDirection: 0,
    yTranslationDirection: 0
  },
  insideLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: 0
  },
  insideRight: {
    xTranslationDirection: -1,
    yTranslationDirection: 0
  },
  insideTop: {
    xTranslationDirection: 0,
    yTranslationDirection: 1
  },
  insideBottom: {
    xTranslationDirection: 0,
    yTranslationDirection: -1
  },
  insideTopLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: 1
  },
  insideBottomLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: -1
  },
  insideTopRight: {
    xTranslationDirection: -1,
    yTranslationDirection: 1
  },
  insideBottomRight: {
    xTranslationDirection: -1,
    yTranslationDirection: -1
  }
};
const verticalCrossLineTranslationDirections = {
  top: {
    xTranslationDirection: 1,
    yTranslationDirection: 0
  },
  bottom: {
    xTranslationDirection: -1,
    yTranslationDirection: 0
  },
  left: {
    xTranslationDirection: 0,
    yTranslationDirection: -1
  },
  right: {
    xTranslationDirection: 0,
    yTranslationDirection: 1
  },
  topLeft: {
    xTranslationDirection: -1,
    yTranslationDirection: -1
  },
  topRight: {
    xTranslationDirection: -1,
    yTranslationDirection: 1
  },
  bottomLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: -1
  },
  bottomRight: {
    xTranslationDirection: 1,
    yTranslationDirection: 1
  },
  inside: {
    xTranslationDirection: 0,
    yTranslationDirection: 0
  },
  insideLeft: {
    xTranslationDirection: 0,
    yTranslationDirection: 1
  },
  insideRight: {
    xTranslationDirection: 0,
    yTranslationDirection: -1
  },
  insideTop: {
    xTranslationDirection: -1,
    yTranslationDirection: 0
  },
  insideBottom: {
    xTranslationDirection: 1,
    yTranslationDirection: 0
  },
  insideTopLeft: {
    xTranslationDirection: -1,
    yTranslationDirection: 1
  },
  insideBottomLeft: {
    xTranslationDirection: 1,
    yTranslationDirection: 1
  },
  insideTopRight: {
    xTranslationDirection: -1,
    yTranslationDirection: -1
  },
  insideBottomRight: {
    xTranslationDirection: 1,
    yTranslationDirection: -1
  }
};
function calculateLabelTranslation({
  yDirection,
  padding = 0,
  position = 'top',
  bbox
}) {
  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;
  const {
    xTranslationDirection,
    yTranslationDirection
  } = crossLineTranslationDirections[position];
  const w = yDirection ? bbox.width : bbox.height;
  const h = yDirection ? bbox.height : bbox.width;
  const xTranslation = xTranslationDirection * (padding + w / 2);
  const yTranslation = yTranslationDirection * (padding + h / 2);
  const result = {
    xTranslation,
    yTranslation
  };
  return result;
}
function calculateLabelChartPadding({
  yDirection,
  bbox,
  padding = 0,
  position = 'top'
}) {
  const chartPadding = {};
  if (position.startsWith('inside')) return chartPadding;
  if (position === 'top' && !yDirection) {
    chartPadding.top = padding + bbox.height;
  } else if (position === 'bottom' && !yDirection) {
    chartPadding.bottom = padding + bbox.height;
  } else if (position === 'left' && yDirection) {
    chartPadding.left = padding + bbox.width;
  } else if (position === 'right' && yDirection) {
    chartPadding.right = padding + bbox.width;
  }
  return chartPadding;
}
const POSITION_TOP_COORDINATES = ({
  yDirection,
  xEnd,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xEnd / 2,
      y: yStart
    };
  } else {
    return {
      x: xEnd,
      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart
    };
  }
};
const POSITION_LEFT_COORDINATES = ({
  yDirection,
  xStart,
  xEnd,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xStart,
      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart
    };
  } else {
    return {
      x: xEnd / 2,
      y: yStart
    };
  }
};
const POSITION_RIGHT_COORDINATES = ({
  yDirection,
  xEnd,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xEnd,
      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart
    };
  } else {
    return {
      x: xEnd / 2,
      y: !isNaN(yEnd) ? yEnd : yStart
    };
  }
};
const POSITION_BOTTOM_COORDINATES = ({
  yDirection,
  xStart,
  xEnd,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xEnd / 2,
      y: !isNaN(yEnd) ? yEnd : yStart
    };
  } else {
    return {
      x: xStart,
      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart
    };
  }
};
const POSITION_INSIDE_COORDINATES = ({
  xEnd,
  yStart,
  yEnd
}) => {
  return {
    x: xEnd / 2,
    y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart
  };
};
const POSITION_TOP_LEFT_COORDINATES = ({
  yDirection,
  xStart,
  xEnd,
  yStart
}) => {
  if (yDirection) {
    return {
      x: xStart / 2,
      y: yStart
    };
  } else {
    return {
      x: xEnd,
      y: yStart
    };
  }
};
const POSITION_BOTTOM_LEFT_COORDINATES = ({
  yDirection,
  xStart,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xStart,
      y: !isNaN(yEnd) ? yEnd : yStart
    };
  } else {
    return {
      x: xStart,
      y: yStart
    };
  }
};
const POSITION_TOP_RIGHT_COORDINATES = ({
  yDirection,
  xEnd,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xEnd,
      y: yStart
    };
  } else {
    return {
      x: xEnd,
      y: !isNaN(yEnd) ? yEnd : yStart
    };
  }
};
const POSITION_BOTTOM_RIGHT_COORDINATES = ({
  yDirection,
  xStart,
  xEnd,
  yStart,
  yEnd
}) => {
  if (yDirection) {
    return {
      x: xEnd,
      y: !isNaN(yEnd) ? yEnd : yStart
    };
  } else {
    return {
      x: xStart,
      y: !isNaN(yEnd) ? yEnd : yStart
    };
  }
};
const labeldDirectionHandling = {
  top: {
    c: POSITION_TOP_COORDINATES
  },
  bottom: {
    c: POSITION_BOTTOM_COORDINATES
  },
  left: {
    c: POSITION_LEFT_COORDINATES
  },
  right: {
    c: POSITION_RIGHT_COORDINATES
  },
  topLeft: {
    c: POSITION_TOP_LEFT_COORDINATES
  },
  topRight: {
    c: POSITION_TOP_RIGHT_COORDINATES
  },
  bottomLeft: {
    c: POSITION_BOTTOM_LEFT_COORDINATES
  },
  bottomRight: {
    c: POSITION_BOTTOM_RIGHT_COORDINATES
  },
  inside: {
    c: POSITION_INSIDE_COORDINATES
  },
  insideLeft: {
    c: POSITION_LEFT_COORDINATES
  },
  insideRight: {
    c: POSITION_RIGHT_COORDINATES
  },
  insideTop: {
    c: POSITION_TOP_COORDINATES
  },
  insideBottom: {
    c: POSITION_BOTTOM_COORDINATES
  },
  insideTopLeft: {
    c: POSITION_TOP_LEFT_COORDINATES
  },
  insideBottomLeft: {
    c: POSITION_BOTTOM_LEFT_COORDINATES
  },
  insideTopRight: {
    c: POSITION_TOP_RIGHT_COORDINATES
  },
  insideBottomRight: {
    c: POSITION_BOTTOM_RIGHT_COORDINATES
  }
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/shape/range.mjs
var range_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class Range extends Shape {
  constructor() {
    super();
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.startLine = false;
    this.endLine = false;
    this.isRange = false;
    this.restoreOwnStyles();
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    var _a;
    const {
      ctx,
      forceRender,
      stats
    } = renderCtx;
    if (this.dirty === RedrawType.NONE && !forceRender) {
      if (stats) stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    let {
      x1,
      y1,
      x2,
      y2
    } = this;
    x1 = this.align(x1);
    y1 = this.align(y1);
    x2 = this.align(x2);
    y2 = this.align(y2);
    const {
      fill,
      opacity,
      isRange
    } = this;
    const fillActive = !!(isRange && fill);
    if (fillActive) {
      const {
        fillOpacity
      } = this;
      ctx.fillStyle = fill;
      ctx.globalAlpha = opacity * fillOpacity;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x1, y2);
      ctx.closePath();
      ctx.fill();
    }
    const {
      stroke,
      strokeWidth,
      startLine,
      endLine
    } = this;
    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);
    if (strokeActive) {
      const {
        strokeOpacity,
        lineDash,
        lineDashOffset,
        lineCap,
        lineJoin
      } = this;
      ctx.strokeStyle = stroke;
      ctx.globalAlpha = opacity * strokeOpacity;
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.beginPath();
      if (startLine) {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
      }
      if (endLine) {
        ctx.moveTo(x2, y2);
        ctx.lineTo(x1, y2);
      }
      ctx.stroke();
    }
    (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();
    super.render(renderCtx);
  }
}
Range.className = 'Range';
Range.defaultStyles = Object.assign(Object.assign({}, Shape.defaultStyles), {
  strokeWidth: 1
});
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "x1", void 0);
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "y1", void 0);
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "x2", void 0);
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "y2", void 0);
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "startLine", void 0);
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "endLine", void 0);
range_decorate([SceneChangeDetection({
  redraw: RedrawType.MINOR
})], Range.prototype, "isRange", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/crossline/crossLine.mjs
var crossLine_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};












const CROSSLINE_LABEL_POSITIONS = ['top', 'left', 'right', 'bottom', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'inside', 'insideLeft', 'insideRight', 'insideTop', 'insideBottom', 'insideTopLeft', 'insideBottomLeft', 'insideTopRight', 'insideBottomRight'];
const OPT_CROSSLINE_LABEL_POSITION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, v => CROSSLINE_LABEL_POSITIONS.includes(v)), `expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'`);
const OPT_CROSSLINE_TYPE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, v => v === 'range' || v === 'line'), `expecting a crossLine type keyword such as 'range' or 'line'`);
class CrossLineLabel {
  constructor() {
    this.enabled = undefined;
    this.text = undefined;
    this.fontStyle = undefined;
    this.fontWeight = undefined;
    this.fontSize = 14;
    this.fontFamily = 'Verdana, sans-serif';
    /**
     * The padding between the label and the line.
     */
    this.padding = 5;
    /**
     * The color of the labels.
     */
    this.color = 'rgba(87, 87, 87, 1)';
    this.position = undefined;
    this.rotation = undefined;
    this.parallel = undefined;
  }
}
crossLine_decorate([Validate(OPT_BOOLEAN)], CrossLineLabel.prototype, "enabled", void 0);
crossLine_decorate([Validate(OPT_STRING)], CrossLineLabel.prototype, "text", void 0);
crossLine_decorate([Validate(OPT_FONT_STYLE)], CrossLineLabel.prototype, "fontStyle", void 0);
crossLine_decorate([Validate(OPT_FONT_WEIGHT)], CrossLineLabel.prototype, "fontWeight", void 0);
crossLine_decorate([Validate(NUMBER(0))], CrossLineLabel.prototype, "fontSize", void 0);
crossLine_decorate([Validate(STRING)], CrossLineLabel.prototype, "fontFamily", void 0);
crossLine_decorate([Validate(NUMBER(0))], CrossLineLabel.prototype, "padding", void 0);
crossLine_decorate([Validate(OPT_COLOR_STRING)], CrossLineLabel.prototype, "color", void 0);
crossLine_decorate([Validate(OPT_CROSSLINE_LABEL_POSITION)], CrossLineLabel.prototype, "position", void 0);
crossLine_decorate([Validate(OPT_NUMBER(-360, 360))], CrossLineLabel.prototype, "rotation", void 0);
crossLine_decorate([Validate(OPT_BOOLEAN)], CrossLineLabel.prototype, "parallel", void 0);
class CrossLine {
  constructor() {
    this.id = createId(this);
    this.enabled = undefined;
    this.type = undefined;
    this.range = undefined;
    this.value = undefined;
    this.fill = undefined;
    this.fillOpacity = undefined;
    this.stroke = undefined;
    this.strokeWidth = undefined;
    this.strokeOpacity = undefined;
    this.lineDash = undefined;
    this.label = new CrossLineLabel();
    this.scale = undefined;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = ChartAxisDirection.X;
    this.group = new Group({
      name: `${this.id}`,
      layer: true,
      zIndex: CrossLine.LINE_LAYER_ZINDEX
    });
    this.crossLineRange = new Range();
    this.crossLineLabel = new Text();
    this.labelPoint = undefined;
    this.data = [];
    this.startLine = false;
    this.endLine = false;
    this.isRange = false;
    const {
      group,
      crossLineRange,
      crossLineLabel
    } = this;
    group.append([crossLineRange, crossLineLabel]);
    crossLineRange.pointerEvents = PointerEvents.None;
  }
  update(visible) {
    if (!this.enabled) {
      return;
    }
    this.group.visible = visible;
    if (!visible) {
      return;
    }
    const dataCreated = this.createNodeData();
    if (!dataCreated) {
      this.group.visible = false;
      return;
    }
    this.updateNodes();
    this.group.zIndex = this.getZIndex(this.isRange);
  }
  updateNodes() {
    this.updateRangeNode();
    if (this.label.enabled) {
      this.updateLabel();
      this.positionLabel();
    }
  }
  createNodeData() {
    var _a, _b;
    const {
      scale,
      gridLength,
      sideFlag,
      direction,
      label: {
        position = 'top'
      },
      clippedRange,
      strokeWidth = 0
    } = this;
    if (!scale) {
      return false;
    }
    const bandwidth = (_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0;
    const clippedRangeClamper = x => Math.max(Math.min(...clippedRange), Math.min(Math.max(...clippedRange), x));
    const [xStart, xEnd] = [0, sideFlag * gridLength];
    let [yStart, yEnd] = this.getRange();
    let [clampedYStart, clampedYEnd] = [Number(scale.convert(yStart, {
      strict: false
    })), scale.convert(yEnd, {
      strict: false
    }) + bandwidth];
    clampedYStart = clippedRangeClamper(clampedYStart);
    clampedYEnd = clippedRangeClamper(clampedYEnd);
    [yStart, yEnd] = [Number(scale.convert(yStart)), scale.convert(yEnd) + bandwidth];
    const validRange = !isNaN(clampedYStart) && !isNaN(clampedYEnd) && (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;
    if (validRange) {
      const reverse = clampedYStart !== Math.min(clampedYStart, clampedYEnd);
      if (reverse) {
        [clampedYStart, clampedYEnd] = [Math.min(clampedYStart, clampedYEnd), Math.max(clampedYStart, clampedYEnd)];
        [yStart, yEnd] = [yEnd, yStart];
      }
    }
    this.isRange = validRange;
    this.startLine = !isNaN(yStart) && strokeWidth > 0 && yStart === clampedYStart;
    this.endLine = !isNaN(yEnd) && strokeWidth > 0 && yEnd === clampedYEnd;
    if (!validRange && !this.startLine && !this.endLine) {
      return false;
    }
    this.data = [clampedYStart, clampedYEnd];
    if (this.label.enabled) {
      const yDirection = direction === ChartAxisDirection.Y;
      const {
        c = POSITION_TOP_COORDINATES
      } = (_b = labeldDirectionHandling[position]) !== null && _b !== void 0 ? _b : {};
      const {
        x: labelX,
        y: labelY
      } = c({
        yDirection,
        xStart,
        xEnd,
        yStart: clampedYStart,
        yEnd: clampedYEnd
      });
      this.labelPoint = {
        x: labelX,
        y: labelY
      };
    }
    return true;
  }
  updateRangeNode() {
    var _a;
    const {
      crossLineRange,
      sideFlag,
      gridLength,
      data,
      startLine,
      endLine,
      isRange,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      lineDash
    } = this;
    crossLineRange.x1 = 0;
    crossLineRange.x2 = sideFlag * gridLength;
    crossLineRange.y1 = data[0];
    crossLineRange.y2 = data[1];
    crossLineRange.startLine = startLine;
    crossLineRange.endLine = endLine;
    crossLineRange.isRange = isRange;
    crossLineRange.fill = fill;
    crossLineRange.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;
    crossLineRange.stroke = stroke;
    crossLineRange.strokeWidth = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1;
    crossLineRange.strokeOpacity = (_a = this.strokeOpacity) !== null && _a !== void 0 ? _a : 1;
    crossLineRange.lineDash = lineDash;
  }
  updateLabel() {
    const {
      crossLineLabel,
      label
    } = this;
    if (!label.text) {
      return;
    }
    crossLineLabel.fontStyle = label.fontStyle;
    crossLineLabel.fontWeight = label.fontWeight;
    crossLineLabel.fontSize = label.fontSize;
    crossLineLabel.fontFamily = label.fontFamily;
    crossLineLabel.fill = label.color;
    crossLineLabel.text = label.text;
  }
  positionLabel() {
    const {
      crossLineLabel,
      labelPoint: {
        x = undefined,
        y = undefined
      } = {},
      label: {
        parallel,
        rotation,
        position = 'top',
        padding = 0
      },
      direction,
      parallelFlipRotation,
      regularFlipRotation
    } = this;
    if (x === undefined || y === undefined) {
      return;
    }
    const {
      defaultRotation,
      configuredRotation
    } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    crossLineLabel.rotation = defaultRotation + configuredRotation;
    crossLineLabel.textBaseline = 'middle';
    crossLineLabel.textAlign = 'center';
    const bbox = this.computeLabelBBox();
    if (!bbox) {
      return;
    }
    const yDirection = direction === ChartAxisDirection.Y;
    const {
      xTranslation,
      yTranslation
    } = calculateLabelTranslation({
      yDirection,
      padding,
      position,
      bbox
    });
    crossLineLabel.translationX = x + xTranslation;
    crossLineLabel.translationY = y + yTranslation;
  }
  getZIndex(isRange = false) {
    if (isRange) {
      return CrossLine.RANGE_LAYER_ZINDEX;
    }
    return CrossLine.LINE_LAYER_ZINDEX;
  }
  getRange() {
    const {
      value,
      range,
      scale
    } = this;
    const isContinuous = scale instanceof ContinuousScale;
    let [start, end] = range !== null && range !== void 0 ? range : [value, undefined];
    if (!isContinuous && end === undefined) {
      end = start;
    }
    start = checkDatum(start, isContinuous) != null ? start : undefined;
    end = checkDatum(end, isContinuous) != null ? end : undefined;
    if (isContinuous && start === end) {
      end = undefined;
    }
    if (start === undefined && end !== undefined) {
      start = end;
      end = undefined;
    }
    return [start, end];
  }
  computeLabelBBox() {
    return this.crossLineLabel.computeTransformedBBox();
  }
  calculatePadding(padding) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const {
      isRange,
      startLine,
      endLine,
      direction,
      label: {
        padding: labelPadding = 0,
        position = 'top'
      }
    } = this;
    if (!isRange && !startLine && !endLine) {
      return;
    }
    const crossLineLabelBBox = this.computeLabelBBox();
    const labelX = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.x;
    const labelY = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.y;
    if (!crossLineLabelBBox || labelX == undefined || labelY == undefined) {
      return;
    }
    const chartPadding = calculateLabelChartPadding({
      yDirection: direction === ChartAxisDirection.Y,
      padding: labelPadding,
      position,
      bbox: crossLineLabelBBox
    });
    padding.left = Math.max((_a = padding.left) !== null && _a !== void 0 ? _a : 0, (_b = chartPadding.left) !== null && _b !== void 0 ? _b : 0);
    padding.right = Math.max((_c = padding.right) !== null && _c !== void 0 ? _c : 0, (_d = chartPadding.right) !== null && _d !== void 0 ? _d : 0);
    padding.top = Math.max((_e = padding.top) !== null && _e !== void 0 ? _e : 0, (_f = chartPadding.top) !== null && _f !== void 0 ? _f : 0);
    padding.bottom = Math.max((_g = padding.bottom) !== null && _g !== void 0 ? _g : 0, (_h = chartPadding.bottom) !== null && _h !== void 0 ? _h : 0);
  }
}
CrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;
CrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;
CrossLine.className = 'CrossLine';
crossLine_decorate([Validate(OPT_BOOLEAN)], CrossLine.prototype, "enabled", void 0);
crossLine_decorate([Validate(OPT_CROSSLINE_TYPE)], CrossLine.prototype, "type", void 0);
crossLine_decorate([Validate(OPT_ARRAY(2))], CrossLine.prototype, "range", void 0);
crossLine_decorate([Validate(OPT_COLOR_STRING)], CrossLine.prototype, "fill", void 0);
crossLine_decorate([Validate(OPT_NUMBER(0, 1))], CrossLine.prototype, "fillOpacity", void 0);
crossLine_decorate([Validate(OPT_COLOR_STRING)], CrossLine.prototype, "stroke", void 0);
crossLine_decorate([Validate(OPT_NUMBER())], CrossLine.prototype, "strokeWidth", void 0);
crossLine_decorate([Validate(OPT_NUMBER(0, 1))], CrossLine.prototype, "strokeOpacity", void 0);
crossLine_decorate([Validate(OPT_LINE_DASH)], CrossLine.prototype, "lineDash", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/chartOptions.mjs





const JSON_APPLY_PLUGINS = {
  constructors: {}
};
const JSON_APPLY_OPTIONS = {
  constructors: {
    title: Caption,
    subtitle: Caption,
    footnote: Caption,
    shadow: DropShadow,
    innerCircle: DoughnutInnerCircle,
    'axes[].crossLines[]': CrossLine,
    'axes[].title': AxisTitle,
    'series[].innerLabels[]': DoughnutInnerLabel
  },
  allowedTypes: {
    'legend.pagination.marker.shape': ['primitive', 'function'],
    'series[].marker.shape': ['primitive', 'function'],
    'axis[].tick.count': ['primitive', 'class-instance']
  }
};
function getJsonApplyOptions() {
  return {
    constructors: Object.assign(Object.assign({}, JSON_APPLY_OPTIONS.constructors), JSON_APPLY_PLUGINS.constructors),
    allowedTypes: Object.assign({}, JSON_APPLY_OPTIONS.allowedTypes)
  };
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/module.mjs

class BaseModuleInstance {
  constructor() {
    this.destroyFns = [];
  }
  destroy() {
    for (const destroyFn of this.destroyFns) {
      destroyFn();
    }
  }
}
const REGISTERED_MODULES = [];
function registerModule(module) {
  const otherModule = REGISTERED_MODULES.find(other => {
    return module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier;
  });
  if (otherModule) {
    if (module.packageType === 'enterprise' && otherModule.packageType === 'community') {
      // Replace the community module with an enterprise version
      const index = REGISTERED_MODULES.indexOf(otherModule);
      REGISTERED_MODULES.splice(index, 1, module);
    } else {
      // Skip if the module is already registered
    }
  } else {
    // Simply register the module
    REGISTERED_MODULES.push(module);
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/shapes/rangeHandle.mjs
var rangeHandle_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class RangeHandle extends Path {
  constructor() {
    super(...arguments);
    this._fill = '#f2f2f2';
    this._stroke = '#999999';
    this._strokeWidth = 1;
    this._lineCap = 'square';
    this._centerX = 0;
    this._centerY = 0;
    // Use an even number for better looking results.
    this._width = 8;
    // Use an even number for better looking results.
    this._gripLineGap = 2;
    // Use an even number for better looking results.
    this._gripLineLength = 8;
    this._height = 16;
  }
  set centerX(value) {
    if (this._centerX !== value) {
      this._centerX = value;
      this.dirtyPath = true;
    }
  }
  get centerX() {
    return this._centerX;
  }
  set centerY(value) {
    if (this._centerY !== value) {
      this._centerY = value;
      this.dirtyPath = true;
    }
  }
  get centerY() {
    return this._centerY;
  }
  set width(value) {
    if (this._width !== value) {
      this._width = value;
      this.dirtyPath = true;
    }
  }
  get width() {
    return this._width;
  }
  set gripLineGap(value) {
    if (this._gripLineGap !== value) {
      this._gripLineGap = value;
      this.dirtyPath = true;
    }
  }
  get gripLineGap() {
    return this._gripLineGap;
  }
  set gripLineLength(value) {
    if (this._gripLineLength !== value) {
      this._gripLineLength = value;
      this.dirtyPath = true;
    }
  }
  get gripLineLength() {
    return this._gripLineLength;
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this.dirtyPath = true;
    }
  }
  get height() {
    return this._height;
  }
  computeBBox() {
    const {
      centerX,
      centerY,
      width,
      height
    } = this;
    const x = centerX - width / 2;
    const y = centerY - height / 2;
    return new BBox(x, y, width, height);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return bbox.containsPoint(point.x, point.y);
  }
  updatePath() {
    const {
      path,
      centerX,
      centerY,
      width,
      height
    } = this;
    path.clear();
    const x = centerX - width / 2;
    const y = centerY - height / 2;
    const ax = this.align(x);
    const ay = this.align(y);
    const axw = ax + this.align(x, width);
    const ayh = ay + this.align(y, height);
    // Handle.
    path.moveTo(ax, ay);
    path.lineTo(axw, ay);
    path.lineTo(axw, ayh);
    path.lineTo(ax, ayh);
    path.lineTo(ax, ay);
    // Grip lines.
    const dx = this.gripLineGap / 2;
    const dy = this.gripLineLength / 2;
    path.moveTo(this.align(centerX - dx), this.align(centerY - dy));
    path.lineTo(this.align(centerX - dx), this.align(centerY + dy));
    path.moveTo(this.align(centerX + dx), this.align(centerY - dy));
    path.lineTo(this.align(centerX + dx), this.align(centerY + dy));
  }
}
RangeHandle.className = 'RangeHandle';
rangeHandle_decorate([Validate(COLOR_STRING)], RangeHandle.prototype, "_fill", void 0);
rangeHandle_decorate([Validate(COLOR_STRING)], RangeHandle.prototype, "_stroke", void 0);
rangeHandle_decorate([Validate(NUMBER(0))], RangeHandle.prototype, "_strokeWidth", void 0);
rangeHandle_decorate([Validate(LINE_CAP)], RangeHandle.prototype, "_lineCap", void 0);
rangeHandle_decorate([Validate(NUMBER(0))], RangeHandle.prototype, "_width", void 0);
rangeHandle_decorate([Validate(NUMBER(0))], RangeHandle.prototype, "_gripLineGap", void 0);
rangeHandle_decorate([Validate(NUMBER(0))], RangeHandle.prototype, "_gripLineLength", void 0);
rangeHandle_decorate([Validate(NUMBER(0))], RangeHandle.prototype, "_height", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/shapes/rangeMask.mjs
var rangeMask_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class RangeMask extends Path {
  constructor() {
    super(...arguments);
    this._stroke = '#999999';
    this._strokeWidth = 1;
    this._fill = '#999999';
    this._fillOpacity = 0.2;
    this._lineCap = 'square';
    this._x = 0;
    this._y = 0;
    this._width = 200;
    this._height = 30;
    this.minRange = 0.05;
    this._min = 0;
    this._max = 1;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.dirtyPath = true;
    }
  }
  get x() {
    return this._x;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.dirtyPath = true;
    }
  }
  get y() {
    return this._y;
  }
  set width(value) {
    if (this._width !== value) {
      this._width = value;
      this.dirtyPath = true;
    }
  }
  get width() {
    return this._width;
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this.dirtyPath = true;
    }
  }
  get height() {
    return this._height;
  }
  set min(value) {
    var _a;
    value = Math.min(Math.max(value, 0), this.max - this.minRange);
    if (isNaN(value)) {
      return;
    }
    if (this._min !== value) {
      this._min = value;
      this.dirtyPath = true;
      (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }
  get min() {
    return this._min;
  }
  set max(value) {
    var _a;
    value = Math.max(Math.min(value, 1), this.min + this.minRange);
    if (isNaN(value)) {
      return;
    }
    if (this._max !== value) {
      this._max = value;
      this.dirtyPath = true;
      (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }
  get max() {
    return this._max;
  }
  computeBBox() {
    const {
      x,
      y,
      width,
      height
    } = this;
    return new BBox(x, y, width, height);
  }
  computeVisibleRangeBBox() {
    const {
      x,
      y,
      width,
      height,
      min,
      max
    } = this;
    const minX = x + width * min;
    const maxX = x + width * max;
    return new BBox(minX, y, maxX - minX, height);
  }
  updatePath() {
    const {
      path,
      x,
      y,
      width,
      height,
      min,
      max
    } = this;
    path.clear();
    const ax = this.align(x);
    const ay = this.align(y);
    const axw = ax + this.align(x, width);
    const ayh = ay + this.align(y, height);
    // Whole range.
    path.moveTo(ax, ay);
    path.lineTo(axw, ay);
    path.lineTo(axw, ayh);
    path.lineTo(ax, ayh);
    path.lineTo(ax, ay);
    const minX = this.align(x + width * min);
    const maxX = this.align(x + width * max);
    // Visible range.
    path.moveTo(minX, ay);
    path.lineTo(minX, ayh);
    path.lineTo(maxX, ayh);
    path.lineTo(maxX, ay);
    path.lineTo(minX, ay);
  }
}
RangeMask.className = 'RangeMask';
rangeMask_decorate([Validate(COLOR_STRING)], RangeMask.prototype, "_stroke", void 0);
rangeMask_decorate([Validate(NUMBER(0))], RangeMask.prototype, "_strokeWidth", void 0);
rangeMask_decorate([Validate(COLOR_STRING)], RangeMask.prototype, "_fill", void 0);
rangeMask_decorate([Validate(NUMBER(0, 1))], RangeMask.prototype, "_fillOpacity", void 0);
rangeMask_decorate([Validate(LINE_CAP)], RangeMask.prototype, "_lineCap", void 0);
rangeMask_decorate([Validate(NUMBER(0))], RangeMask.prototype, "_width", void 0);
rangeMask_decorate([Validate(NUMBER(0))], RangeMask.prototype, "_height", void 0);
rangeMask_decorate([Validate(NUMBER())], RangeMask.prototype, "_min", void 0);
rangeMask_decorate([Validate(NUMBER())], RangeMask.prototype, "_max", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/shapes/rangeSelector.mjs




class RangeSelector extends Group {
  constructor() {
    super({
      name: 'rangeSelectorGroup'
    });
    this.minHandle = new RangeHandle();
    this.maxHandle = new RangeHandle();
    this.mask = (() => {
      const {
        x,
        y,
        width,
        height,
        min,
        max
      } = RangeSelector.defaults;
      const mask = new RangeMask();
      mask.x = x;
      mask.y = y;
      mask.width = width;
      mask.height = height;
      mask.min = min;
      mask.max = max;
      const {
        minHandle,
        maxHandle
      } = this;
      minHandle.centerX = x;
      maxHandle.centerX = x + width;
      minHandle.centerY = maxHandle.centerY = y + height / 2;
      this.append([mask, minHandle, maxHandle]);
      mask.onRangeChange = () => {
        var _a;
        this.updateHandles();
        (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);
      };
      return mask;
    })();
    this._x = RangeSelector.defaults.x;
    this._y = RangeSelector.defaults.y;
    this._width = RangeSelector.defaults.width;
    this._height = RangeSelector.defaults.height;
    this._min = RangeSelector.defaults.min;
    this._max = RangeSelector.defaults.max;
    this.isContainerNode = true;
  }
  set x(value) {
    this.mask.x = value;
    this.updateHandles();
  }
  get x() {
    return this.mask.x;
  }
  set y(value) {
    this.mask.y = value;
    this.updateHandles();
  }
  get y() {
    return this.mask.y;
  }
  set width(value) {
    this.mask.width = value;
    this.updateHandles();
  }
  get width() {
    return this.mask.width;
  }
  set height(value) {
    this.mask.height = value;
    this.updateHandles();
  }
  get height() {
    return this.mask.height;
  }
  set min(value) {
    this.mask.min = value;
  }
  get min() {
    return this.mask.min;
  }
  set max(value) {
    this.mask.max = value;
  }
  get max() {
    return this.mask.max;
  }
  updateHandles() {
    const {
      minHandle,
      maxHandle,
      x,
      y,
      width,
      height,
      mask
    } = this;
    minHandle.centerX = x + width * mask.min;
    maxHandle.centerX = x + width * mask.max;
    minHandle.centerY = maxHandle.centerY = y + height / 2;
  }
  computeBBox() {
    return this.mask.computeBBox();
  }
  computeVisibleRangeBBox() {
    return this.mask.computeVisibleRangeBBox();
  }
  render(renderCtx) {
    const {
      ctx,
      forceRender,
      stats
    } = renderCtx;
    if (this.dirty === RedrawType.NONE && !forceRender) {
      if (stats) stats.nodesSkipped++;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    const {
      mask,
      minHandle,
      maxHandle
    } = this;
    [mask, minHandle, maxHandle].forEach(child => {
      if (child.visible && (forceRender || child.dirty > RedrawType.NONE)) {
        ctx.save();
        child.render(Object.assign(Object.assign({}, renderCtx), {
          ctx,
          forceRender
        }));
        ctx.restore();
      }
    });
    this.markClean({
      force: true
    });
    if (stats) stats.nodesRendered++;
  }
}
RangeSelector.className = 'Range';
RangeSelector.defaults = {
  x: 0,
  y: 0,
  width: 200,
  height: 30,
  min: 0,
  max: 1
};
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/navigator/navigatorMask.mjs
class NavigatorMask {
  constructor(rangeMask) {
    this.rm = rangeMask;
  }
  set fill(value) {
    this.rm.fill = value;
  }
  get fill() {
    return this.rm.fill;
  }
  set stroke(value) {
    this.rm.stroke = value;
  }
  get stroke() {
    return this.rm.stroke;
  }
  set strokeWidth(value) {
    this.rm.strokeWidth = value;
  }
  get strokeWidth() {
    return this.rm.strokeWidth;
  }
  set fillOpacity(value) {
    this.rm.fillOpacity = value;
  }
  get fillOpacity() {
    return this.rm.fillOpacity;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/navigator/navigatorHandle.mjs
class NavigatorHandle {
  constructor(rangeHandle) {
    this.rh = rangeHandle;
  }
  set fill(value) {
    this.rh.fill = value;
  }
  get fill() {
    return this.rh.fill;
  }
  set stroke(value) {
    this.rh.stroke = value;
  }
  get stroke() {
    return this.rh.stroke;
  }
  set strokeWidth(value) {
    this.rh.strokeWidth = value;
  }
  get strokeWidth() {
    return this.rh.strokeWidth;
  }
  set width(value) {
    this.rh.width = value;
  }
  get width() {
    return this.rh.width;
  }
  set height(value) {
    this.rh.height = value;
  }
  get height() {
    return this.rh.height;
  }
  set gripLineGap(value) {
    this.rh.gripLineGap = value;
  }
  get gripLineGap() {
    return this.rh.gripLineGap;
  }
  set gripLineLength(value) {
    this.rh.gripLineLength = value;
  }
  get gripLineLength() {
    return this.rh.gripLineLength;
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/navigator/navigator.mjs

var navigator_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class Navigator extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.rs = new RangeSelector();
    // Wrappers to allow option application to the scene graph nodes.
    this.mask = new NavigatorMask(this.rs.mask);
    this.minHandle = new NavigatorHandle(this.rs.minHandle);
    this.maxHandle = new NavigatorHandle(this.rs.maxHandle);
    this.minHandleDragging = false;
    this.maxHandleDragging = false;
    this.panHandleOffset = NaN;
    this._enabled = false;
    this.margin = 10;
    this._visible = true;
    this.rs.onRangeChange = () => this.ctx.zoomManager.updateZoom('navigator', {
      x: {
        min: this.rs.min,
        max: this.rs.max
      }
    });
    [ctx.interactionManager.addListener('drag-start', event => this.onDragStart(event)), ctx.interactionManager.addListener('drag', event => this.onDrag(event)), ctx.interactionManager.addListener('hover', event => this.onDrag(event)), ctx.interactionManager.addListener('drag-end', () => this.onDragStop())].forEach(s => this.destroyFns.push(() => ctx.interactionManager.removeListener(s)));
    [ctx.layoutService.addListener('before-series', event => this.layout(event)), ctx.layoutService.addListener('layout-complete', event => this.layoutComplete(event))].forEach(s => this.destroyFns.push(() => ctx.layoutService.removeListener(s)));
    ctx.scene.root.appendChild(this.rs);
    this.destroyFns.push(() => {
      var _a;
      return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.rs);
    });
    this.destroyFns.push(() => this.ctx.zoomManager.updateZoom('navigator'));
    this.updateGroupVisibility();
  }
  set enabled(value) {
    this._enabled = value;
    this.updateGroupVisibility();
  }
  get enabled() {
    return this._enabled;
  }
  set width(value) {
    this.rs.width = value;
  }
  get width() {
    return this.rs.width;
  }
  set height(value) {
    this.rs.height = value;
  }
  get height() {
    return this.rs.height;
  }
  set min(value) {
    this.rs.min = value;
  }
  get min() {
    return this.rs.min;
  }
  set max(value) {
    this.rs.max = value;
  }
  get max() {
    return this.rs.max;
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  updateGroupVisibility() {
    const visible = this.enabled && this.visible;
    this.rs.visible = visible;
    if (visible) {
      this.ctx.zoomManager.updateZoom('navigator', {
        x: {
          min: this.rs.min,
          max: this.rs.max
        }
      });
    } else {
      this.ctx.zoomManager.updateZoom('navigator');
    }
  }
  layout({
    shrinkRect
  }) {
    if (this.enabled) {
      const navigatorTotalHeight = this.rs.height + this.margin;
      shrinkRect.shrink(navigatorTotalHeight, 'bottom');
      this.rs.y = shrinkRect.y + shrinkRect.height + this.margin;
    }
    return {
      shrinkRect
    };
  }
  layoutComplete({
    series: {
      rect,
      visible
    }
  }) {
    if (this.enabled && visible) {
      this.rs.x = rect.x;
      this.rs.width = rect.width;
    }
    this.visible = visible;
  }
  onDragStart(offset) {
    if (!this.enabled) {
      return;
    }
    const {
      offsetX,
      offsetY
    } = offset;
    const {
      rs
    } = this;
    const {
      minHandle,
      maxHandle,
      x,
      width,
      min
    } = rs;
    const visibleRange = rs.computeVisibleRangeBBox();
    if (!(this.minHandleDragging || this.maxHandleDragging)) {
      if (minHandle.containsPoint(offsetX, offsetY)) {
        this.minHandleDragging = true;
      } else if (maxHandle.containsPoint(offsetX, offsetY)) {
        this.maxHandleDragging = true;
      } else if (visibleRange.containsPoint(offsetX, offsetY)) {
        this.panHandleOffset = (offsetX - x) / width - min;
      }
    }
  }
  onDrag(offset) {
    if (!this.enabled) {
      return;
    }
    const {
      rs,
      panHandleOffset
    } = this;
    const {
      x,
      y,
      width,
      height,
      minHandle,
      maxHandle
    } = rs;
    const {
      offsetX,
      offsetY
    } = offset;
    const minX = x + width * rs.min;
    const maxX = x + width * rs.max;
    const visibleRange = new BBox(minX, y, maxX - minX, height);
    const getRatio = () => Math.min(Math.max((offsetX - x) / width, 0), 1);
    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {
      this.ctx.cursorManager.updateCursor('navigator', 'ew-resize');
    } else if (visibleRange.containsPoint(offsetX, offsetY)) {
      this.ctx.cursorManager.updateCursor('navigator', 'grab');
    } else {
      this.ctx.cursorManager.updateCursor('navigator');
    }
    if (this.minHandleDragging) {
      rs.min = getRatio();
    } else if (this.maxHandleDragging) {
      rs.max = getRatio();
    } else if (!isNaN(panHandleOffset)) {
      const span = rs.max - rs.min;
      const min = Math.min(getRatio() - panHandleOffset, 1 - span);
      if (min <= rs.min) {
        // pan left
        rs.min = min;
        rs.max = rs.min + span;
      } else {
        // pan right
        rs.max = min + span;
        rs.min = rs.max - span;
      }
    }
  }
  onDragStop() {
    this.stopHandleDragging();
  }
  stopHandleDragging() {
    this.minHandleDragging = this.maxHandleDragging = false;
    this.panHandleOffset = NaN;
  }
}
navigator_decorate([Validate(BOOLEAN)], Navigator.prototype, "_enabled", void 0);
navigator_decorate([Validate(NUMBER(0))], Navigator.prototype, "margin", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/util/navigator-module.mjs


const CHART_NAVIGATOR_MODULE = {
  type: 'root',
  optionsKey: 'navigator',
  packageType: 'community',
  chartTypes: ['cartesian'],
  instanceConstructor: Navigator,
  themeTemplate: {
    navigator: {
      enabled: false,
      height: 30,
      mask: {
        fill: '#999999',
        stroke: '#999999',
        strokeWidth: 1,
        fillOpacity: 0.2
      },
      minHandle: {
        fill: '#f2f2f2',
        stroke: '#999999',
        strokeWidth: 1,
        width: 8,
        height: 16,
        gripLineGap: 2,
        gripLineLength: 8
      },
      maxHandle: {
        fill: '#f2f2f2',
        stroke: '#999999',
        strokeWidth: 1,
        width: 8,
        height: 16,
        gripLineGap: 2,
        gripLineLength: 8
      }
    }
  }
};
registerModule(CHART_NAVIGATOR_MODULE);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/background/background.mjs

var background_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class Background extends BaseModuleInstance {
  constructor(ctx) {
    var _a;
    super();
    this.onLayoutComplete = e => {
      const {
        width,
        height
      } = e.chart;
      this.rectNode.width = width;
      this.rectNode.height = height;
    };
    this.node = new Group({
      name: 'background'
    });
    this.node.zIndex = Layers.SERIES_BACKGROUND_ZINDEX;
    this.rectNode = new Rect();
    this.node.appendChild(this.rectNode);
    this.fill = 'white';
    this.visible = true;
    (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.node);
    this.destroyFns.push(() => {
      var _a;
      return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.node);
    });
    const layoutHandle = ctx.layoutService.addListener('layout-complete', this.onLayoutComplete);
    this.destroyFns.push(() => ctx.layoutService.removeListener(layoutHandle));
  }
}
background_decorate([Validate(BOOLEAN), ProxyPropertyOnWrite('node', 'visible')], Background.prototype, "visible", void 0);
background_decorate([Validate(OPT_COLOR_STRING), ProxyPropertyOnWrite('rectNode', 'fill')], Background.prototype, "fill", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/background/backgroundModule.mjs


const CHART_BACKGROUND_MODULE = {
  type: 'root',
  optionsKey: 'background',
  packageType: 'community',
  chartTypes: ['cartesian', 'polar', 'hierarchy'],
  instanceConstructor: Background
};
registerModule(CHART_BACKGROUND_MODULE);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/module-support.mjs




























;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/factory/setupModules.mjs






function setupModules() {
  for (const m of REGISTERED_MODULES) {
    if (m.optionConstructors != null) {
      Object.assign(JSON_APPLY_PLUGINS.constructors, m.optionConstructors);
    }
    if (m.type === 'root') {
      if (m.themeTemplate) {
        for (const chartType of m.chartTypes) {
          registerChartDefaults(chartType, m.themeTemplate);
        }
      }
    }
    if (m.type === 'series') {
      if (m.chartTypes.length > 1) throw new Error('AG Charts - Module definition error: ' + m.identifier);
      registerSeries(m.identifier, m.chartTypes[0], m.instanceConstructor, m.seriesDefaults, m.themeTemplate);
    }
    if (m.type === 'axis') {
      if (m.themeTemplate) {
        for (const axisType of m.axisTypes) {
          registerAxisThemeTemplate(axisType, m.themeTemplate);
        }
      }
    }
    if (m.type === 'legend') {
      registerLegend(m.identifier, m.instanceConstructor);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/chart/agChartV2.mjs

var agChartV2_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
















// Deliberately imported via `module-support` so that internal module registration happens.


function chartType(options) {
  if (isAgCartesianChartOptions(options)) {
    return 'cartesian';
  } else if (isAgPolarChartOptions(options)) {
    return 'polar';
  } else if (isAgHierarchyChartOptions(options)) {
    return 'hierarchy';
  }
  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);
}
/**
 * Factory for creating and updating instances of AgChartInstance.
 *
 * @docsInterface
 */
class AgChart {
  /**
   * Create a new `AgChartInstance` based upon the given configuration options.
   */
  static create(options) {
    return AgChartInternal.createOrUpdate(options);
  }
  /**
   * Update an existing `AgChartInstance`. Options provided should be complete and not
   * partial.
   * <br/>
   * <br/>
   * **NOTE**: As each call could trigger a chart redraw, multiple calls to update options in
   * quick succession could result in undesirable flickering, so callers should batch up and/or
   * debounce changes to avoid unintended partial update renderings.
   */
  static update(chart, options) {
    if (!AgChartInstanceProxy.isInstance(chart)) {
      throw new Error('AG Charts - invalid chart reference passed');
    }
    AgChartInternal.createOrUpdate(options, chart);
  }
  /**
   * Update an existing `AgChartInstance` by applying a partial set of option changes.
   * <br/>
   * <br/>
   * **NOTE**: As each call could trigger a chart redraw, each individual delta options update
   * should leave the chart in a valid options state. Also, multiple calls to update options in
   * quick succession could result in undesirable flickering, so callers should batch up and/or
   * debounce changes to avoid unintended partial update renderings.
   */
  static updateDelta(chart, deltaOptions) {
    if (!AgChartInstanceProxy.isInstance(chart)) {
      throw new Error('AG Charts - invalid chart reference passed');
    }
    return AgChartInternal.updateUserDelta(chart, deltaOptions);
  }
  /**
   * Starts a browser-based image download for the given `AgChartInstance`.
   */
  static download(chart, options) {
    if (!(chart instanceof AgChartInstanceProxy)) {
      throw new Error('AG Charts - invalid chart reference passed');
    }
    return AgChartInternal.download(chart, options);
  }
  /**
   * Returns a base64-encoded image data URL for the given `AgChartInstance`.
   */
  static getImageDataURL(chart, options) {
    if (!(chart instanceof AgChartInstanceProxy)) {
      throw new Error('AG Charts - invalid chart reference passed');
    }
    return AgChartInternal.getImageDataURL(chart, options);
  }
}
/**
 * Proxy class, to allow library users to keep a stable reference to their chart, even if we need
 * to switch concrete class (e.g. when switching between CartesianChart vs. PolarChart).
 */
class AgChartInstanceProxy {
  constructor(chart) {
    this.chart = chart;
  }
  static isInstance(x) {
    var _a, _b;
    if (x instanceof AgChartInstanceProxy) {
      // Simple case.
      return true;
    }
    if (((_a = x.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'AgChartInstanceProxy' && x.chart != null) {
      // instanceof can fail if mixing bundles (e.g. grid all-modules vs. standalone).
      return true;
    }
    const signatureProps = Object.keys((_b = x.constructor) === null || _b === void 0 ? void 0 : _b.prototype);
    const heuristicTypeCheck = Object.keys(AgChartInstanceProxy.prototype).every(prop => signatureProps.includes(prop));
    if (heuristicTypeCheck && x.chart != null) {
      // minimised code case - the constructor name is mangled but prototype names are not :P
      return true;
    }
    return false;
  }
  getOptions() {
    return this.chart.getOptions();
  }
  destroy() {
    this.chart.destroy();
  }
}
class AgChartInternal {
  static initialiseModules() {
    if (AgChartInternal.initialised) return;
    setupModules();
    AgChartInternal.initialised = true;
  }
  static createOrUpdate(userOptions, proxy) {
    AgChartInternal.initialiseModules();
    debug('>>> createOrUpdate() user options', userOptions);
    const mixinOpts = {};
    if (AgChartInternal.DEBUG() === true) {
      mixinOpts['debug'] = true;
    }
    const {
      overrideDevicePixelRatio
    } = userOptions;
    delete userOptions['overrideDevicePixelRatio'];
    const processedOptions = prepareOptions(userOptions, mixinOpts);
    let chart = proxy === null || proxy === void 0 ? void 0 : proxy.chart;
    if (chart == null || chartType(userOptions) !== chartType(chart.processedOptions)) {
      chart = AgChartInternal.createChartInstance(processedOptions, overrideDevicePixelRatio, chart);
    }
    if (proxy == null) {
      proxy = new AgChartInstanceProxy(chart);
    } else {
      proxy.chart = chart;
    }
    const chartToUpdate = chart;
    chartToUpdate.queuedUserOptions.push(userOptions);
    const dequeue = () => {
      // If there are a lot of update calls, `requestFactoryUpdate()` may skip callbacks,
      // so we need to remove all queue items up to the last successfully applied item.
      const queuedOptionsIdx = chartToUpdate.queuedUserOptions.indexOf(userOptions);
      chartToUpdate.queuedUserOptions.splice(0, queuedOptionsIdx);
    };
    chartToUpdate.requestFactoryUpdate(() => agChartV2_awaiter(this, void 0, void 0, function* () {
      // Chart destroyed, skip processing.
      if (chartToUpdate.destroyed) return;
      const deltaOptions = jsonDiff(chartToUpdate.processedOptions, processedOptions);
      if (deltaOptions == null) {
        dequeue();
        return;
      }
      yield AgChartInternal.updateDelta(chartToUpdate, deltaOptions, userOptions);
      dequeue();
    }));
    return proxy;
  }
  static updateUserDelta(proxy, deltaOptions) {
    var _a;
    const {
      chart,
      chart: {
        queuedUserOptions
      }
    } = proxy;
    const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : chart.userOptions;
    const userOptions = jsonMerge([lastUpdateOptions, deltaOptions]);
    debug('>>> updateUserDelta() user delta', deltaOptions);
    debug('base options', lastUpdateOptions);
    AgChartInternal.createOrUpdate(userOptions, proxy);
  }
  /**
   * Returns the content of the current canvas as an image.
   * @param opts The download options including `width` and `height` of the image as well as `fileName` and `fileFormat`.
   */
  static download(proxy, opts) {
    const asyncDownload = () => agChartV2_awaiter(this, void 0, void 0, function* () {
      const maybeClone = yield AgChartInternal.prepareResizedChart(proxy, opts);
      const {
        chart
      } = maybeClone;
      chart.scene.download(opts === null || opts === void 0 ? void 0 : opts.fileName, opts === null || opts === void 0 ? void 0 : opts.fileFormat);
      if (maybeClone !== proxy) {
        maybeClone.destroy();
      }
    });
    asyncDownload().catch(e => Logger.errorOnce(e));
  }
  static getImageDataURL(proxy, opts) {
    return agChartV2_awaiter(this, void 0, void 0, function* () {
      const maybeClone = yield AgChartInternal.prepareResizedChart(proxy, opts);
      const {
        chart
      } = maybeClone;
      const result = chart.scene.canvas.getDataURL(opts === null || opts === void 0 ? void 0 : opts.fileFormat);
      if (maybeClone !== proxy) {
        maybeClone.destroy();
      }
      return result;
    });
  }
  static prepareResizedChart(proxy, opts) {
    return agChartV2_awaiter(this, void 0, void 0, function* () {
      const {
        chart
      } = proxy;
      let {
        width,
        height
      } = opts !== null && opts !== void 0 ? opts : {};
      const currentWidth = chart.width;
      const currentHeight = chart.height;
      const unchanged = width === undefined && height === undefined || chart.scene.canvas.pixelRatio === 1 && currentWidth === width && currentHeight === height;
      if (unchanged) {
        return proxy;
      }
      width = width !== null && width !== void 0 ? width : currentWidth;
      height = height !== null && height !== void 0 ? height : currentHeight;
      const options = Object.assign(Object.assign({}, chart.userOptions), {
        container: document.createElement('div'),
        width,
        height,
        autoSize: false,
        overrideDevicePixelRatio: 1
      });
      const clonedChart = AgChartInternal.createOrUpdate(options);
      yield clonedChart.chart.waitForUpdate();
      return clonedChart;
    });
  }
  static createChartInstance(options, overrideDevicePixelRatio, oldChart) {
    const transferableResource = oldChart === null || oldChart === void 0 ? void 0 : oldChart.destroy({
      keepTransferableResources: true
    });
    if (isAgCartesianChartOptions(options)) {
      return new CartesianChart(document, overrideDevicePixelRatio, transferableResource);
    } else if (isAgHierarchyChartOptions(options)) {
      return new HierarchyChart(document, overrideDevicePixelRatio, transferableResource);
    } else if (isAgPolarChartOptions(options)) {
      return new PolarChart(document, overrideDevicePixelRatio, transferableResource);
    }
    throw new Error(`AG Charts - couldn't apply configuration, check type of options: ${options['type']}`);
  }
  static updateDelta(chart, processedOptions, userOptions) {
    var _a;
    return agChartV2_awaiter(this, void 0, void 0, function* () {
      if (processedOptions.type == null) {
        processedOptions = Object.assign(Object.assign({}, processedOptions), {
          type: (_a = chart.processedOptions.type) !== null && _a !== void 0 ? _a : optionsType(processedOptions)
        });
      }
      yield chart.awaitUpdateCompletion();
      if (chart.destroyed) return;
      debug('applying delta', processedOptions);
      applyChartOptions(chart, processedOptions, userOptions);
    });
  }
}
AgChartInternal.DEBUG = () => {
  var _a;
  return (_a = windowValue('agChartsDebug')) !== null && _a !== void 0 ? _a : false;
};
AgChartInternal.initialised = false;
function debug(message, ...optionalParams) {
  if ([true, 'opts'].includes(AgChartInternal.DEBUG())) {
    Logger.debug(message, ...optionalParams);
  }
}
function applyChartOptions(chart, processedOptions, userOptions) {
  var _a, _b, _c, _d;
  const completeOptions = jsonMerge([(_a = chart.processedOptions) !== null && _a !== void 0 ? _a : {}, processedOptions], noDataCloneMergeOptions);
  const modulesChanged = applyModules(chart, completeOptions);
  const skip = ['type', 'data', 'series', 'listeners', 'theme', 'legend'];
  if (isAgCartesianChartOptions(processedOptions)) {
    // Append axes to defaults.
    skip.push('axes');
  } else if (isAgPolarChartOptions(processedOptions) || isAgHierarchyChartOptions(processedOptions)) {
    // Use defaults.
  } else {
    throw new Error(`AG Charts - couldn't apply configuration, check type of options and chart: ${processedOptions['type']}`);
  }
  // Needs to be done before applying the series to detect if a seriesNode[Double]Click listener has been added
  if (processedOptions.listeners) {
    registerListeners(chart, processedOptions.listeners);
  }
  applyOptionValues(chart, processedOptions, {
    skip
  });
  let forceNodeDataRefresh = false;
  if (processedOptions.series && processedOptions.series.length > 0) {
    applySeries(chart, processedOptions);
    forceNodeDataRefresh = true;
  }
  if (isAgCartesianChartOptions(processedOptions) && processedOptions.axes) {
    const axesPresent = applyAxes(chart, processedOptions);
    if (axesPresent) {
      forceNodeDataRefresh = true;
    }
  }
  applyLegend(chart, processedOptions);
  const seriesOpts = processedOptions.series;
  const seriesDataUpdate = !!processedOptions.data || (seriesOpts === null || seriesOpts === void 0 ? void 0 : seriesOpts.some(s => s.data != null));
  const otherRefreshUpdate = (_c = (_b = processedOptions.legend) !== null && _b !== void 0 ? _b : processedOptions.title) !== null && _c !== void 0 ? _c : processedOptions.subtitle;
  forceNodeDataRefresh = forceNodeDataRefresh || seriesDataUpdate || !!otherRefreshUpdate;
  if (processedOptions.data) {
    chart.data = processedOptions.data;
  }
  if (processedOptions.listeners) {
    chart.updateAllSeriesListeners();
  }
  chart.processedOptions = completeOptions;
  chart.userOptions = jsonMerge([(_d = chart.userOptions) !== null && _d !== void 0 ? _d : {}, userOptions], noDataCloneMergeOptions);
  const majorChange = forceNodeDataRefresh || modulesChanged;
  const updateType = majorChange ? ChartUpdateType.PROCESS_DATA : ChartUpdateType.PERFORM_LAYOUT;
  debug('chart update type', {
    updateType: ChartUpdateType[updateType]
  });
  chart.update(updateType, {
    forceNodeDataRefresh
  });
}
function applyModules(chart, options) {
  const matchingChartType = module => {
    return chart instanceof CartesianChart && module.chartTypes.includes('cartesian') || chart instanceof PolarChart && module.chartTypes.includes('polar') || chart instanceof HierarchyChart && module.chartTypes.includes('hierarchy');
  };
  let modulesChanged = false;
  const rootModules = REGISTERED_MODULES.filter(m => m.type === 'root');
  for (const next of rootModules) {
    const shouldBeEnabled = matchingChartType(next) && options[next.optionsKey] != null;
    const isEnabled = chart.isModuleEnabled(next);
    if (shouldBeEnabled === isEnabled) continue;
    modulesChanged = true;
    if (shouldBeEnabled) {
      chart.addModule(next);
    } else {
      chart.removeModule(next);
    }
  }
  return modulesChanged;
}
function applySeries(chart, options) {
  const optSeries = options.series;
  if (!optSeries) {
    return;
  }
  const matchingTypes = chart.series.length === optSeries.length && chart.series.every((s, i) => {
    var _a;
    return s.type === ((_a = optSeries[i]) === null || _a === void 0 ? void 0 : _a.type);
  });
  // Try to optimise series updates if series count and types didn't change.
  if (matchingTypes) {
    chart.series.forEach((s, i) => {
      var _a, _b, _c, _d;
      const previousOpts = (_c = (_b = (_a = chart.processedOptions) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {};
      const seriesDiff = jsonDiff(previousOpts, (_d = optSeries[i]) !== null && _d !== void 0 ? _d : {});
      if (!seriesDiff) {
        return;
      }
      debug(`applying series diff idx ${i}`, seriesDiff);
      applySeriesValues(s, seriesDiff, {
        path: `series[${i}]`,
        index: i
      });
      s.markNodeDataDirty();
    });
    return;
  }
  chart.series = createSeries(chart, optSeries);
}
function applyAxes(chart, options) {
  const optAxes = options.axes;
  if (!optAxes) {
    return false;
  }
  const matchingTypes = chart.axes.length === optAxes.length && chart.axes.every((a, i) => a.type === optAxes[i].type);
  // Try to optimise series updates if series count and types didn't change.
  if (matchingTypes) {
    const oldOpts = chart.processedOptions;
    if (isAgCartesianChartOptions(oldOpts)) {
      chart.axes.forEach((a, i) => {
        var _a, _b;
        const previousOpts = (_b = (_a = oldOpts.axes) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : {};
        const axisDiff = jsonDiff(previousOpts, optAxes[i]);
        debug(`applying axis diff idx ${i}`, axisDiff);
        const path = `axes[${i}]`;
        const skip = ['axes[].type'];
        applyOptionValues(a, axisDiff, {
          path,
          skip
        });
      });
      return true;
    }
  }
  chart.axes = createAxis(chart, optAxes);
  return true;
}
function applyLegend(chart, options) {
  const skip = ['listeners'];
  chart.setLegendInit(legend => {
    var _a, _b, _c;
    applyOptionValues(legend, (_a = options.legend) !== null && _a !== void 0 ? _a : {}, {
      skip
    });
    if ((_b = options.legend) === null || _b === void 0 ? void 0 : _b.listeners) {
      Object.assign(chart.legend.listeners, (_c = options.legend.listeners) !== null && _c !== void 0 ? _c : {});
    }
  });
}
function createSeries(chart, options) {
  const series = [];
  const moduleContext = chart.getModuleContext();
  let index = 0;
  for (const seriesOptions of options !== null && options !== void 0 ? options : []) {
    const path = `series[${index++}]`;
    const seriesInstance = getSeries(seriesOptions.type, moduleContext);
    applySeriesValues(seriesInstance, seriesOptions, {
      path,
      index
    });
    series.push(seriesInstance);
  }
  return series;
}
function createAxis(chart, options) {
  const axes = [];
  const skip = ['axes[].type'];
  const moduleContext = chart.getModuleContext();
  let index = 0;
  for (const axisOptions of options !== null && options !== void 0 ? options : []) {
    let axis;
    switch (axisOptions.type) {
      case 'number':
        axis = new NumberAxis(moduleContext);
        break;
      case LogAxis.type:
        axis = new LogAxis(moduleContext);
        break;
      case CategoryAxis.type:
        axis = new CategoryAxis(moduleContext);
        break;
      case GroupedCategoryAxis.type:
        axis = new GroupedCategoryAxis(moduleContext);
        break;
      case TimeAxis.type:
        axis = new TimeAxis(moduleContext);
        break;
      default:
        throw new Error('AG Charts - unknown axis type: ' + axisOptions['type']);
    }
    const path = `axes[${index++}]`;
    applyAxisModules(axis, axisOptions);
    applyOptionValues(axis, axisOptions, {
      path,
      skip
    });
    axes.push(axis);
  }
  return axes;
}
function applyAxisModules(axis, options) {
  let modulesChanged = false;
  const rootModules = REGISTERED_MODULES.filter(m => m.type === 'axis');
  for (const next of rootModules) {
    const shouldBeEnabled = options[next.optionsKey] != null;
    const isEnabled = axis.isModuleEnabled(next);
    if (shouldBeEnabled === isEnabled) continue;
    modulesChanged = true;
    if (shouldBeEnabled) {
      axis.addModule(next);
    } else {
      axis.removeModule(next);
    }
  }
  return modulesChanged;
}
function registerListeners(source, listeners) {
  source.clearEventListeners();
  for (const property in listeners) {
    const listener = listeners[property];
    if (typeof listener !== 'function') continue;
    source.addEventListener(property, listener);
  }
}
function applyOptionValues(target, options, {
  skip,
  path
} = {}) {
  const applyOpts = Object.assign(Object.assign(Object.assign({}, getJsonApplyOptions()), {
    skip
  }), path ? {
    path
  } : {});
  return jsonApply(target, options, applyOpts);
}
function applySeriesValues(target, options, {
  path,
  index
} = {}) {
  var _a;
  const skip = ['series[].listeners'];
  const jsonApplyOptions = getJsonApplyOptions();
  const ctrs = (_a = jsonApplyOptions.constructors) !== null && _a !== void 0 ? _a : {};
  const seriesTypeOverrides = {
    constructors: Object.assign(Object.assign({}, ctrs), {
      title: target.type === 'pie' ? PieTitle : ctrs['title']
    })
  };
  const applyOpts = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, jsonApplyOptions), seriesTypeOverrides), {
    skip: ['series[].type', ...(skip !== null && skip !== void 0 ? skip : [])]
  }), path ? {
    path
  } : {}), {
    idx: index !== null && index !== void 0 ? index : -1
  });
  const result = jsonApply(target, options, applyOpts);
  const listeners = options === null || options === void 0 ? void 0 : options.listeners;
  if (listeners != null) {
    registerListeners(target, listeners);
  }
  return result;
}
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/scene/image.mjs
var image_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class Image extends Node {
  constructor(sourceImage) {
    super();
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.opacity = 1;
    this.sourceImage = sourceImage;
  }
  render(renderCtx) {
    const {
      ctx,
      forceRender,
      stats
    } = renderCtx;
    if (this.dirty === RedrawType.NONE && !forceRender) {
      if (stats) stats.nodesSkipped++;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    const image = this.sourceImage;
    ctx.globalAlpha = this.opacity;
    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);
    super.render(renderCtx);
  }
}
image_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Image.prototype, "x", void 0);
image_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Image.prototype, "y", void 0);
image_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Image.prototype, "width", void 0);
image_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Image.prototype, "height", void 0);
image_decorate([SceneChangeDetection({
  redraw: RedrawType.MAJOR
})], Image.prototype, "opacity", void 0);
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/integrated-charts-scene.mjs




























;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/integrated-charts-theme.mjs



const integrated_charts_theme_themes = Object.entries(themes).reduce((obj, [name, factory]) => {
  obj[name] = factory();
  return obj;
}, {});
;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/sparklines-scale.mjs





;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/sparklines-util.mjs














;// CONCATENATED MODULE: ./node_modules/ag-charts-community/dist/esm/es6/main.mjs
// Documented APIs.





// Undocumented APIs used by examples.












/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm-bundler.js + 4 modules
var vue_esm_bundler = __webpack_require__(9003);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/agCharts.vue?vue&type=template&id=28ce898c

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ag_charts_vue = (0,vue_esm_bundler/* resolveComponent */.up)("ag-charts-vue");
  return (0,vue_esm_bundler/* openBlock */.wg)(), (0,vue_esm_bundler/* createBlock */.j4)(_component_ag_charts_vue, {
    options: _ctx.options
  }, null, 8, ["options"]);
}
;// CONCATENATED MODULE: ./src/components/agCharts.vue?vue&type=template&id=28ce898c

// EXTERNAL MODULE: ./node_modules/ag-charts-vue3/main.js
var main = __webpack_require__(7534);
// EXTERNAL MODULE: ./node_modules/ag-charts-community/dist/esm/es6/main.mjs + 187 modules
var es6_main = __webpack_require__(6385);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/agCharts.vue?vue&type=script&lang=js


/* harmony default export */ var agChartsvue_type_script_lang_js = ({
  name: "gepChartCustomerHistoricalComparison",
  components: {
    "ag-charts-vue": main.AgChartsVue
  },
  data: function () {
    return {
      options: null
    };
  },
  created() {
    this.options = {
      autoSize: true,
      title: {
        text: 'Mean Sea Level (mm)'
      },
      data: [{
        time: 1998,
        mm: -18.044704295762713
      }, {
        time: 1998.05,
        mm: -8.01167395696654
      }, {
        time: 1998.1,
        mm: -11.723956003017026
      }, {
        time: 1998.1499999999999,
        mm: -13.950128097323676
      }, {
        time: 1998.1999999999998,
        mm: -18.568726152487848
      }, {
        time: 1998.2499999999998,
        mm: -16.9826460946247
      }, {
        time: 1998.2999999999997,
        mm: -14.237773696675355
      }, {
        time: 1998.3499999999997,
        mm: -10.498762915259096
      }, {
        time: 1998.3999999999996,
        mm: -10.5813146712348
      }, {
        time: 1998.4499999999996,
        mm: -11.80256206064789
      }, {
        time: 1998.4999999999995,
        mm: -5.9298308802357305
      }, {
        time: 1998.5499999999995,
        mm: -4.485394405421387
      }, {
        time: 1998.5999999999995,
        mm: -9.085616601658025
      }, {
        time: 1998.6499999999994,
        mm: -13.53351803257168
      }, {
        time: 1998.6999999999994,
        mm: -10.638713820906212
      }, {
        time: 1998.7499999999993,
        mm: -11.925245427689404
      }, {
        time: 1998.7999999999993,
        mm: -15.204691835196051
      }, {
        time: 1998.8499999999992,
        mm: -9.975145257530706
      }, {
        time: 1998.8999999999992,
        mm: -9.111788395881328
      }, {
        time: 1998.9499999999991,
        mm: -12.626260692955546
      }, {
        time: 1998.999999999999,
        mm: -6.470631442069884
      }, {
        time: 1999.049999999999,
        mm: -6.325711974577979
      }, {
        time: 1999.099999999999,
        mm: -6.948262274091785
      }, {
        time: 1999.149999999999,
        mm: -6.782176474476461
      }, {
        time: 1999.199999999999,
        mm: -9.58441476298171
      }, {
        time: 1999.2499999999989,
        mm: -2.955987327262733
      }, {
        time: 1999.2999999999988,
        mm: -8.71197033065971
      }, {
        time: 1999.3499999999988,
        mm: -7.3376252957588335
      }, {
        time: 1999.3999999999987,
        mm: -10.907341193561223
      }, {
        time: 1999.4499999999987,
        mm: -8.68863688090925
      }, {
        time: 1999.4999999999986,
        mm: -9.913720798033156
      }, {
        time: 1999.5499999999986,
        mm: -7.56520952284904
      }, {
        time: 1999.5999999999985,
        mm: -12.948614376814833
      }, {
        time: 1999.6499999999985,
        mm: -5.772033101863784
      }, {
        time: 1999.6999999999985,
        mm: -11.822446339666257
      }, {
        time: 1999.7499999999984,
        mm: -11.322700292901029
      }, {
        time: 1999.7999999999984,
        mm: -3.740090984751749
      }, {
        time: 1999.8499999999983,
        mm: -5.334569669010907
      }, {
        time: 1999.8999999999983,
        mm: -3.7203793477638065
      }, {
        time: 1999.9499999999982,
        mm: -8.511258109605286
      }, {
        time: 1999.9999999999982,
        mm: -10.173334290959453
      }, {
        time: 2000.0499999999981,
        mm: -12.32193293376777
      }, {
        time: 2000.099999999998,
        mm: 2.9198954882239665
      }, {
        time: 2000.149999999998,
        mm: -11.200621036166854
      }, {
        time: 2000.199999999998,
        mm: -1.5902175866924981
      }, {
        time: 2000.249999999998,
        mm: -0.2974904537808367
      }, {
        time: 2000.299999999998,
        mm: -3.4287219220995215
      }, {
        time: 2000.3499999999979,
        mm: -8.893091660102144
      }, {
        time: 2000.3999999999978,
        mm: -8.569403031523603
      }, {
        time: 2000.4499999999978,
        mm: -4.863271685844555
      }, {
        time: 2000.4999999999977,
        mm: -1.3106025098230472
      }, {
        time: 2000.5499999999977,
        mm: -3.378986244406452
      }, {
        time: 2000.5999999999976,
        mm: 0.6543209346728922
      }, {
        time: 2000.6499999999976,
        mm: -0.373219906579493
      }, {
        time: 2000.6999999999975,
        mm: 1.6636607747541667
      }, {
        time: 2000.7499999999975,
        mm: -0.3162884931932961
      }, {
        time: 2000.7999999999975,
        mm: 0.1663366792883112
      }, {
        time: 2000.8499999999974,
        mm: -0.17863332528387232
      }, {
        time: 2000.8999999999974,
        mm: -0.8227918713865856
      }, {
        time: 2000.9499999999973,
        mm: -0.6268209545787142
      }, {
        time: 2000.9999999999973,
        mm: -9.608531973024718
      }, {
        time: 2001.0499999999972,
        mm: -9.724677049240123
      }, {
        time: 2001.0999999999972,
        mm: 2.7475615038855583
      }, {
        time: 2001.1499999999971,
        mm: 3.5533567222360567
      }, {
        time: 2001.199999999997,
        mm: 4.249449591877086
      }, {
        time: 2001.249999999997,
        mm: -3.141816970310899
      }, {
        time: 2001.299999999997,
        mm: 0.26228922897072504
      }, {
        time: 2001.349999999997,
        mm: 2.7604234020367837
      }, {
        time: 2001.399999999997,
        mm: 2.699061335265049
      }, {
        time: 2001.4499999999969,
        mm: 1.8655180286262993
      }, {
        time: 2001.4999999999968,
        mm: 2.592347457795303
      }, {
        time: 2001.5499999999968,
        mm: 2.5268304782368674
      }, {
        time: 2001.5999999999967,
        mm: 4.740028528794215
      }, {
        time: 2001.6499999999967,
        mm: -7.810644184211567
      }, {
        time: 2001.6999999999966,
        mm: -1.3171470822362936
      }, {
        time: 2001.7499999999966,
        mm: 5.399431992332412
      }, {
        time: 2001.7999999999965,
        mm: -0.18041552671703087
      }, {
        time: 2001.8499999999965,
        mm: 2.035854537274691
      }, {
        time: 2001.8999999999965,
        mm: -0.027346254445385743
      }, {
        time: 2001.9499999999964,
        mm: -0.48574269299339257
      }, {
        time: 2001.9999999999964,
        mm: 2.9567025228818995
      }, {
        time: 2002.0499999999963,
        mm: 2.3152190704508375
      }, {
        time: 2002.0999999999963,
        mm: 1.7991980102523986
      }, {
        time: 2002.1499999999962,
        mm: 2.8799665606424787
      }, {
        time: 2002.1999999999962,
        mm: 6.366042262780211
      }, {
        time: 2002.2499999999961,
        mm: 8.718852610752014
      }, {
        time: 2002.299999999996,
        mm: 1.7025186486214263
      }, {
        time: 2002.349999999996,
        mm: 4.373973101767856
      }, {
        time: 2002.399999999996,
        mm: 0.9297333294445598
      }, {
        time: 2002.449999999996,
        mm: 6.199667197467772
      }, {
        time: 2002.499999999996,
        mm: -2.398646421871616
      }, {
        time: 2002.5499999999959,
        mm: -0.7268568139048419
      }, {
        time: 2002.5999999999958,
        mm: -0.7190093361980727
      }, {
        time: 2002.6499999999958,
        mm: 1.8554026111389144
      }, {
        time: 2002.6999999999957,
        mm: 3.9914498836091266
      }, {
        time: 2002.7499999999957,
        mm: 15.440503872842658
      }, {
        time: 2002.7999999999956,
        mm: 1.5880035716282626
      }, {
        time: 2002.8499999999956,
        mm: 9.980445660566572
      }, {
        time: 2002.8999999999955,
        mm: 4.651045119557397
      }, {
        time: 2002.9499999999955,
        mm: 3.3297163572320465
      }, {
        time: 2002.9999999999955,
        mm: 4.415742900089591
      }, {
        time: 2003.0499999999954,
        mm: 9.708295213794061
      }, {
        time: 2003.0999999999954,
        mm: 5.965017245184134
      }, {
        time: 2003.1499999999953,
        mm: 4.771305751998193
      }, {
        time: 2003.1999999999953,
        mm: 7.12125666676957
      }, {
        time: 2003.2499999999952,
        mm: 1.6841222053459948
      }, {
        time: 2003.2999999999952,
        mm: 5.427046091147847
      }, {
        time: 2003.3499999999951,
        mm: 4.260098331938561
      }, {
        time: 2003.399999999995,
        mm: 12.2087985658812
      }, {
        time: 2003.449999999995,
        mm: 4.292494785513127
      }, {
        time: 2003.499999999995,
        mm: 7.928077799491142
      }, {
        time: 2003.549999999995,
        mm: 14.726912160552136
      }, {
        time: 2003.599999999995,
        mm: 12.959736611753732
      }, {
        time: 2003.6499999999949,
        mm: 11.375494840011726
      }, {
        time: 2003.6999999999948,
        mm: 7.855139702702456
      }, {
        time: 2003.7499999999948,
        mm: 14.746993640258415
      }, {
        time: 2003.7999999999947,
        mm: 14.90504068108065
      }, {
        time: 2003.8499999999947,
        mm: 12.980904068233901
      }, {
        time: 2003.8999999999946,
        mm: 6.050365267483823
      }, {
        time: 2003.9499999999946,
        mm: 12.122837726119416
      }, {
        time: 2003.9999999999945,
        mm: 9.243529978656351
      }, {
        time: 2004.0499999999945,
        mm: 11.60677461614598
      }, {
        time: 2004.0999999999945,
        mm: 10.898001680018043
      }, {
        time: 2004.1499999999944,
        mm: 15.410302318361857
      }, {
        time: 2004.1999999999944,
        mm: 8.141969510915079
      }, {
        time: 2004.2499999999943,
        mm: 13.882930449128766
      }, {
        time: 2004.2999999999943,
        mm: 12.561292714117089
      }, {
        time: 2004.3499999999942,
        mm: 10.897184548985969
      }, {
        time: 2004.3999999999942,
        mm: 18.87841771419057
      }, {
        time: 2004.4499999999941,
        mm: 15.981372488627665
      }, {
        time: 2004.499999999994,
        mm: 18.567279636952097
      }, {
        time: 2004.549999999994,
        mm: 17.10185082769863
      }, {
        time: 2004.599999999994,
        mm: 16.65247308280955
      }, {
        time: 2004.649999999994,
        mm: 13.028204447681336
      }, {
        time: 2004.699999999994,
        mm: 20.431174406188045
      }, {
        time: 2004.7499999999939,
        mm: 8.890017191913248
      }, {
        time: 2004.7999999999938,
        mm: 17.99150402975073
      }, {
        time: 2004.8499999999938,
        mm: 19.5641052549399
      }, {
        time: 2004.8999999999937,
        mm: 17.64155069725755
      }, {
        time: 2004.9499999999937,
        mm: 12.615646074511668
      }, {
        time: 2004.9999999999936,
        mm: 18.551882563736555
      }, {
        time: 2005.0499999999936,
        mm: 17.151807608204187
      }, {
        time: 2005.0999999999935,
        mm: 22.212036738549756
      }, {
        time: 2005.1499999999935,
        mm: 9.4395400078233
      }, {
        time: 2005.1999999999935,
        mm: 24.335806157416066
      }, {
        time: 2005.2499999999934,
        mm: 10.713520135045385
      }, {
        time: 2005.2999999999934,
        mm: 14.67159085937137
      }, {
        time: 2005.3499999999933,
        mm: 21.475871387776394
      }, {
        time: 2005.3999999999933,
        mm: 12.62581684210625
      }, {
        time: 2005.4499999999932,
        mm: 19.969362382031832
      }, {
        time: 2005.4999999999932,
        mm: 20.39135541077421
      }, {
        time: 2005.5499999999931,
        mm: 28.041637444740815
      }, {
        time: 2005.599999999993,
        mm: 18.013067221562903
      }, {
        time: 2005.649999999993,
        mm: 21.53979641696595
      }, {
        time: 2005.699999999993,
        mm: 24.43129032832503
      }, {
        time: 2005.749999999993,
        mm: 26.72716950873879
      }, {
        time: 2005.799999999993,
        mm: 22.53662533319716
      }, {
        time: 2005.8499999999929,
        mm: 19.913635704521237
      }, {
        time: 2005.8999999999928,
        mm: 22.03129582463497
      }, {
        time: 2005.9499999999928,
        mm: 18.317440743356144
      }, {
        time: 2005.9999999999927,
        mm: 19.725095158845217
      }, {
        time: 2006.0499999999927,
        mm: 22.738629159922755
      }, {
        time: 2006.0999999999926,
        mm: 17.544782550283344
      }, {
        time: 2006.1499999999926,
        mm: 18.29826776588348
      }, {
        time: 2006.1999999999925,
        mm: 20.07957708032884
      }, {
        time: 2006.2499999999925,
        mm: 20.725443030710046
      }, {
        time: 2006.2999999999925,
        mm: 28.689084452452917
      }, {
        time: 2006.3499999999924,
        mm: 20.049201040306247
      }, {
        time: 2006.3999999999924,
        mm: 33.12787607661357
      }, {
        time: 2006.4499999999923,
        mm: 18.032189154186995
      }, {
        time: 2006.4999999999923,
        mm: 26.879880575490855
      }, {
        time: 2006.5499999999922,
        mm: 27.966175337986606
      }, {
        time: 2006.5999999999922,
        mm: 18.3544407118249
      }, {
        time: 2006.6499999999921,
        mm: 24.50844341222195
      }, {
        time: 2006.699999999992,
        mm: 18.691452025192042
      }, {
        time: 2006.749999999992,
        mm: 34.704555934620984
      }, {
        time: 2006.799999999992,
        mm: 22.599513393893588
      }, {
        time: 2006.849999999992,
        mm: 33.13097089910198
      }, {
        time: 2006.899999999992,
        mm: 19.42426459222666
      }, {
        time: 2006.9499999999919,
        mm: 23.873776525653962
      }, {
        time: 2006.9999999999918,
        mm: 20.93050206432765
      }, {
        time: 2007.0499999999918,
        mm: 31.545209528324147
      }, {
        time: 2007.0999999999917,
        mm: 25.25323147059744
      }, {
        time: 2007.1499999999917,
        mm: 29.40516663777317
      }, {
        time: 2007.1999999999916,
        mm: 24.137749671683633
      }, {
        time: 2007.2499999999916,
        mm: 22.952227348054084
      }, {
        time: 2007.2999999999915,
        mm: 26.569614793245552
      }, {
        time: 2007.3499999999915,
        mm: 28.973873895627637
      }, {
        time: 2007.3999999999915,
        mm: 26.038055355356217
      }, {
        time: 2007.4499999999914,
        mm: 33.48790207600345
      }, {
        time: 2007.4999999999914,
        mm: 29.1900095847528
      }, {
        time: 2007.5499999999913,
        mm: 25.216337654110596
      }, {
        time: 2007.5999999999913,
        mm: 24.775555868607483
      }, {
        time: 2007.6499999999912,
        mm: 29.992547812621066
      }, {
        time: 2007.6999999999912,
        mm: 29.906922369334055
      }, {
        time: 2007.7499999999911,
        mm: 31.619306852556317
      }, {
        time: 2007.799999999991,
        mm: 35.435816641309415
      }, {
        time: 2007.849999999991,
        mm: 34.45445276718546
      }, {
        time: 2007.899999999991,
        mm: 23.994290321446243
      }, {
        time: 2007.949999999991,
        mm: 29.594922929454924
      }, {
        time: 2007.999999999991,
        mm: 32.218242518852534
      }, {
        time: 2008.0499999999909,
        mm: 21.2582103727037
      }, {
        time: 2008.0999999999908,
        mm: 34.94057999762386
      }, {
        time: 2008.1499999999908,
        mm: 28.81490377885196
      }, {
        time: 2008.1999999999907,
        mm: 26.934959354283485
      }, {
        time: 2008.2499999999907,
        mm: 25.68184116258691
      }, {
        time: 2008.2999999999906,
        mm: 29.27000013607092
      }, {
        time: 2008.3499999999906,
        mm: 32.82175946954303
      }, {
        time: 2008.3999999999905,
        mm: 37.92542795885618
      }, {
        time: 2008.4499999999905,
        mm: 29.86111826577077
      }, {
        time: 2008.4999999999905,
        mm: 29.752246614473055
      }, {
        time: 2008.5499999999904,
        mm: 33.16215081564422
      }, {
        time: 2008.5999999999904,
        mm: 38.39353089627636
      }, {
        time: 2008.6499999999903,
        mm: 34.7390013596042
      }, {
        time: 2008.6999999999903,
        mm: 44.6554557756114
      }, {
        time: 2008.7499999999902,
        mm: 44.670028636136436
      }, {
        time: 2008.7999999999902,
        mm: 32.467832814805
      }, {
        time: 2008.8499999999901,
        mm: 35.21771148916366
      }, {
        time: 2008.89999999999,
        mm: 28.980783637163047
      }, {
        time: 2008.94999999999,
        mm: 29.474242069765115
      }, {
        time: 2008.99999999999,
        mm: 35.70027684910628
      }, {
        time: 2009.04999999999,
        mm: 36.66640748546295
      }, {
        time: 2009.09999999999,
        mm: 38.28125714265353
      }, {
        time: 2009.1499999999899,
        mm: 30.86118387555772
      }, {
        time: 2009.1999999999898,
        mm: 34.14976343207722
      }, {
        time: 2009.2499999999898,
        mm: 30.311590224797307
      }, {
        time: 2009.2999999999897,
        mm: 33.12161381695369
      }, {
        time: 2009.3499999999897,
        mm: 27.202150358392004
      }, {
        time: 2009.3999999999896,
        mm: 32.450665456829846
      }, {
        time: 2009.4499999999896,
        mm: 41.829619335658045
      }, {
        time: 2009.4999999999895,
        mm: 37.79502641904563
      }, {
        time: 2009.5499999999895,
        mm: 37.327501706660456
      }, {
        time: 2009.5999999999894,
        mm: 42.59074289376976
      }, {
        time: 2009.6499999999894,
        mm: 34.713566410332405
      }, {
        time: 2009.6999999999894,
        mm: 33.8454724212374
      }, {
        time: 2009.7499999999893,
        mm: 33.85551755707323
      }, {
        time: 2009.7999999999893,
        mm: 38.44131577360343
      }, {
        time: 2009.8499999999892,
        mm: 34.01133575190159
      }, {
        time: 2009.8999999999892,
        mm: 40.734904554081275
      }, {
        time: 2009.9499999999891,
        mm: 37.69440629874941
      }, {
        time: 2009.999999999989,
        mm: 43.65512099702232
      }, {
        time: 2010.049999999989,
        mm: 44.53855675976268
      }, {
        time: 2010.099999999989,
        mm: 34.580252737624555
      }, {
        time: 2010.149999999989,
        mm: 36.3044869070914
      }, {
        time: 2010.199999999989,
        mm: 34.935323475623214
      }, {
        time: 2010.2499999999889,
        mm: 38.544021319788065
      }, {
        time: 2010.2999999999888,
        mm: 37.69994364087048
      }, {
        time: 2010.3499999999888,
        mm: 37.01352175828303
      }, {
        time: 2010.3999999999887,
        mm: 31.364911225433474
      }, {
        time: 2010.4499999999887,
        mm: 41.92653957695048
      }, {
        time: 2010.4999999999886,
        mm: 39.13930732971747
      }, {
        time: 2010.5499999999886,
        mm: 32.4230503673564
      }, {
        time: 2010.5999999999885,
        mm: 45.92332001275658
      }, {
        time: 2010.6499999999885,
        mm: 45.42805076602833
      }, {
        time: 2010.6999999999884,
        mm: 35.34184620278239
      }, {
        time: 2010.7499999999884,
        mm: 41.96927369628975
      }, {
        time: 2010.7999999999884,
        mm: 55.946105121932945
      }, {
        time: 2010.8499999999883,
        mm: 51.79230227596097
      }, {
        time: 2010.8999999999883,
        mm: 45.46426892020041
      }, {
        time: 2010.9499999999882,
        mm: 45.27959481231892
      }, {
        time: 2010.9999999999882,
        mm: 43.027412523819585
      }, {
        time: 2011.0499999999881,
        mm: 39.8879529362198
      }, {
        time: 2011.099999999988,
        mm: 42.78890561958068
      }, {
        time: 2011.149999999988,
        mm: 40.43630068974813
      }, {
        time: 2011.199999999988,
        mm: 45.5441947549631
      }, {
        time: 2011.249999999988,
        mm: 48.59433430815706
      }, {
        time: 2011.299999999988,
        mm: 44.69424073749984
      }, {
        time: 2011.3499999999879,
        mm: 49.22484372965325
      }, {
        time: 2011.3999999999878,
        mm: 31.32083108929117
      }, {
        time: 2011.4499999999878,
        mm: 45.77863789209616
      }, {
        time: 2011.4999999999877,
        mm: 49.59001066037766
      }, {
        time: 2011.5499999999877,
        mm: 41.420637392649475
      }, {
        time: 2011.5999999999876,
        mm: 51.88379530742566
      }, {
        time: 2011.6499999999876,
        mm: 53.69537450924408
      }, {
        time: 2011.6999999999875,
        mm: 41.64122130895057
      }, {
        time: 2011.7499999999875,
        mm: 50.87074674721288
      }, {
        time: 2011.7999999999874,
        mm: 47.74692871527646
      }, {
        time: 2011.8499999999874,
        mm: 42.003562334542565
      }, {
        time: 2011.8999999999874,
        mm: 45.00064478378242
      }, {
        time: 2011.9499999999873,
        mm: 52.58461914267784
      }, {
        time: 2011.9999999999873,
        mm: 44.48000793743117
      }, {
        time: 2012.0499999999872,
        mm: 49.77313335586189
      }, {
        time: 2012.0999999999872,
        mm: 44.13010614066648
      }, {
        time: 2012.1499999999871,
        mm: 45.17222626974958
      }, {
        time: 2012.199999999987,
        mm: 45.394199326276585
      }, {
        time: 2012.249999999987,
        mm: 40.88614823803925
      }, {
        time: 2012.299999999987,
        mm: 53.819374661543904
      }, {
        time: 2012.349999999987,
        mm: 47.93862079276136
      }, {
        time: 2012.399999999987,
        mm: 48.23538407731764
      }, {
        time: 2012.4499999999869,
        mm: 43.781820026161405
      }, {
        time: 2012.4999999999868,
        mm: 47.65097175733099
      }, {
        time: 2012.5499999999868,
        mm: 46.84727093739718
      }, {
        time: 2012.5999999999867,
        mm: 51.13113606417207
      }, {
        time: 2012.6499999999867,
        mm: 59.62392518885257
      }, {
        time: 2012.6999999999866,
        mm: 55.93657038324557
      }, {
        time: 2012.7499999999866,
        mm: 55.74069731509539
      }, {
        time: 2012.7999999999865,
        mm: 61.29934446303331
      }, {
        time: 2012.8499999999865,
        mm: 49.016392727908006
      }, {
        time: 2012.8999999999864,
        mm: 45.08149281950582
      }, {
        time: 2012.9499999999864,
        mm: 55.66940410520621
      }, {
        time: 2012.9999999999864,
        mm: 62.18171546736599
      }],
      series: [{
        type: 'scatter',
        xKey: 'time',
        yKey: 'mm'
      }]
    };
  }
});
;// CONCATENATED MODULE: ./src/components/agCharts.vue?vue&type=script&lang=js
 
// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js
var exportHelper = __webpack_require__(89);
;// CONCATENATED MODULE: ./src/components/agCharts.vue




;
const __exports__ = /*#__PURE__*/(0,exportHelper/* default */.Z)(agChartsvue_type_script_lang_js, [['render',render]])

/* harmony default export */ var agCharts = (__exports__);
;// CONCATENATED MODULE: ./src/index.ts


const src_element = (0,vue_esm_bundler/* defineCustomElement */.MW)(agCharts);
customElements.define("ag-charts", src_element);
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib-no-default.js



}();
module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=ag-charts.common.js.map